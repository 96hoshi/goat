"""Init DB

Revision ID: 3da99e981cec
Revises: 
Create Date: 2022-03-22 19:21:52.765844

"""
from alembic import op
import sqlalchemy as sa
import geoalchemy2
import sqlmodel  

from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision = '3da99e981cec'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    basic_query_edges_routing = PGFunction(
        schema="basic",
        signature="query_edges_routing(buffer_geom text, modus_input text, scenario_id_input integer, speed_input float, routing_profile TEXT, coordinates_only BOOLEAN)",
        definition='returns text\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tsql_ways_ids text := \'\';\n\tsql_scenario_id text := \'\';\n\tsql_routing_profile text := \'\';\n\tsql_geom text := format(\' AND ST_Intersects(geom, ST_SETSRID(ST_GEOMFROMTEXT(\'\'%1$s\'\'), 4326))\', buffer_geom);\n\texcluded_class_id text;\n\tfilter_categories text;\n\ttransport_mode TEXT := split_part(routing_profile,\'_\',1);\n\tcost_function TEXT;\n\tcategory text := jsonb_build_object(\'walking\',\'foot\',\'cycling\',\'bicycle\') ->> transport_mode;\n\tsql_select_ways text;\n\tsql_cost TEXT;\n\ttime_loss_intersections jsonb := \'{}\'::jsonb;\n\tgeom_column TEXT = \'geom\';\nBEGIN \n\texcluded_class_id = (basic.select_customization(\'excluded_class_id_\' || transport_mode))::text;\n\texcluded_class_id = substr(excluded_class_id, 2, length(excluded_class_id) - 2);\n\n  \tfilter_categories = replace(basic.select_customization(\'categories_no_\' || category)::TEXT, \'"\', \'\'\'\');\n\tfilter_categories = substr(filter_categories, 2, length(filter_categories) - 2);\n\n  \tIF transport_mode IN (\'cycling\',\'ebike\') THEN\n  \t\ttime_loss_intersections = basic.select_customization(\'cycling_crossings_delay\');\n  \tEND IF;\n\t\n\tIF routing_profile = \'cycling_pedelec\' THEN \n\t\tcost_function = \'ebike\';\n\tELSE\n\t\tcost_function = transport_mode;\n\tEND IF;\n\n\tsql_cost = jsonb_build_object(\n\t\'cycling\',\'CASE WHEN crossing IS NOT NULL THEN (\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+COALESCE(s_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s) \n\t\t\t   ELSE (length_m*(1+COALESCE(s_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s END AS cost,\n\t\t\t   CASE WHEN crossing IS NOT NULL THEN (\t\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+COALESCE(rs_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s) \n\t\t\t   ELSE (length_m*(1+COALESCE(rs_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s END AS reverse_cost\',\n\t\'walking\', \'length_m/%1$s as cost, length_m/%1$s as reverse_cost\',\n\t\'ebike\', \'CASE WHEN crossing IS NOT NULL THEN (\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+-greatest(-COALESCE(s_imp,0),0)+COALESCE(impedance_surface,0))::float)/%1$s) \n\t\t\t   ELSE (length_m*(1+COALESCE(impedance_surface,0))::float)/%1$s END AS cost,\n\t\t\t   CASE WHEN crossing IS NOT NULL THEN (\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+-greatest(-COALESCE(rs_imp,0),0)+COALESCE(impedance_surface,0))::float)/%1$s)\n\t\t\t   ELSE (length_m*(1+COALESCE(impedance_surface,0))::float)/%1$s END AS reverse_cost\'\n\t) ->> cost_function;\n\n\tsql_cost = format(sql_cost, speed_input, time_loss_intersections::text);\n\n  \tIF modus_input = \'scenario\' THEN \n\t\tsql_scenario_id = \' AND (scenario_id IS NULL OR scenario_id=\'||scenario_id_input||\')\';\n\t\tsql_ways_ids = \' AND NOT id::int4 = any(\'\'\'|| basic.modified_edges(scenario_id_input)::text ||\'\'\') \';\n\tEND IF;\n\n\tIF  routing_profile = \'walking_safe_night\' THEN\n\t\tsql_routing_profile = \'AND (lit_classified = \'\'yes\'\' OR lit_classified = \'\'unclassified\'\')\';\n\tELSEIF routing_profile = \'walking_wheelchair\' THEN\n\t\tsql_routing_profile = \'AND ((wheelchair_classified = \'\'yes\'\') OR wheelchair_classified = \'\'limited\'\'\n\t\tOR wheelchair_classified = \'\'unclassified\'\')\';\n\tEND IF;\n\t\n\tIF coordinates_only = TRUE THEN\n\t\tgeom_column = \'coordinates_3857\'; \n\tEND IF; \n\n\n\tsql_select_ways = \n\t\t\'SELECT id::integer, source, target, length_3857,\'||sql_cost||\',death_end,\'||quote_ident(geom_column)||\', NULL AS starting_ids, NULL AS starting_geoms\n\t\tFROM basic.edge\n\t\tWHERE class_id NOT IN (\'||excluded_class_id||\')\n    \tAND (\'||quote_ident(category)||\' NOT IN (\'||filter_categories||\') \n\t\tOR \'||quote_ident(category)||\' IS NULL)\n\t\t\'||sql_geom||sql_scenario_id||sql_ways_ids||sql_routing_profile;\n\treturn sql_select_ways;\nEND;\n$function$;\n/*Produces the sql query as text to fetch the network*/\n/*\nSELECT basic.query_edges_routing(ST_ASTEXT(ST_BUFFER(ST_POINT(11.543274,48.195524),0.0018)),\'default\',NULL,1.33,\'walking_standard\',true)\n*/'
    )
    op.create_entity(basic_query_edges_routing)

    basic_create_artificial_edges = PGFunction(
        schema="basic",
        signature="create_artificial_edges(sql_network TEXT, point geometry, snap_distance integer, new_node_id integer, line_part1_id integer)",
        definition="returns TABLE(wid integer, id integer, COST float, reverse_cost float, length_m float, SOURCE integer, target integer, fraction float, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tsql_start_vertices TEXT; \n\trec record;\n\tline_part1 geometry;\n\tline_part2 geometry;\n\tlength_part1 float;\n\tlength_part2 float;\n\tline_part2_id integer; \n\tbuffer geometry; \n\ttotal_length_m float;\nBEGIN \n\t\n\tbuffer = ST_Buffer(point::geography, snap_distance)::geometry;\n  \tsql_start_vertices = 'SELECT ST_LineLocatePoint(geom,$2) AS fraction, \n\tw.geom AS w_geom, w.SOURCE, w.target, w.COST, w.reverse_cost, $3 AS vid, w.id AS wid\n\tFROM \n\t(\n\t\t%1$s\t\n\t) w\n\tWHERE $1 && geom\n\tORDER BY ST_CLOSESTPOINT(geom,$2) <-> $2\n  \tLIMIT 1;';\n  \t\n  \n\tEXECUTE format(sql_start_vertices, sql_network) USING buffer, point, new_node_id INTO rec;\n\n \ttotal_length_m = ST_LENGTH(rec.w_geom::geography);\n\tline_part1 = ST_LINESUBSTRING(rec.w_geom,0,rec.fraction);\n\tline_part2 = ST_LINESUBSTRING(rec.w_geom,rec.fraction,1);\n\tlength_part1 = ST_Length(line_part1::geography);\n\tlength_part2 = total_length_m - length_part1;\n\tline_part2_id = line_part1_id - 1;\n\n  \tRETURN query \n\tWITH pair_artificial AS (\n\t\tSELECT rec.wid, line_part1_id AS id, \n\t\trec.COST * (length_part1 / total_length_m) AS COST,\n\t\trec.reverse_cost * (length_part1 / total_length_m) AS reverse_cost,\n\t\tlength_part1 AS length_m, rec.SOURCE, rec.vid AS target, rec.fraction AS fraction, line_part1 AS geom\n\t\tUNION ALL\n\t\tSELECT rec.wid, line_part2_id AS id,\n\t\trec.COST * (length_part2 / total_length_m) AS COST,\n\t\trec.reverse_cost * (length_part2 / total_length_m) AS reverse_cost,\n\t\tlength_part2, rec.vid AS SOURCE, rec.target, rec.fraction AS fraction, line_part2 AS geom\n\t)\n\tSELECT p.wid, p.id, p.COST, p.reverse_cost, p.length_m, p.SOURCE, p.target, p.fraction, p.geom \n\tFROM pair_artificial p\n\tWHERE p.COST <> 0;\nEND \n$function$;\n/*This function create two artificial edges at starting point \nSELECT * \nFROM basic.create_artificial_edges(\n\tbasic.query_edges_routing(ST_ASTEXT(ST_BUFFER(ST_POINT(11.670883790338209, 48.129792632018706),0.0018)),'default',NULL,1.33,'walking_standard',FALSE),\n\tST_SETSRID(ST_POINT(11.670883790338209, 48.129792632018706), 4326), 100, 1, 1\n); \n */"
    )
    op.create_entity(basic_create_artificial_edges)

    basic_fetch_network_routing = PGFunction(
        schema="basic",
        signature="fetch_network_routing(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns SETOF type_fetch_edges_routing\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tbuffer_starting_point geometry; \n\tbuffer_network geometry;\n\tpoint geometry := ST_SETSRID(ST_POINT(x[1],y[1]), 4326);\n\tsnap_distance_network integer := basic.select_customization('snap_distance_network')::integer;\n\tmax_new_node_id integer := 2147483647;\n\tmax_new_edge_id integer := 2147483647;\nBEGIN \n\n\tSELECT ST_Buffer(point::geography,snap_distance_network)::geometry\n\tINTO buffer_starting_point;\n\n\tSELECT ST_Buffer(point::geography,max_cutoff * speed)::geometry\n\tINTO buffer_network;\n\n\tDROP TABLE IF EXISTS artificial_edges;\n\tCREATE TEMP TABLE artificial_edges AS   \n\tSELECT * \n\tFROM basic.create_artificial_edges(basic.query_edges_routing(ST_ASTEXT(buffer_starting_point),modus,scenario_id,speed,routing_profile,FALSE),point, \n\t\tsnap_distance_network,max_new_node_id, max_new_edge_id \n\t); \n\t\t\n\tRETURN query EXECUTE \n\t'SELECT 0, 0, 0, 0, 0, 0, NULL,''[[1.1,1.1],[1.1,1.1]]''::json, $1, $2\n\t UNION ALL ' || \n\tbasic.query_edges_routing(ST_ASTEXT(buffer_network),modus,scenario_id,speed,routing_profile,True) || \n    ' AND id NOT IN (SELECT wid FROM artificial_edges)\n\tUNION ALL \n\tSELECT id, source, target, ST_LENGTH(ST_TRANSFORM(geom, 3857)) AS length_3857, cost, reverse_cost, NULL AS death_end, ST_AsGeoJSON(ST_Transform(geom,3857))::json->''coordinates'', NULL AS starting_ids, NULL AS starting_geoms\n\tFROM artificial_edges' USING ARRAY[max_new_node_id]::integer[], ARRAY[ST_ASTEXT(point)]::TEXT[];\n\nEND;\n$function$;\n\n/*Fetches the routing network\nSELECT * \nFROM basic.fetch_network_routing(ARRAY[11.543274],ARRAY[48.195524], 1200., 1.33, 'default', 1, 'walking_standard')\n*/"
    )
    op.create_entity(basic_fetch_network_routing)

    basic_fetch_network_routing_heatmap = PGFunction(
        schema="basic",
        signature="fetch_network_routing_heatmap(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns SETOF type_fetch_edges_routing\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tunion_buffer_network geometry;\n\tcnt_starting_points integer := 0;\n\tlength_starting_points integer := array_length(x, 1);\n\tpoint geometry;\nBEGIN \n\t\n\tPERFORM basic.create_multiple_artificial_edges(x, y, max_cutoff, speed, modus, scenario_id, routing_profile);\n\t\n\tDROP TABLE IF EXISTS buffer_network; \n\tCREATE TEMP TABLE buffer_network (id serial, geom geometry);\n\t\n\tDROP TABLE IF EXISTS buffer_starting_points;\n\tCREATE TEMP TABLE buffer_starting_points(geom geometry);\n\n\t/*Loop through starting points*/\n\tWHILE cnt_starting_points < length_starting_points \n\tLOOP\n\t\tcnt_starting_points = cnt_starting_points + 1;\n\t\tpoint = ST_SETSRID(ST_POINT(x[cnt_starting_points],y[cnt_starting_points]), 4326);\n\t\t\n\t\tINSERT INTO buffer_network(geom) \n\t\tSELECT ST_Buffer(point::geography,max_cutoff * speed)::geometry;\n\t\t\n\t\tINSERT INTO buffer_starting_points(geom)\n\t\tSELECT ST_BUFFER(point, 0.000000001); \n\tEND LOOP; \n\t\n\tCREATE INDEX ON buffer_starting_points USING GIST(geom); \n\n\tunion_buffer_network  = (SELECT ST_UNION(b.geom) FROM buffer_network b);\n\t\n\tDROP TABLE IF EXISTS batch_artificial_edges; \n\tCREATE TEMP TABLE batch_artificial_edges AS\n\tSELECT *\n\tFROM temporal.heatmap_edges_artificial a\n\tWHERE ST_Intersects(a.geom, union_buffer_network); \n\t\n\tDROP TABLE IF EXISTS batch_starting_vertices; \n\tCREATE TEMP TABLE batch_starting_vertices AS\n\tSELECT v.*\n\tFROM temporal.heatmap_starting_vertices v, buffer_starting_points s  \n\tWHERE ST_Intersects(v.geom, s.geom); \n\n\t/*Fetch Network*/\n\tRETURN query EXECUTE \n\t'SELECT 1, 1, 1, 1, 1, 1, NULL, ''[[1.1,1.1],[1.1,1.1]]''::json, $1, $2\n\t UNION ALL ' || \n\tbasic.query_edges_routing(ST_ASTEXT(union_buffer_network),modus,scenario_id,speed,routing_profile,True) || \n    ' AND id NOT IN (SELECT wid FROM batch_artificial_edges)\n\tUNION ALL \n\tSELECT id, source, target, ST_LENGTH(ST_TRANSFORM(geom, 3857)) AS length_3857, cost, reverse_cost, \n\tNULL AS death_end, ST_AsGeoJSON(ST_Transform(geom,3857))::json->''coordinates'', NULL AS starting_ids, NULL AS starting_geoms\n\tFROM batch_artificial_edges' USING (SELECT array_agg(s.id) FROM batch_starting_vertices s), (SELECT array_agg(ST_ASTEXT(s.geom)) FROM batch_starting_vertices s); \n\nEND;\n$function$;\n\n/*\nWITH p AS \n(\n\tSELECT ST_CENTROID(geom) geom \n\tFROM temporal.heatmap_grid_helper h \n\tWHERE cid = 0\n),\nagg AS \n(\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p  \n)\nSELECT n.* \nFROM agg, \nLATERAL basic.fetch_network_routing_heatmap(x,y, 1200., 1.33, 'default', 1, 'walking_standard') n\n*/"
    )
    op.create_entity(basic_fetch_network_routing_heatmap)

    basic_fix_multiple_artificial_edges = PGFunction(
        schema="basic",
        signature="fix_multiple_artificial_edges(wid integer, s integer, t integer, c float, rc float, w_geom geometry, vids integer[],fractions float[])",
        definition='returns TABLE (edge_id integer, COST float, reverse_cost float, SOURCE integer, target integer, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tstart_fraction float := 0;\n\tsource_id integer := s;\n\tend_fraction float;\n\tstart_id integer := s;\n\tcnt integer := 1;\nBEGIN \n\tfractions = array_append(fractions,1::float);\n\tvids = array_append(vids,t);\n\n\tFOREACH end_fraction IN ARRAY fractions\n\tLOOP \n\t\tRETURN query\n\t\tWITH parts AS \n\t\t(\n\t\t\tSELECT wid, c*(end_fraction-start_fraction) AS cost,rc*(end_fraction-start_fraction) AS reverse_cost, \n\t\t\tsource_id AS source, vids[cnt] AS target, ST_LINESUBSTRING(w_geom,start_fraction,end_fraction) AS geom\n\t\t)\n\t\tSELECT p.wid, p.cost, p.reverse_cost, p.source, p.target, p.geom\n\t\tFROM parts p\n\t\tWHERE p.cost <> 0;  \n\n\t\tstart_fraction = end_fraction;\n\t\tsource_id = vids[cnt];\n\t\tedge_id = edge_id - 1;\n\t\tcnt = cnt + 1;\n\tEND LOOP;\n\tRETURN; \nEND \n$function$'
    )
    op.create_entity(basic_fix_multiple_artificial_edges)

    basic_create_multiple_artificial_edges = PGFunction(
        schema="basic",
        signature="create_multiple_artificial_edges(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns VOID \n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tbuffer_starting_point geometry; \n\tunion_buffer_network geometry;\n\tpoint geometry; \n\tsnap_distance_network integer := basic.select_customization('snap_distance_network')::integer;\n\tcnt_starting_points integer := 0;\n\tlength_starting_points integer := array_length(x, 1);\n\tmax_new_node_id integer := 2147483647;\n\tmax_new_edge_id integer := 2147483647;\nBEGIN \n\t\n\t/*Prepare temporary tables*/\n\tDROP TABLE IF EXISTS artificial_edges; \n\tCREATE TEMP TABLE artificial_edges (\n\t\twid integer, \n\t\tid integer, \n\t\tCOST float, \n\t\treverse_cost float, \n\t\tlength_m float, \n\t\tSOURCE integer, \n\t\ttarget integer, \n\t\tfraction float, \n\t\tgeom geometry, \n\t\tvid integer, \n\t\tpoint_geom geometry\n\t); \n\n\tDROP TABLE IF EXISTS duplicated_artificial_edges; \n\tCREATE TEMP TABLE duplicated_artificial_edges (LIKE artificial_edges); \n\n\tDROP TABLE IF EXISTS buffer_network; \n\tCREATE TEMP TABLE buffer_network (id serial, geom geometry);\n\t\n\t/*Loop through starting points*/\n\tWHILE cnt_starting_points < length_starting_points \n\tLOOP\n\t\tcnt_starting_points = cnt_starting_points + 1;\n\t\tpoint = ST_SETSRID(ST_POINT(x[cnt_starting_points],y[cnt_starting_points]), 4326);\n\t\t\n\t\tSELECT ST_SETSRID(ST_Buffer(point::geography,snap_distance_network)::geometry, 4326)\n\t\tINTO buffer_starting_point;\t\n\t\t\n\t\tINSERT INTO artificial_edges\n\t\tSELECT c.*, max_new_node_id, point AS point_geom  \n\t\tFROM basic.create_artificial_edges(basic.query_edges_routing(ST_ASTEXT(buffer_starting_point),modus,scenario_id,speed,routing_profile,FALSE),\n\t\t\tpoint, snap_distance_network, max_new_node_id, max_new_edge_id  \n\t\t) c; \n\n\t\tINSERT INTO buffer_network(geom) \n\t\tSELECT ST_Buffer(point::geography,max_cutoff * speed)::geometry;\n\t\t\n\t\tmax_new_node_id = max_new_node_id - 1;\n\t\tmax_new_edge_id = max_new_edge_id - 2; \n\tEND LOOP; \n\t\n\tunion_buffer_network  = (SELECT ST_UNION(b.geom) FROM buffer_network b);\n\t\n\tDROP TABLE IF EXISTS starting_vertices; \n\tCREATE TEMP TABLE starting_vertices (id integer, geom geometry);\n\n\t/*Identify duplicates and unique artificial edges */\n\tDROP TABLE IF EXISTS final_artificial_edges; \n\tCREATE TEMP TABLE final_artificial_edges AS \n\tWITH cnt_artificial_edges AS \n\t(\n\t\tSELECT a.wid, count(*)::integer AS cnt \n\t\tFROM artificial_edges a  \n\t\tGROUP BY a.wid\n\t),\t\n\tnot_duplicates AS \n\t(\n\t\tSELECT a.wid, a.vid, a.id, a.COST, a.reverse_cost, a.length_m, a.SOURCE, a.target, a.geom, a.point_geom  \n\t\tFROM artificial_edges a, cnt_artificial_edges c\n\t\tWHERE a.wid = c.wid \n\t\tAND c.cnt <= 2\n\t),\n\tinsert_not_duplicates AS \n\t(\n\t\tINSERT INTO starting_vertices \n\t\tSELECT DISTINCT vid, point_geom \n\t\tFROM not_duplicates \t\n\t),\n\tinsert_duplicates AS \n\t(\n\t\tINSERT INTO duplicated_artificial_edges\n\t\tSELECT a.* \n\t\tFROM artificial_edges a, cnt_artificial_edges c\n\t\tWHERE a.wid = c.wid \n\t\tAND c.cnt > 2 \n\t)\n\tSELECT n.wid, n.id, n.COST, n.reverse_cost, n.length_m, n.SOURCE, n.target, n.geom, n.point_geom  \n\tFROM not_duplicates n; \n\t\n\t/*Handle duplicated artificial edges*/\n\tDROP TABLE IF EXISTS cleaned_duplicates; \n\tCREATE TEMP TABLE cleaned_duplicates AS \n\tWITH sum_costs AS \n\t(\n\t\tSELECT d.vid, round(SUM(d.COST::numeric), 4) AS cost, round(SUM(d.reverse_cost::numeric), 4) AS reverse_cost\n\t\tFROM duplicated_artificial_edges d \n\t\tGROUP BY d.vid\n\t),\n\tordered AS \n\t(\n\t\tSELECT DISTINCT d.wid, d.vid, d.fraction, s.COST, s.reverse_cost, d.point_geom  \n\t\tFROM duplicated_artificial_edges d, sum_costs s  \n\t\tWHERE d.vid = s.vid \n\t\tAND d.fraction NOT IN (0,1)\n\t\tORDER BY d.wid, d.fraction \n\t),\n\tinsert_distinct_starting_points AS \n\t(\n\t\tINSERT INTO starting_vertices \n\t\tSELECT o.vid, point_geom  \n\t\tFROM ordered o\n\t),\n\tgrouped AS \n\t(\t\n\t\tSELECT g.wid, array_agg(g.vid) vids, array_agg(g.fraction) fractions\n\t\tFROM ordered g  \n\t\tGROUP BY g.wid\n\t),\n\tdistinct_costs AS \n\t(\n\t\tSELECT DISTINCT o.wid, o.COST, o.reverse_cost\n\t\tFROM ordered o\n\t),\n\tdistinct_duplicated_edges AS \n\t(\n\t\tSELECT g.wid, o.COST, o.reverse_cost, g.vids, g.fractions, e.SOURCE, e.target, e.geom\n\t\tFROM grouped g\n\t\tLEFT JOIN distinct_costs o\n\t\tON g.wid = o.wid \n\t\tLEFT JOIN basic.edge e \n\t\tON g.wid = e.id \n\t)\n\tSELECT edge_id AS wid, (max_new_edge_id - ROW_NUMBER() OVER()) AS id, f.COST, f.reverse_cost,\n\tST_LENGTH(f.geom::geography) AS length_m, f.SOURCE, f.target, f.geom, NULL AS point_geom  \n\tFROM distinct_duplicated_edges d, \n\tLATERAL basic.fix_multiple_artificial_edges(d.wid, d.SOURCE, d.target, d.COST, d.reverse_cost, d.geom, d.vids, d.fractions) f; \n\t\n\tUPDATE cleaned_duplicates d\n\tSET point_geom = s.geom \n\tFROM starting_vertices s  \n\tWHERE d.SOURCE = s.id;\n\n\tUPDATE cleaned_duplicates d\n\tSET point_geom = s.geom \n\tFROM starting_vertices s  \n\tWHERE d.target = s.id;\n\n\tINSERT INTO final_artificial_edges \n\tSELECT * FROM cleaned_duplicates; \n\nEND;\n$function$;\n\n/*\nWITH p AS \n(\n\tSELECT ST_CENTROID(geom) AS geom \n\tFROM basic.grid_calculation\n\tLIMIT 10\n),\nagg AS \n(\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p  \n)\nSELECT basic.create_multiple_artificial_edges(x, y, 1200., 1.33, 'default', 1, 'walking_standard') a\nFROM agg \n*/"
    )
    op.create_entity(basic_create_multiple_artificial_edges)

    basic_fetch_network_routing_multi = PGFunction(
        schema="basic",
        signature="fetch_network_routing_multi(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns SETOF type_fetch_edges_routing\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tunion_buffer_network geometry;\nBEGIN \n\t\n\tPERFORM basic.create_multiple_artificial_edges(x, y, max_cutoff, speed, modus, scenario_id, routing_profile);\n\tunion_buffer_network  = (SELECT ST_UNION(geom) FROM buffer_network);\n\t\n\t/*Fetch Network*/\n\tRETURN query EXECUTE \n\t'SELECT 1, 1, 1, 1, 1, 1, NULL, ''[[1.1,1.1],[1.1,1.1]]''::json, $1, $2\n\t UNION ALL ' || \n\tbasic.query_edges_routing(ST_ASTEXT(union_buffer_network),modus,scenario_id,speed,routing_profile,True) || \n    ' AND id NOT IN (SELECT wid FROM artificial_edges)\n\tUNION ALL \n\tSELECT id, source, target, ST_LENGTH(ST_TRANSFORM(geom, 3857)) AS length_3857, cost, reverse_cost, NULL AS death_end, ST_AsGeoJSON(ST_Transform(geom,3857))::json->''coordinates'', NULL AS starting_ids, NULL AS starting_geoms\n\tFROM artificial_edges' USING (SELECT array_agg(s.id) FROM starting_vertices s), (SELECT array_agg(ST_ASTEXT(s.geom)) FROM starting_vertices s); \n\nEND;\n$function$;\n\n/*\nWITH p AS \n(\n\tSELECT geom\n\tFROM basic.poi \n\tLIMIT 100\n),\nagg AS \n(\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p  \n)\nSELECT n.* \nFROM agg, \nLATERAL basic.fetch_network_routing_multi(x,y, 1200., 1.33, 'default', 1, 'walking_standard') n \n*/"
    )
    op.create_entity(basic_fetch_network_routing_multi)

    basic_select_customization = PGFunction(
        schema="basic",
        signature="select_customization(setting_type text)",
        definition="returns jsonb\n LANGUAGE sql\nAS $function$\n\n\tSELECT setting -> c.type\n\tFROM customer.customization c \n\tWHERE c.type = setting_type;\n\n$function$ IMMUTABLE;\n/*\nSELECT basic.select_customization('categories_no_foot');\n*/"
    )
    op.create_entity(basic_select_customization)

    basic_extend_line = PGFunction(
        schema="basic",
        signature="extend_line(geom geometry, extend_distance NUMERIC, point_to_extend text)",
        definition="returns geometry \nLANGUAGE plpgsql\nAS $function$\nDECLARE\n\tstart_geom geometry; \n\tend_geom geometry;\n\tazimuth_A float;\n\tazimuth_B float;\n\tlength_A NUMERIC;\n\tlength_B NUMERIC;\n\tnewpoint_A geometry;\n\tnewpoint_B geometry;\n\tnew_line geometry; \nBEGIN \n\t\t\n\t-- get the points A and B given a line L\n\tstart_geom = ST_STARTPOINT(geom);\n\tend_geom = ST_ENDPOINT(geom);\n\t\t\n\t-- Start line section\n\tazimuth_A = ST_AZIMUTH(ST_POINTN(geom,2),start_geom);\n\n\t-- End line section \n\tazimuth_B = ST_AZIMUTH(ST_POINTN(geom,-2),end_geom);\n\t\n\t-- get the length of the line A --> B\n\tlength_A = ST_DISTANCE(ST_STARTPOINT(geom),ST_POINTN(geom,2));\n\tlength_B = ST_DISTANCE(ST_ENDPOINT(geom),ST_POINTN(geom,-2));\n\t\n\tnewpoint_A = ST_TRANSLATE(start_geom, sin(azimuth_A) * extend_distance, cos(azimuth_A) * extend_distance);\n\tnewpoint_B = ST_TRANSLATE(end_geom, sin(azimuth_B) * extend_distance, cos(azimuth_B) * extend_distance);\n\t\n\tIF point_to_extend = 'start' THEN\n\t\tnew_line = st_addpoint(geom,newpoint_a, 0);\n\tELSEIF point_to_extend = 'end' THEN \n\t\tnew_line = st_addpoint(geom,newpoint_b, -1);\n\tELSEIF point_to_extend = 'both' THEN \n\t\tnew_line = st_addpoint(st_addpoint(geom,newpoint_B),newpoint_A,0);\n\tELSE \n\t\tRAISE EXCEPTION 'Please specify a valid point_to_extend type.';\n\tEND IF; \n\n\tRETURN new_line;\nEND\n$function$\n/*point_to_extend = 'start', 'end', 'both'*/\n--1 meter in Germany approx. 0.0000127048\n--SELECT basic.extend_line(geom, 0.0127048, 'both') \n--FROM customer.way_modified WHERE id = 112"
    )
    op.create_entity(basic_extend_line)

    basic_modified_edges = PGFunction(
        schema="basic",
        signature="modified_edges(scenario_id_input integer)",
        definition="returns INTEGER[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_features integer[];\nBEGIN \n\n\tmodified_features = \n\t(\n\t\tWITH ids AS \n\t\t(\n\t\t\tSELECT DISTINCT way_id \n\t\t\tFROM customer.way_modified  \n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND way_id IS NOT NULL \n\t\t\tAND edit_type IN ('d', 'm')\n\t\t)\n\t\tSELECT COALESCE(ARRAY_AGG(way_id), array[]::integer[]) \n\t\tFROM ids\n\t);\n\t\n\tRETURN modified_features;\n\t\nEND;\n$function$\n/*\nSELECT * FROM basic.modified_edges(1)\n*/"
    )
    op.create_entity(basic_modified_edges)

    basic_poi_categories = PGFunction(
        schema="basic",
        signature="poi_categories(user_id_input integer)",
        definition="returns jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tdefault_setting jsonb := basic.select_customization('poi_groups');\n\tuser_setting jsonb := basic.select_user_customization(user_id_input, 'poi_groups');\n\tclassified_pois jsonb; \nBEGIN \n\t\n\tDROP TABLE IF EXISTS poi_groups_default; \n\tCREATE TEMP TABLE poi_groups_default AS \n\tWITH poi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(default_setting) poi_group\n\t)\n\tSELECT jsonb_array_elements(p.poi_group -> jsonb_object_keys(p.poi_group) -> 'children') AS poi_category \n\tFROM poi_groups p;\n\n\tDROP TABLE IF EXISTS poi_groups_user; \n\tCREATE TEMP TABLE poi_groups_user AS \n\tWITH poi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(user_setting) poi_group\n\t)\n\tSELECT jsonb_array_elements(p.poi_group -> jsonb_object_keys(p.poi_group) -> 'children') AS poi_category \n\tFROM poi_groups p; \n\t\n\tclassified_pois = (\n\t\tWITH poi_categories AS \n\t\t(\t\n\t\t\tSELECT jsonb_object_keys(p.poi_category) AS poi_category, (p.poi_category -> jsonb_object_keys(p.poi_category) -> 'multiple_entrance') AS multiple_entrance \n\t\t\tFROM poi_groups_default p\n\t\t\tUNION ALL \n\t\t\tSELECT jsonb_object_keys(p.poi_category) AS poi_category, (p.poi_category -> jsonb_object_keys(p.poi_category) -> 'multiple_entrance') AS multiple_entrance \n\t\t\tFROM poi_groups_user p\n\t\t),\n\t\t\n\t\tpoi_classified AS \n\t\t(\n\t\t\tSELECT COALESCE(multiple_entrance::BOOLEAN, FALSE) multiple_entrance, array_agg(poi_category) arr_pois \n\t\t\tFROM (SELECT DISTINCT * FROM poi_categories) p \n\t\t\tGROUP BY multiple_entrance\n\t\t) \n\t\tSELECT jsonb_object_agg(multiple_entrance, arr_pois)\n\t\tFROM poi_classified\n\t); \n\tRETURN classified_pois; \nEND ;\n$function$\n\n\n/* Function that returns the default and user poi categories grouped into multiple_entrance and single_entrance\\:\nSELECT basic.poi_categories(1) \n*/"
    )
    op.create_entity(basic_poi_categories)

    basic_select_user_customization = PGFunction(
        schema="basic",
        signature="select_user_customization(user_id_input integer, setting_type text)",
        definition="returns jsonb\n LANGUAGE sql\nAS $function$\n\n\tSELECT u.setting -> c.type\n\tFROM customer.customization c, customer.user_customization u \n\tWHERE c.type = setting_type \n\tAND u.customization_id = c.id\n\tAND u.user_id = user_id_input;\n\n$function$ IMMUTABLE;\n/*\nSELECT select_user_customization(1, 'poi_groups');\n*/"
    )
    op.create_entity(basic_select_user_customization)

    basic_create_intersection_line = PGFunction(
        schema="basic",
        signature="create_intersection_line(point_geom geometry, length_line double precision)",
        definition='returns SETOF geometry\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n\tSELECT ST_SETSRID(ST_MAKELINE(\n\t\tST_Translate(point_geom, length_line, length_line),\n\t\tST_Translate(point_geom, -length_line, -length_line)\n\t), 4326)\n$function$'
    )
    op.create_entity(basic_create_intersection_line)

    basic_modified_pois = PGFunction(
        schema="basic",
        signature="modified_pois(scenario_id_input integer)",
        definition="returns TEXT[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_features text[];\nBEGIN \n\n\tmodified_features = \n\t(\n\t\tWITH ids AS \n\t\t(\n\t\t\tSELECT uid \n\t\t\tFROM customer.poi_modified p \t\n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND edit_type IN ('d', 'm')\n\t\t)\n\t\tSELECT COALESCE(ARRAY_AGG(uid), array[]::text[]) \n\t\tFROM ids\n\t);\n\t\n\tRETURN modified_features;\n\t\nEND;\n$function$\n/*\nSELECT * FROM basic.modified_pois(75)\n*/"
    )
    op.create_entity(basic_modified_pois)

    basic_create_snapped_split_line = PGFunction(
        schema="basic",
        signature="create_snapped_split_line(geom geometry, extend_distance NUMERIC, point_to_extend text)",
        definition="returns geometry \nLANGUAGE plpgsql\nAS $function$\nDECLARE\n\tstart_geom geometry; \n\tend_geom geometry;\n\tazimuth_A float;\n\tazimuth_B float;\n\tlength_A NUMERIC;\n\tlength_B NUMERIC;\n\tnewpoint_A geometry;\n\tnewpoint_B geometry;\n\tnew_line geometry; \nBEGIN \n\t\t\n\t-- get the points A and B given a line L\n\tstart_geom = ST_STARTPOINT(geom);\n\tend_geom = ST_ENDPOINT(geom);\n\t\t\n\t-- Start line section\n\tazimuth_A = ST_AZIMUTH(ST_POINTN(geom,2),start_geom);\n\n\t-- End line section \n\tazimuth_B = ST_AZIMUTH(ST_POINTN(geom,-2),end_geom);\n\t\n\t-- get the length of the line A --> B\n\tlength_A = ST_DISTANCE(ST_STARTPOINT(geom),ST_POINTN(geom,2));\n\tlength_B = ST_DISTANCE(ST_ENDPOINT(geom),ST_POINTN(geom,-2));\n\t\n\tnewpoint_A = ST_TRANSLATE(start_geom, sin(azimuth_A) * extend_distance, cos(azimuth_A) * extend_distance);\n\tnewpoint_B = ST_TRANSLATE(end_geom, sin(azimuth_B) * extend_distance, cos(azimuth_B) * extend_distance);\n\t\n\tIF point_to_extend = 'start' THEN\n\t\tnew_line = ST_MAKELINE(start_geom,newpoint_A);\n\tELSEIF point_to_extend = 'end' THEN \n\t\tnew_line = ST_MAKELINE(end_geom,newpoint_B);\n\tELSE\n\t\tRAISE EXCEPTION 'Please specify a valid point_to_extend type.';\n\tEND IF; \n\n\tRETURN new_line;\nEND\n$function$\n/*point_to_extend = 'start', 'end'*/\n--1 meter in Germany approx. 0.0000127048\n/*\nSELECT basic.create_snapped_split_line(geom, 0.0000127048, 'start') \nFROM customer.way_modified WHERE id = 112;\n*/"
    )
    op.create_entity(basic_create_snapped_split_line)

    basic_modified_buildings = PGFunction(
        schema="basic",
        signature="modified_buildings(scenario_id_input integer)",
        definition="returns INTEGER[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_features integer[];\nBEGIN \n\n\tmodified_features = \n\t(\n\t\tWITH ids AS \n\t\t(\n\t\t\tSELECT DISTINCT building_id \n\t\t\tFROM customer.building_modified   \n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND building_id IS NOT NULL \n\t\t\tAND edit_type IN ('d')\n\t\t)\n\t\tSELECT COALESCE(ARRAY_AGG(building_id), array[]::integer[]) \n\t\tFROM ids\n\t);\n\t\n\tRETURN modified_features;\n\t\nEND;\n$function$\n/*\nSELECT * FROM basic.modified_buildings(1)\n*/"
    )
    op.create_entity(basic_modified_buildings)

    basic_create_perpendicular_line = PGFunction(
        schema="basic",
        signature="create_perpendicular_line(line_geom geometry, point_geom geometry, length_line float)",
        definition='returns SETOF geometry AS\n$func$\n\n\tSELECT ST_SETSRID(\n\t\t\tST_MAKELINE(\n\t\t\t\tST_MAKEPOINT(x2+length_line,y2+(-1/((y2-y1)/(x2-x1)))*length_line), \n\t\t\t\tST_MAKEPOINT(x2-length_line,y2-(-1/((y2-y1)/(x2-x1)))*length_line)\n\t\t\t),4326)\n\tFROM (\n\t\tSELECT ST_X(st_startpoint(line_geom)) x1, ST_Y(st_startpoint(line_geom)) y1, ST_X(point_geom) x2, ST_Y(point_geom) y2 \n\t) x_y\n$func$  LANGUAGE sql IMMUTABLE'
    )
    op.create_entity(basic_create_perpendicular_line)

    basic_heatmap_local_accessibility = PGFunction(
        schema="basic",
        signature="heatmap_local_accessibility(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition='returns TABLE(grid_visualization_id bigint, percentile_accessibility integer, accessibility_index bigint, modus text, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tborders_quintiles bigint[]; \nBEGIN\n\t\n\tDROP TABLE IF EXISTS heatmap_default; \n\tCREATE TEMP TABLE heatmap_default AS\n\tWITH grouped AS \n\t(\n\t\tSELECT h.grid_visualization_id, sum(h.accessibility_index) AS accessibility_index \n\t\tFROM basic.prepare_heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'default\', scenario_id_input, data_upload_ids) h\n\t\tGROUP BY h.grid_visualization_id \t\n\t)\n\tSELECT g.id AS grid_visualization_id, \n\tCOALESCE(h.percentile_accessibility,0) AS percentile_accessibility, COALESCE(h.accessibility_index, 0)::bigint AS accessibility_index, \'default\' AS modus, g.geom  \n\tFROM basic.grid_visualization g\n\tLEFT JOIN (\n\t\tSELECT h.grid_visualization_id, ntile(5) over (order by h.accessibility_index) AS percentile_accessibility, h.accessibility_index \n\t\tFROM grouped h\n\t\tWHERE h.accessibility_index IS NOT NULL \n\t) h\n\tON g.id = h.grid_visualization_id;\t\n\t\n\tIF modus_input IN (\'scenario\',\'comparison\') THEN  \n\t\tSELECT array_agg(border)\n\t\tINTO borders_quintiles\n\t\tFROM \n\t\t(\n\t\t\tSELECT min(h.accessibility_index) border\n\t\t\tFROM heatmap_default h\n\t\t\tWHERE h.accessibility_index <> 0\n\t\t\tGROUP BY h.percentile_accessibility \n\t\t\tORDER BY h.percentile_accessibility\n\t\t) b;\n\t\t\n\t\tDROP TABLE IF EXISTS heatmap_scenario;\n\t\tCREATE TEMP TABLE heatmap_scenario AS \n\t\tWITH grouped AS \n\t\t(\n\t\t\tSELECT h.grid_visualization_id, sum(h.accessibility_index) AS accessibility_index \n\t\t\tFROM basic.prepare_heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'scenario\', scenario_id_input, data_upload_ids) h\n\t\t\tGROUP BY h.grid_visualization_id \t\n\t\t),\n\t\twith_geom AS\n\t\t(\n\t\t\tSELECT g.id AS grid_visualization_id, COALESCE(h.accessibility_index, 0) AS accessibility_index, \'scenario\' AS modus, g.geom  \n\t\t\tFROM basic.grid_visualization g\n\t\t\tLEFT JOIN grouped h \n\t\t\tON g.id = h.grid_visualization_id\n\t\t)\t\t\n\t\tSELECT h.grid_visualization_id, \n\t\tCASE WHEN h.accessibility_index = 0 THEN 0\n\t\tWHEN h.accessibility_index > 0 AND h.accessibility_index < borders_quintiles[2] THEN 1\n\t\tWHEN h.accessibility_index >= borders_quintiles[2] AND h.accessibility_index < borders_quintiles[3] THEN 2\n\t\tWHEN h.accessibility_index >= borders_quintiles[3] AND h.accessibility_index < borders_quintiles[4] THEN 3\n\t\tWHEN h.accessibility_index >= borders_quintiles[4] AND h.accessibility_index < borders_quintiles[5] THEN 4\n\t\tWHEN h.accessibility_index >= borders_quintiles[5] THEN 5\n\t\tEND AS percentile_accessibility, h.accessibility_index::bigint, h.modus, h.geom  \n\t\tFROM with_geom h; \n\t\n\tEND IF; \n\t\n\tIF modus_input = \'comparison\' THEN \n\n\t\tALTER TABLE heatmap_default ADD PRIMARY KEY(grid_visualization_id);\n\t\tALTER TABLE heatmap_scenario ADD PRIMARY KEY(grid_visualization_id);\n\t\t\n\t\tDROP TABLE IF EXISTS heatmap_comparison;\n\t\tCREATE TEMP TABLE heatmap_comparison AS \n\t\tWITH with_geom AS  \n\t\t(\n\t\t\tSELECT d.grid_visualization_id, (s.percentile_accessibility - d.percentile_accessibility ) AS percentile_accessibility, \n\t\t\tCOALESCE(s.accessibility_index - d.accessibility_index,0) AS accessibility_index, \'comparison\' AS modus, d.geom\n\t\t\tFROM heatmap_default d, heatmap_scenario s \n\t\t\tWHERE d.grid_visualization_id = s.grid_visualization_id\n\t\t) \n\t\tSELECT h.grid_visualization_id, ntile(10) over (order by h.accessibility_index) AS percentile_accessibility, h.accessibility_index, h.modus, h.geom  \n\t\tFROM with_geom h\n\t\tWHERE h.accessibility_index <> 0\n\t\tUNION ALL \n\t\tSELECT h.grid_visualization_id, 0, h.accessibility_index, h.modus, h.geom   \n\t\tFROM with_geom h\n\t\tWHERE h.accessibility_index = 0; \n\t\t\n\tEND IF;\n\n\tIF modus_input = \'default\' THEN \n\t\tRETURN query \n\t\tSELECT * \n\t\tFROM heatmap_default;\n\tELSEIF modus_input = \'scenario\' THEN \n\t\tRETURN query \n\t\tSELECT * \n\t\tFROM heatmap_scenario;\n\tELSEIF modus_input = \'comparison\' THEN \n\t\tRETURN query \n\t\tSELECT * \n\t\tFROM heatmap_comparison;\n\tEND IF; \nEND\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_table; \nCREATE TABLE default_table AS \nSELECT * \nFROM basic.heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'default\',11, \'{}\'::integer[]) h;\n\nDROP TABLE IF EXISTS scenario_table; \nCREATE TABLE scenario_table AS \nSELECT * \nFROM basic.heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'scenario\',11, \'{}\'::integer[]) h;\n\nDROP TABLE IF EXISTS comparison_table; \nCREATE TABLE comparison_table AS \nSELECT * \nFROM basic.heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'comparison\',11, \'{}\'::integer[]) h;\n*/'
    )
    op.create_entity(basic_heatmap_local_accessibility)

    basic_starting_points_multi_isochrones = PGFunction(
        schema="basic",
        signature="starting_points_multi_isochrones(modus text, minutes integer, speed_input numeric, amenities text[], scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[], region TEXT DEFAULT NULL, study_area_ids integer[] DEFAULT NULL)",
        definition="returns TABLE (x float[], y float[])\nAS $function$\n\nDECLARE \n\texcluded_pois_id text[] := ARRAY[]::text[];\n\tregion_geom geometry;  \n\tbuffer_geom geometry; \nBEGIN \n\n\tIF region IS NULL AND study_area_ids IS NOT NULL THEN\n        SELECT ST_UNION(s.geom)   \n        INTO region_geom\n        FROM basic.sub_study_area s\n        WHERE s.id IN (SELECT UNNEST(study_area_ids));\n    ELSEIF region IS NOT NULL AND study_area_ids IS NULL THEN\n        SELECT ST_GeomFromText(region) AS geom  \n        INTO region_geom;\n    ELSE \n        RAISE EXCEPTION 'Please specify either region or study_area_ids but not both.';\n    END IF;\n\t\n   \tbuffer_geom = ST_Buffer(region_geom::geography, speed_input  * 60 * minutes)::geometry;\n   \n\tIF modus = 'scenario' THEN\n        excluded_pois_id = basic.modified_pois(scenario_id_input);\n    END IF;\n\t\n\n   \tRETURN QUERY \n   \tWITH relevant_pois AS \n   \t(\n\t\tSELECT ST_X(p.geom) x, ST_Y(p.geom) y\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT ST_X(p.geom) x, ST_Y(p.geom) y \n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT ST_X(p.geom) x, ST_Y(p.geom) y\n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.scenario_id = scenario_id_input\n\t)\n\tSELECT ARRAY_AGG(r.x) AS x, ARRAY_AGG(r.y) AS y \n\tFROM relevant_pois r;\n\t\nEND; \n$function$\nLANGUAGE plpgsql;\n\n/*\nSELECT * \nFROM basic.starting_points_multi_isochrones('default', 10, 1.33, ARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 0, ARRAY[0], NULL, ARRAY[1,2,3,4])\n */"
    )
    op.create_entity(basic_starting_points_multi_isochrones)

    basic_heatmap_population = PGFunction(
        schema="basic",
        signature="heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population float, percentile_population integer, modus text, geom geometry)\nLANGUAGE plpgsql\nAS $function$\nBEGIN \n\t\n\tIF modus_input IN ('default', 'comparison') THEN \n\t\tDROP TABLE IF EXISTS population_default;\n\t\tCREATE TEMP TABLE population_default AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'default', scenario_id_input);\n\tEND IF; \n\tIF modus_input IN ('scenario','comparison') THEN \n\t\tDROP TABLE IF EXISTS population_scenario;\n\t\tCREATE TEMP TABLE population_scenario AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'scenario', scenario_id_input);\n\tEND IF;\n\tIF modus_input IN ('comparison') THEN \n\t\tALTER TABLE population_default ADD PRIMARY KEY(grid_visualization_id); \n\t\tALTER TABLE population_scenario ADD PRIMARY KEY(grid_visualization_id); \n\t\tDROP TABLE IF EXISTS population_comparison;\n\t\t\n\t\tCREATE TEMP TABLE population_comparison AS \n\t\tWITH pop_difference AS \n\t\t(\n\t\t\tSELECT d.grid_visualization_id, (COALESCE(s.population,0) - COALESCE(d.population,0)) AS population, d.geom\n\t\t\tFROM population_default d, population_scenario s\n\t\t\tWHERE d.grid_visualization_id = s.grid_visualization_id\n\t\t) \n\t\tSELECT p.grid_visualization_id, p.population, \n\t\tCASE \n\t\tWHEN p.population = 0 THEN 0\n\t\tWHEN p.population < -400 THEN -5 \n\t\tWHEN p.population BETWEEN -400 AND -200 THEN -4 \n\t\tWHEN p.population BETWEEN -200 AND -80 THEN -3 \n\t\tWHEN p.population BETWEEN -80 AND -20 THEN -2 \n\t\tWHEN p.population BETWEEN -20 AND -1 THEN -1 \n\t\tWHEN p.population BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN p.population BETWEEN 20 AND 80 THEN 2\n\t\tWHEN p.population BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN p.population BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN p.population  > 400 THEN 5 END AS percentile_population, p.geom \n\t\tFROM pop_difference p;\n\tEND IF; \n\t\t\n\tIF modus_input = 'default' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_default p;\n\tELSEIF modus_input = 'scenario' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_scenario p;\n\tELSEIF modus_input = 'comparison' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_comparison p;\n\tEND IF; \n\nEND\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_pop;\nCREATE TABLE default_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'default',0)\n\nDROP TABLE IF EXISTS scenario_pop;\nCREATE TABLE scenario_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'scenario',13)\n\nDROP TABLE IF EXISTS comparison_pop;\nCREATE TABLE comparison_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'comparison',13)\n*/"
    )
    op.create_entity(basic_heatmap_population)

    basic_reached_population_study_area = PGFunction(
        schema="basic",
        signature="reached_population_study_area(ischrone_calculation_id_input integer, scenario_id_input integer, modus text, study_area_ids integer[])",
        definition="returns TABLE(id integer, step integer, reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[];\nBEGIN\n\t\n\tDROP TABLE IF EXISTS reachable_population; \n\n\t/*Get reachable population*/\n\tIF modus = 'default' THEN\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tSELECT s.id AS sub_study_area_id, s.name, s.population \n\t\tFROM basic.sub_study_area s\n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)); \n\t\n\tELSEIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT p.sub_study_area_id, -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tGROUP BY p.sub_study_area_id \n\t\t\tUNION ALL \n\t\t\tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t \t),\n\t \tscenario_population AS \n\t \t(\n\t\t \tSELECT p.sub_study_area_id, sum(population) population \n\t\t \tFROM prepared_scenario p \n\t\t \tGROUP BY p.sub_study_area_id\n\t\t) \n\t\tSELECT s.id AS sub_study_area_id, s.name, (s.population + COALESCE(sp.population, 0)) AS population \n\t\tFROM basic.sub_study_area s\n\t\tLEFT JOIN scenario_population sp \n\t\tON s.id = sp.sub_study_area_id\n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)); \t\n\n\tELSE \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input \n\t)\n\tSELECT g.id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population, g.sub_study_area_id \n\tFROM to_group g\n\tGROUP BY g.id, g.sub_study_area_id; \n\t\n\t/*Combine and return results*/\n\tRETURN query \n\tWITH combined AS \n\t(\n\t\tSELECT r.id AS isochrone_feature_id, a.sub_study_area_id, a.name, \n\t\tCASE WHEN COALESCE(r.population, 0) > a.population THEN a.population \n\t\tELSE COALESCE(r.population, 0) END AS reached_population, a.population AS total_population \n\t\tFROM reachable_population a\n\t\tLEFT JOIN reached_population r \n\t\tON a.sub_study_area_id = r.sub_study_area_id \n\t),\n\tas_object AS \n\t(\n\t\tSELECT c.isochrone_feature_id, jsonb_object_agg(c.sub_study_area_id, \n\t\tjsonb_build_object('name', c.name, 'reached_population', c.reached_population, 'total_population', c.total_population)) AS population \n\t\tFROM combined c\n\t\tGROUP BY c.isochrone_feature_id \n\t)\n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = o.population \n\tFROM as_object o \n\tWHERE o.isochrone_feature_id = i.id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n \nEND; \n$function$;\n\n/*\nSELECT * \nFROM basic.reached_population_study_area(39, 2,'default', ARRAY[17,24,26])\n*/"
    )
    op.create_entity(basic_reached_population_study_area)

    basic_thematic_data_sum = PGFunction(
        schema="basic",
        signature="thematic_data_sum(user_id_input integer, input_isochrone_calculation_id integer, modus text, scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE(isochrone_feature_id integer, isochrone_feature_step integer, isochrone_feature_reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tpois_one_entrance jsonb = poi_categories -> 'false'; \n\tpois_more_entrance jsonb = poi_categories -> 'true';\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\texcluded_buildings_id integer[] := ARRAY[]::integer[];\n\tactive_upload_ids integer[];\nBEGIN \t\t\n\n\tIF modus = 'scenario' THEN\n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\tEND IF;\n\n    --Calculate reached AOIs\n\tDROP TABLE IF EXISTS reached_aois; \n\tCREATE TEMP TABLE reached_aois AS  \n\tWITH area_cnt AS \n\t(\n\t\tSELECT i.id, a.category, count(*) as cnt, intersec.area \n\t\tFROM customer.isochrone_feature i, basic.aoi a, \n\t\tLATERAL (SELECT ST_Area(st_intersection(i.geom,a.geom)::geography)::integer area) AS intersec  \n\t\tWHERE isochrone_calculation_id  = input_isochrone_calculation_id\n\t\tAND st_intersects(i.geom,a.geom)\n\t\tGROUP BY i.id, category, name, intersec.area\n\t),\n\tjson_area_cnt AS\n\t(\n\t\tSELECT p.id, p.category, jsonb_build_object('cnt',sum(cnt),'area',sum(area)) AS aois_json\n\t\tFROM area_cnt p \n\t\tGROUP BY p.id, p.category\n\t)\n\tSELECT j.id, jsonb_object_agg(category, aois_json) aois_json_agg\n\tFROM json_area_cnt j\n\tGROUP BY j.id; \n\t\n\n\tDROP TABLE IF EXISTS reached_opportunities; \n\tCREATE TEMP TABLE reached_opportunities \n\t(\n\t\tid integer,\n\t\topportunity_type TEXT, \n\t\tcnt integer\n\t);\n\n\t--Calculate reached population \n\tINSERT INTO reached_opportunities\n\tWITH temp_sum AS \n\t(\n\t\tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM basic.population p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n     \tUNION ALL \n     \tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM customer.population_modified p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.scenario_id = scenario_id_input \n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t)\n\tSELECT s.id, 'sum_pop', sum(s.population)::integer+(5-(sum(s.population)::integer % 5)) as sum_pop \n\tFROM temp_sum s     \t     \n\tGROUP BY s.id; \n\n\t--Calculate reached POIs one entrance \n\tINSERT INTO reached_opportunities\n\tSELECT i.id, s.category, count(*)\n \tFROM customer.isochrone_feature i\n \tCROSS JOIN LATERAL \n\t(\n\t\tSELECT p.category, i.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id \n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.scenario_id = scenario_id_input \n\t) s\n\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n\tGROUP BY category, i.id;\n\n\t--Calculate reached POIs more entrances \n\tINSERT INTO reached_opportunities\n\tWITH more_entrances AS \n\t(\n\t\tSELECT s.category, i.id\n\t \tFROM customer.isochrone_feature i\n\t \tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM basic.poi p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM customer.poi_user p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids)) \n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id \n\t\t\tFROM customer.poi_modified p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t\tGROUP BY name, category, i.id\n\t)\n\tSELECT m.id, m.category, count(*) \n\tFROM more_entrances m \n\tGROUP BY m.category, m.id;\n\n\tRETURN QUERY \n\tWITH group_reached_opportunities AS \n\t(\n\t\tSELECT r.id, jsonb_object_agg(opportunity_type, cnt) reached_opportunities  \n\t\tFROM reached_opportunities r \n\t\tGROUP BY id \n\t),\n\tcombined_opportunities AS \n\t(\n\t\tSELECT COALESCE(g.id, r.id) AS id, COALESCE(reached_opportunities, '{}'::jsonb) || COALESCE(aois_json_agg, '{}'::jsonb) AS reached_opportunities \n\t\tFROM group_reached_opportunities g\n\t\tFULL JOIN reached_aois r  \n\t\tON r.id = g.id \n\t)\n\tUPDATE customer.isochrone_feature i  \n\tSET reached_opportunities = c.reached_opportunities \n\tFROM combined_opportunities c \n\tWHERE i.id = c.id\n\tRETURNING i.id, i.step, i.reached_opportunities; \nEND ;\n$function$\n/*Intersects the isochrone with opportunity data-sets to produce cumulative opportunities*/\n/*\nSELECT * FROM basic.thematic_data_sum(3, 61, 'default', 0, ARRAY[0])\n*/"
    )
    op.create_entity(basic_thematic_data_sum)

    basic_count_pois_multi_isochrones = PGFunction(
        schema="basic",
        signature="count_pois_multi_isochrones (userid_input integer, modus text, minutes integer, speed_input numeric, region_type text, region TEXT[], amenities text[], scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE (region_name text, count_pois integer, geom geometry)\n    AS $function$\nDECLARE\n    buffer_geom geometry;\n    region_geom geometry;\n    region_name text;\n    excluded_pois_id text[] := ARRAY[]::text[];\nBEGIN\n\n    IF modus = 'scenario' THEN\n        excluded_pois_id = basic.modified_pois(scenario_id_input);\n    END IF;\n\n    IF region_type = 'study_area' THEN\n        SELECT s.geom, name  \n        INTO region_geom, region_name\n        FROM basic.sub_study_area s\n        WHERE id IN (SELECT UNNEST(region::integer[]));\n    ELSEIF region_type = 'draw' THEN\n        SELECT ST_GeomFromText(region[1]) \n        INTO region_geom;\n        region_name = 'draw';\n    ELSE \n        RAISE EXCEPTION 'Unknown region type\\: %', region_type;\n    END IF;\n    buffer_geom = ST_Buffer(region_geom::geography, speed_input  * 60 * minutes)::geometry;\n    \n    RETURN query \n\tWITH intersected_pois AS (\n        SELECT p.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT p.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.id\n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.scenario_id = scenario_id_input \n    ),\n    count_pois AS \n    (\n    \tSELECT count(*) AS cnt\n    \tFROM intersected_pois\n    )    \n    SELECT region_name, c.cnt::integer,\n    region_geom\n\tFROM count_pois c;\nEND\n$function$\nLANGUAGE plpgsql;\n\n/* Example with starting point to find study_area\nSELECT * FROM basic.count_pois_multi_isochrones(1,'scenario',10,1.33,'study_area',\n'POINT(11.570115749093093 48.15360025891228)', ARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 1, ARRAY[3]);\n \n * Example with drawn polygon\nSELECT * FROM basic.count_pois_multi_isochrones(1,'scenario',10,1.33,'draw',\n'POLYGON ((11.570115749093093 48.15360025891228, 11.570274296106232 48.1518693270582, 11.572708788648153 48.15118483030911, 11.574984827528402 48.15223125586774, 11.574826384986741 48.15396220424526, 11.57239179909107 48.154646710542, 11.570115749093093 48.15360025891228))',\nARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 1, ARRAY[3]);\n */"
    )
    op.create_entity(basic_count_pois_multi_isochrones)

    basic_prepare_heatmap_local_accessibility = PGFunction(
        schema="basic",
        signature="prepare_heatmap_local_accessibility(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition='returns TABLE(grid_visualization_id bigint, accessibility_index bigint)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tarray_amenities text[];\n\tpois_one_entrance jsonb := basic.poi_categories(user_id_input) -> \'false\';\n\tpois_more_entrances jsonb := basic.poi_categories(user_id_input) -> \'true\';\n\tsensitivities integer[]; \n\ttranslation_sensitivities jsonb;\n\texcluded_poi_uids text[] := \'{}\'::TEXT[];\nBEGIN\n  \t\n\tSELECT ARRAY_AGG(s.sensitivity::integer) \n\tINTO sensitivities \n\tFROM (\n\t\tSELECT jsonb_array_elements_text(basic.select_customization(\'heatmap_sensitivities\')) sensitivity \n\t) s;\n\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_one_entrance  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_one_entrance) AS o(category) \n\tWHERE a.category = o.category; \n\t\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_more_entrances  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_more_entrances) AS o(category) \n\tWHERE a.category = o.category; \n\n\tSELECT jsonb_object_agg(k, (sensitivities  # (v ->> \'sensitivity\')::integer)::smallint)\n\tINTO translation_sensitivities\n\tFROM jsonb_each(amenities_json) AS u(k, v);\n\n\tIF modus_input <> \'default\' AND scenario_id_input <> 0 THEN \n\t\texcluded_poi_uids = basic.modified_pois(scenario_id_input); \n\tEND IF; \n\n\tRETURN query\n\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\n\tRETURN query \n\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\tp.category, p.name\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\t\n\tIF data_upload_ids <> \'{}\'::integer[] THEN \n\t\tRETURN query\n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \t\n\tEND IF;\n\n\tIF modus_input <> \'default\' AND scenario_id_input <> 0 THEN \n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p  \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\t\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\tEND IF; \n\t\nEND;\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_heatmap;\nCREATE TABLE default_heatmap AS \nWITH heatmap_grids AS \n(\n\tSELECT grid_visualization_id, sum(accessibility_index) \n\tFROM basic.prepare_heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'default\',10) h\n\tGROUP BY grid_visualization_id \n)\nSELECT h.*, g.geom \nFROM basic.grid_visualization g, heatmap_grids h \nWHERE h.grid_visualization_id = g.id;  \n\nDROP TABLE IF EXISTS pois_to_explore; \nCREATE TABLE pois_to_explore AS \nSELECT * \nFROM basic.poi_aoi_visualization(4, 2, \'default\', ARRAY[0], 1)\nWHERE category = \'supermarket\'\n*/'
    )
    op.create_entity(basic_prepare_heatmap_local_accessibility)

    basic_heatmap_accessibility_population = PGFunction(
        schema="basic",
        signature="heatmap_accessibility_population(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition='returns TABLE(grid_visualization_id bigint, accessibility_index bigint, percentile_accessibility integer, percentile_population integer, population_accessibility integer, modus text, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n\t\n\tIF modus_input IN (\'default\',\'scenario\') THEN  \n\t\tRETURN query \n\t\tSELECT h.grid_visualization_id, h.accessibility_index, h.percentile_accessibility, p.percentile_population, \n\t\t(p.percentile_population-h.percentile_accessibility) AS population_accessibility, modus_input, h.geom  \n\t\tFROM basic.heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, modus_input, scenario_id_input, data_upload_ids) h, \n\t\tbasic.heatmap_population(active_study_area_id, modus_input, scenario_id_input) p \n\t\tWHERE p.grid_visualization_id = h.grid_visualization_id;\n\t\t\n\tELSEIF modus_input = \'comparison\' THEN \n\n\t\tDROP TABLE IF EXISTS calc_default; \n\t\tCREATE TEMP TABLE calc_default AS \n\t\tSELECT h.grid_visualization_id, h.accessibility_index, h.percentile_accessibility, p.percentile_population, \n\t\t(p.percentile_population-h.percentile_accessibility) AS population_accessibility, h.geom  \n\t\tFROM basic.heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'default\', scenario_id_input, data_upload_ids) h, \n\t\tbasic.heatmap_population(active_study_area_id, \'default\', scenario_id_input) p \n\t\tWHERE p.grid_visualization_id = h.grid_visualization_id;\n\t\t\n\t\tALTER TABLE calc_default ADD PRIMARY KEY(grid_visualization_id);\n\t\t\n\t\tDROP TABLE IF EXISTS calc_scenario;\n\t\tCREATE TEMP TABLE calc_scenario AS \n\t\tSELECT h.grid_visualization_id, h.accessibility_index, h.percentile_accessibility, p.percentile_population, \n\t\t(p.percentile_population-h.percentile_accessibility) AS population_accessibility, h.geom  \n\t\tFROM basic.heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'scenario\', scenario_id_input, data_upload_ids) h, \n\t\tbasic.heatmap_population(active_study_area_id, \'scenario\', scenario_id_input) p \n\t\tWHERE p.grid_visualization_id = h.grid_visualization_id;\n\t\n\t\tALTER TABLE calc_scenario ADD PRIMARY KEY(grid_visualization_id);\n\t\n\t\tRETURN query\n\t\tSELECT d.grid_visualization_id, NULL::bigint AS accessibility_index, NULL::integer AS percentile_accessibility, NULL::integer AS percentile_population, \n\t\tCASE WHEN d.population_accessibility <> s.population_accessibility \n\t\tTHEN abs(d.population_accessibility) - abs(s.population_accessibility)  \n\t\tELSE 0 END AS population_accessibility, modus_input, d.geom\n\t\tFROM calc_default d, calc_scenario s\n\t\tWHERE d.grid_visualization_id = s.grid_visualization_id;\n\t\n\tEND IF; \nEND\n$function$;\n\n/*\nSELECT * \nFROM basic.heatmap_accessibility_population(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'comparison\', 11, \'{}\'::integer[]) h;\n*/'
    )
    op.create_entity(basic_heatmap_accessibility_population)

    basic_reached_pois_heatmap = PGFunction(
        schema="basic",
        signature="reached_pois_heatmap(table_name TEXT, calculation_geom geometry, user_id_input integer, scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[], poi_modified_uid text DEFAULT '')",
        definition="returns VOID\nAS $function$\nDECLARE\n\tsensitivities jsonb:= basic.select_customization('heatmap_sensitivities'); \n\tsnap_distance integer := basic.select_customization('snap_distance_poi_heatmap')::integer; \n\tbuffer_pois geometry := ST_BUFFER(calculation_geom::geography, snap_distance)::geometry;\n\tpoi_categories jsonb := basic.poi_categories(user_id_input); \n\tarr_categories text[];\nBEGIN \n\t\n\tIF table_name = 'poi_user' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap \n\t\tWHERE data_upload_id IN (SELECT UNNEST(data_upload_ids));\n\t\n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap r\n\t\tWHERE poi_uid = poi_modified_uid\n\t\tAND scenario_id = scenario_id_input;\n\t\n\tEND IF; \n\n\tWITH categories AS\n\t(\n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'true') AS category\n\t\tUNION ALL \n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'false') AS category\n\t)\n\tSELECT array_agg(category)\n\tFROM categories \n\tINTO arr_categories; \n\t\n\tIF table_name = 'poi' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, NULL AS data_upload_id  \n\t\tFROM basic.poi p \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE p.category IN (SELECT UNNEST(arr_categories))\n\t\tAND ST_Intersects(p.geom, buffer_pois); \n\tELSEIF table_name = 'poi_user' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, p.data_upload_id \n\t\tFROM customer.poi_user p \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE ST_Intersects(p.geom, buffer_pois)\n\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids)); \n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, scenario_id_input AS scenario_id, p.data_upload_id  \n\t\tFROM (SELECT * FROM customer.poi_modified x WHERE x.uid = poi_modified_uid AND x.scenario_id = scenario_id_input) p\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f;\n\tELSE \n\t\tRAISE EXCEPTION 'Please specify a valid table name.';\n\tEND IF;\n\t\n\tCREATE INDEX ON pois_edges_full (edge_id);\t\n\tINSERT INTO customer.reached_poi_heatmap(poi_uid, scenario_id, data_upload_id, grid_visualization_ids, costs, accessibility_indices)\n\tWITH pois_with_cost AS \n\t(\n\t\tSELECT f.poi_uid, f.scenario_id, c.grid_visualization_id, c.COST, f.data_upload_id \n\t\tFROM pois_edges_full f\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT e.grid_visualization_id, avg(e.cost) AS COST \n\t\t\tFROM \n\t\t\t(\n\t\t\t\tSELECT c.grid_visualization_id,\n\t\t\t\tCASE WHEN r.start_cost < r.end_cost THEN (r.start_cost + f.fraction * (r.end_cost-r.start_cost))\n\t\t\t\tELSE (r.end_cost + (1-f.fraction) * (r.start_cost - r.end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND (r.edge_type IS NULL or r.edge_type = 'a')\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t\tUNION ALL \n\t\t\t\tSELECT c.grid_visualization_id, CASE WHEN start_cost < end_cost THEN (start_cost + fraction * (end_cost-start_cost))\n\t\t\t\tELSE (end_cost + (1-fraction) * (start_cost - end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND edge_type IN ('p', 'ap')\n\t\t\t\tAND f.fraction BETWEEN least(r.start_perc,r.end_perc) AND greatest(r.start_perc,r.end_perc)\t\t\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t) e\t\n\t\t\tGROUP BY e.grid_visualization_id \n\t\t) AS c \n\t),\n\tfirst_merge AS\n\t(\n\t\tSELECT poi_uid, scenario_id, data_upload_id, array_agg(grid_visualization_id) AS grid_visualization_ids , array_agg(cost) AS costs   \n\t\tFROM pois_with_cost \n\t\tGROUP BY poi_uid, scenario_id, data_upload_id  \n\t)\n\tSELECT f.poi_uid, f.scenario_id::integer, f.data_upload_id::integer, f.grid_visualization_ids, f.costs, a.accessibility_indices\n\tFROM first_merge f\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT ARRAY_AGG(accessibility_indices) AS accessibility_indices \n\t\tFROM \n\t\t(\n\t\t\tSELECT array_AGG((pow(exp(1.0)::real,(p.cost::real * p.cost::real) / -s.sensitivity) * (10000))::integer) AS accessibility_indices, s.sensitivity  \n\t\t\tFROM (SELECT sensitivity::REAL FROM jsonb_array_elements(basic.select_customization('heatmap_sensitivities')) sensitivity) s, \n\t\t\t(SELECT UNNEST(f.costs) cost) p\n\t\t\tGROUP BY sensitivity \n\t\t\tORDER BY sensitivity \n\t\t) s\n\t) AS a;\n\t\nEND;\n$function$ LANGUAGE plpgsql\n\n/*\nEXPLAIN ANALYZE \nSELECT basic.reached_pois_heatmap('poi_modified'::text, geom, 4, 75, ARRAY[0]::integer[], 'd0c79777fcdc4d55b02da0ef17470bef'::text) \nFROM (SELECT * FROM customer.poi_modified pm WHERE uid = 'd0c79777fcdc4d55b02da0ef17470bef') p\n*/"
    )
    op.create_entity(basic_reached_pois_heatmap)

    basic_poi_aoi_visualization = PGFunction(
        schema="basic",
        signature="poi_aoi_visualization(user_id_input integer, scenario_id_input integer, active_upload_ids integer[], active_study_area_id integer)",
        definition="returns TABLE (id integer, uid TEXT, category TEXT, name TEXT, opening_hours TEXT, street TEXT, housenumber TEXT, zipcode TEXT, edit_type TEXT, geom geometry)\nLANGUAGE plpgsql\nAS $function$\nDECLARE \t\n\taoi_categories TEXT[]; \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tcombined_poi_categories text[];\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\tbuffer_geom_study_area geometry; \nBEGIN\n\t\n\t/*Get combined poi categories*/\n\tSELECT ARRAY_AGG(c.category)\n\tINTO combined_poi_categories\n\tFROM \t\n\t(\n\t\tSELECT jsonb_array_elements_text(poi_categories -> 'true') category\n\t\tUNION ALL \n\t\tSELECT jsonb_array_elements_text(poi_categories -> 'false') category\n\t) c;\n\n\t/*Prepare AOI categories*/\n\tDROP TABLE IF EXISTS aoi_groups_default; \n\tCREATE TEMP TABLE aoi_groups_default AS \n\tWITH aoi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(basic.select_customization('aoi_groups')) aoi_group\n\t)\n\tSELECT jsonb_array_elements(p.aoi_group -> jsonb_object_keys(p.aoi_group) -> 'children') AS aoi_category \n\tFROM aoi_groups p;\n\n\tSELECT ARRAY_AGG(object_keys) AS aoi_category\n\tINTO aoi_categories\n\tFROM aoi_groups_default  p, LATERAL jsonb_object_keys(p.aoi_category) object_keys;  \n\t\n\t/*Check if POI scenario*/\n\tIF scenario_id_input <> 0 THEN \n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\tEND IF; \n\t/*Buffer study area to avoid border effects*/\n\tbuffer_geom_study_area = (SELECT buffer_geom_heatmap AS geom FROM basic.study_area s WHERE s.id = active_study_area_id);\n\n    RETURN query\n   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM basic.poi p\n\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM customer.poi_user p\n\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\t/*No scenarios nor aoi_user is implemented at the moment*/\n\tSELECT p.id, NULL, p.category, p.name, p.opening_hours, NULL AS street, NULL AS housenumber, NULL AS zipcode, NULL AS edit_type, p.geom\n\tFROM basic.aoi p \n\tWHERE p.category IN (SELECT UNNEST(aoi_categories))\n\tAND p.geom && buffer_geom_study_area; \n\t\n\tIF scenario_id_input <> 0 THEN \n\t   \tRETURN query \n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, p.edit_type, p.geom  \n\t\tFROM customer.poi_modified p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.scenario_id = scenario_id_input; \n\t   \t\n\t\tRETURN query\n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM basic.poi p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\t\n\t\tRETURN query \n\t\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM customer.poi_user p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\tEND IF; \nEND ;\n$function$;\n\n\n/*\nModus should be default, scenario, comparison\nSELECT * \nFROM basic.poi_aoi_visualization(4, 2, 'default', ARRAY[0], 1)\n*/"
    )
    op.create_entity(basic_poi_aoi_visualization)

    basic_heatmap_prepare_artificial = PGFunction(
        schema="basic",
        signature="heatmap_prepare_artificial(grid_helper_classes integer[])",
        definition="returns void\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tx float[];\n\ty float[]; \nBEGIN \n\tWITH p AS \n\t(\n\t\tSELECT ST_CENTROID(c.geom) AS geom \n\t\tFROM temporal.heatmap_grid_helper h, basic.grid_calculation c \n\t\tWHERE cid IN (SELECT UNNEST(grid_helper_classes))\n\t\tAND h.id = c.grid_visualization_id \n\t)\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p\n\tINTO x, y; \n\n\tPERFORM basic.create_multiple_artificial_edges(x, y, 1200., 1.33, 'default', 1, 'walking_standard'); \n\t\n\t\n\tDROP TABLE IF EXISTS temporal.heatmap_edges_artificial; \n\tCREATE TABLE temporal.heatmap_edges_artificial AS\n\tSELECT * FROM final_artificial_edges;\n\tALTER TABLE temporal.heatmap_edges_artificial ADD PRIMARY KEY(id);\n\tCREATE INDEX ON temporal.heatmap_edges_artificial USING GIST(geom);\n\t\n\tDROP TABLE IF EXISTS temporal.heatmap_starting_vertices; \n\tCREATE TABLE temporal.heatmap_starting_vertices AS\n\tSELECT * FROM starting_vertices;\n\tCREATE INDEX ON temporal.heatmap_starting_vertices USING GIST(geom);\n\nEND;\n$function$;\n/*\n * SELECT basic.heatmap_prepare_artificial(ARRAY[1,2,3,4])\n */"
    )
    op.create_entity(basic_heatmap_prepare_artificial)

    basic_reached_population_polygon = PGFunction(
        schema="basic",
        signature="reached_population_polygon(ischrone_calculation_id_input integer, scenario_id_input integer, modus TEXT, region TEXT)",
        definition="returns TABLE (isochrone_feature_id integer, step integer, reached_opportunities jsonb)\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[];\n\tregion_geom geometry := ST_SETSRID(ST_GeomFromText(region), 4326);\n\treachable_population integer; \n\treachable_population_default integer; \n\treachable_population_scenario integer;  \nBEGIN\n\t\n\t/*Check if invalid modus*/\n\tIF modus NOT IN ('default','scenario') THEN \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t/*Get reachable population*/\n\tIF modus IN ('default','scenario')  THEN\n\t\tSELECT COALESCE(population, 0)  \n\t\tINTO reachable_population_default\n\t\tFROM basic.population p \n\t\tWHERE ST_Intersects(p.geom, region_geom); \n\tEND IF; \n\t\n\tIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE ST_Intersects(p.geom, region_geom)\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tUNION ALL \n\t\t\tSELECT sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE ST_Intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t \t)\n \t\tSELECT COALESCE(sum(population), 0)::integer \n \t\tINTO reachable_population_scenario  \n\t\tFROM prepared_scenario p; \n\t\n\t\treachable_population = floor((reachable_population_default  + reachable_population_scenario / 5)*5); \n\t\t\n\tEND IF; \n\t\n\treachable_population = floor((reachable_population_default / 5)*5);\n\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t)\n\tSELECT g.id AS isochrone_feature_id,(floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population\n\tFROM to_group g\n\tGROUP BY g.id;\n\t\n    /*Combine and return results*/\n\tRETURN query \n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = jsonb_build_object('name', 'polygon', 'reached_population', population, 'total_population', reachable_population)  \n\tFROM reached_population r \n\tWHERE i.id = r.isochrone_feature_id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n\nEND; \n$function$ LANGUAGE plpgsql;\n\n/*\nSELECT * \nFROM basic.reached_population_polygon(88, 2, 'default',\n'POLYGON ((11.570115749093093 48.15360025891228, 11.570274296106232 48.1518693270582, 11.572708788648153 48.15118483030911, 11.574984827528402 48.15223125586774, 11.574826384986741 48.15396220424526, 11.57239179909107 48.154646710542, 11.570115749093093 48.15360025891228))') \n*/"
    )
    op.create_entity(basic_reached_population_polygon)

    basic_prepare_heatmap_population = PGFunction(
        schema="basic",
        signature="prepare_heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default'::text, scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population double precision, percentile_population integer, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_buildings integer[] := basic.modified_buildings(scenario_id_input);\nBEGIN \n\t\n\tIF modus_input = 'default' THEN \n\t\tscenario_id_input = 0;\n\tEND IF;\n\t\n\tRETURN query\n\tWITH modified_population AS \n\t(\n\t\tSELECT p.geom, -p.population AS population\n\t\tFROM basic.population p \n\t\tWHERE building_id IN (SELECT UNNEST(modified_buildings))\n\t\tUNION ALL \n\t\tSELECT p.geom, p.population \n\t\tFROM customer.population_modified p \n\t\tWHERE p.scenario_id = scenario_id_input \n\t),\n\tsum_pop AS (\n\t\tSELECT g.id, sum(p.population) + COALESCE(g.population,0) population, \n\t\tCASE WHEN sum(p.population) + COALESCE(g.population,0) BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 20 AND 80 THEN 2\n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  > 400 THEN 5 END AS percentile_population, g.geom\n\t\tFROM basic.grid_visualization g, modified_population p, basic.study_area_grid_visualization s\n\t\tWHERE ST_Intersects(g.geom,p.geom)\n\t\tAND p.population IS NOT NULL \n\t\tAND g.id = s.grid_visualization_id \n\t\tAND s.study_area_id = active_study_area_id\n\t\tGROUP BY g.id, g.population, g.geom\n\t) \n\tSELECT s.id AS grid_visualization_id ,s.population, s.percentile_population, s.geom \n\tFROM sum_pop s\n\tUNION ALL \n\tSELECT g.id AS grid_visualization_id, g.population, g.percentile_population, g.geom\n\tFROM \n\t(\n\t\tSELECT g.* \n\t\tFROM basic.grid_visualization  g, basic.study_area_grid_visualization sa\n\t\tWHERE sa.study_area_id = active_study_area_id \n\t\tAND g.id = sa.grid_visualization_id \n\t) g \n\tLEFT JOIN sum_pop s\n\tON g.id = s.id\n\tWHERE s.id IS NULL;\n\t\nEND\n$function$;\n/*\nSELECT * \nFROM basic.prepare_heatmap_population(13)\n*/"
    )
    op.create_entity(basic_prepare_heatmap_population)

    basic_population_modification = PGFunction(
        schema="basic",
        signature="population_modification(scenario_id_input integer)",
        definition="returns SETOF void\nLANGUAGE plpgsql\nAS $function$\nDECLARE \n\taverage_gross_living_area integer := basic.select_customization('average_gross_living_area');\nBEGIN \n\n\tUPDATE customer.building_modified b\n\tSET area = ST_AREA(geom::geography), population = (b.building_levels_residential * ST_AREA(b.geom::geography) / average_gross_living_area) \n\tWHERE scenario_id = scenario_id_input; \n\t\n\tWITH count_pop AS (\n\t\tSELECT count(*) AS count_points, building_modified_id \n\t\tFROM customer.population_modified \n\t\tWHERE scenario_id = scenario_id_input\n\t\tGROUP BY building_modified_id  \n\t),\n\tpoints_to_update AS \n\t(\n\t\tSELECT p.id, b.id AS building_modified_id, b.population / c.count_points AS population \n\t\tFROM customer.building_modified b, customer.population_modified p, count_pop c  \n\t\tWHERE b.id = p.building_modified_id  \n\t\tAND b.id = c.building_modified_id  \n\t\tAND b.scenario_id = scenario_id_input\n\t\tAND p.scenario_id = scenario_id_input\n\t\tAND b.building_type = 'residential'\n\t)\n\tUPDATE customer.population_modified p \n\tSET population = u.population \n\tFROM points_to_update u \n\tWHERE p.id = u.id; \n\nEND\n$function$;\n/*\nSELECT basic.population_modification(13)\n*/"
    )
    op.create_entity(basic_population_modification)

    basic_network_modification = PGFunction(
        schema="basic",
        signature="network_modification(scenario_id_input integer)",
        definition="returns SETOF integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n   cnt integer;\n   rec record;\n   max_id integer; \nBEGIN\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Prepare Table\n\t---------------------------------------------------------------------------------------------------------------------\n\t\n\t/*Assumption Translation Meters and Degree\\: 1m = 0.000009 degree */\n\tDELETE FROM basic.edge e\n\tWHERE e.scenario_id = scenario_id_input;\n\tDELETE FROM basic.node n \n\tWHERE n.scenario_id = scenario_id_input; \n\tDROP TABLE IF EXISTS drawn_features, existing_network, intersection_existing_network, drawn_features_union, new_network, delete_extended_part, vertices_to_assign; \n\t\t\n\tDROP TABLE IF EXISTS modified_attributes_only;\n\tCREATE TEMP TABLE modified_attributes_only AS \n\tSELECT w.*\n\tFROM basic.edge e, customer.way_modified w \n\tWHERE w.scenario_id = scenario_id_input \n\tAND e.id = w.way_id \n\tAND ST_ASTEXT(ST_ReducePrecision(w.geom,0.00001)) = ST_ASTEXT(ST_ReducePrecision(e.geom,0.00001))\n\tAND edit_type = 'm'; \n\tCREATE INDEX ON modified_attributes_only USING GIST(geom);\n\n\tDROP TABLE IF EXISTS drawn_features; \n\tCREATE TEMP TABLE drawn_features as\n\tSELECT w.id, w.geom, \n\tw.way_type, w.surface, w.wheelchair, w.lit, w.foot, w.bicycle, w.scenario_id, w.way_id AS original_id \n\tFROM customer.way_modified w\n\tWHERE w.scenario_id = scenario_id_input\n\tAND w.edit_type IN ('n', 'm');\n\tCREATE INDEX ON drawn_features USING GIST(geom);\n\t\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Snap start and end points\n\t---------------------------------------------------------------------------------------------------------------------\n\t/*Round start and end point for snapping*/\n\tDROP TABLE IF EXISTS snapped_drawn_features; \n \tCREATE TEMP TABLE snapped_drawn_features AS \n\tSELECT d.id AS did, ST_ReducePrecision(st_startpoint(d.geom), 0.00001) geom, 's' AS point_type, FALSE AS snapped, NULL::integer AS node_id \n\tFROM drawn_features d\n\tUNION ALL \n\tSELECT d.id AS did, ST_ReducePrecision(st_endpoint(d.geom), 0.00001) geom, 'e' AS point_type, FALSE AS snapped, NULL AS node_id  \n\tFROM drawn_features d; \n\n\tALTER TABLE snapped_drawn_features ADD COLUMN id serial; \n\tCREATE INDEX ON snapped_drawn_features USING GIST(geom);\n\tCREATE INDEX ON snapped_drawn_features (id);\n\t\n\t/*Snapping to existing Nodes*/\n\tDROP TABLE IF EXISTS snapped_to_node; \n\tCREATE TEMP TABLE snapped_to_node AS  \n\tSELECT r.id, r.did, r.point_type, r.geom original_geom, s.geom node_geom, s.id AS node_id \n\tFROM snapped_drawn_features r\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT n.id, n.geom\n\t\tFROM basic.node n\n\t\tWHERE ST_Intersects(ST_BUFFER(r.geom,0.00001), n.geom)\n\t\tAND n.scenario_id IS NULL \n\t\tORDER BY r.geom <-> n.geom\n\t\tLIMIT 1\n\t) s;\n\tCREATE INDEX ON snapped_to_node USING GIST(node_geom); \t\n\n\tUPDATE snapped_drawn_features d\n\tSET geom = node_geom, snapped = TRUE, node_id = s.node_id \n\tFROM snapped_to_node s \n\tWHERE s.did = d.did \n\tAND d.point_type = s.point_type;  \n\t\t\n\t/*Snapping to existing edges*/\n\tDROP TABLE IF EXISTS snapped_to_edge; \n\tCREATE TEMP TABLE snapped_to_edge AS  \n\tSELECT r.id, r.did, r.point_type, r.geom original_geom, s.geom closest_point_edge \n\tFROM snapped_drawn_features r\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT n.id, ST_CLOSESTPOINT(n.geom, r.geom) AS geom \n\t\tFROM basic.edge n\n\t\tWHERE ST_Intersects(ST_BUFFER(r.geom,0.00001), n.geom)\n\t\tAND n.scenario_id IS NULL \n\t\tORDER BY r.geom <-> ST_CLOSESTPOINT(n.geom, r.geom)\n\t\tLIMIT 1\n\t) s\n\tWHERE r.snapped = False;\n\t\n\tUPDATE snapped_drawn_features d\n\tSET geom = closest_point_edge, snapped = True\n\tFROM snapped_to_edge s \n\tWHERE s.did = d.did \n\tAND d.point_type = s.point_type;  \n\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, 0, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE d.id = s.did \n\tAND s.snapped = TRUE \n\tAND s.point_type = 's';\n\t\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, -1, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE d.id = s.did \n\tAND s.snapped = TRUE \n\tAND s.point_type = 'e';\n\n\t/*Snapping drawn features to each other*/\t\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, 0, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE s.snapped = FALSE \n\tAND s.point_type = 's'\n\tAND d.id = s.did; \n\t\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, -1, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE s.snapped = FALSE \n\tAND s.point_type = 'e'\n\tAND d.id = s.did; \n\t\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Cut network\n\t---------------------------------------------------------------------------------------------------------------------\n\t/*Extend lines to cut network*/\t\t\n\tDROP TABLE IF EXISTS extended_lines; \n\tCREATE TEMP TABLE extended_lines AS  \n\tWITH agg_snapped_nodes AS \n\t(\n\t\tSELECT d.id, ARRAY_AGG(point_type) AS point_type \n\t\tFROM snapped_to_node s, drawn_features d \n\t\tWHERE d.id = s.did \n\t\tGROUP BY d.id\n\t)\n\tSELECT CASE WHEN ARRAY['e', 's'] && point_type THEN d.geom\n\tWHEN ARRAY['s'] = point_type THEN basic.extend_line(d.geom, 0.00001, 'end')\n\tWHEN ARRAY['e'] = point_type THEN basic.extend_line(d.geom, 0.00001, 'start')\n\tEND AS geom \n\tFROM agg_snapped_nodes a, drawn_features d\n\tWHERE a.id = d.id \n\tAND d.way_type <> 'bridge'\n\tUNION ALL \n\tSELECT basic.extend_line(d.geom, 0.00001, 'both') \n\tFROM drawn_features d \n\tLEFT JOIN snapped_to_node s \n\tON d.id = s.did \n\tWHERE s.id IS NULL\n\tAND d.way_type <> 'bridge';  \n\t\t\n\t/*Intersects drawn bridges*/\n\tDROP TABLE IF EXISTS start_end_bridges;\n\tCREATE TEMP TABLE start_end_bridges AS \n\tSELECT st_startpoint(geom) AS geom \n\tFROM drawn_features\n\tWHERE way_type = 'bridge'\n\tUNION \n\tSELECT ST_endpoint(geom) AS geom \n\tFROM drawn_features\n\tWHERE way_type = 'bridge';\n\tCREATE INDEX ON start_end_bridges USING GIST(geom);\n\n\t/*Intersect drawn ways with existing ways*/\n\tDROP TABLE IF EXISTS intersection_existing_network;\n\tCREATE TEMP TABLE intersection_existing_network AS \n\t\n\tWITH intersection_result AS \n\t(\n\t\tSELECT (ST_DUMP(ST_Intersection(d.geom, w.geom))).geom AS geom \n\t\tFROM extended_lines d, basic.edge w\n\t\tWHERE ST_Intersects(ST_BUFFER(d.geom, 0.00001), w.geom)\n\t\tAND w.scenario_id IS NULL\n\t)\n\tSELECT i.geom AS geom \n\tFROM intersection_result i \n\tWHERE st_geometrytype(i.geom) = 'ST_Point'; \n\n\tINSERT INTO intersection_existing_network\n\tWITH to_add AS\n\t(\n\t\tSELECT scenario_id_input AS scenario_id, x.closest_point AS geom \n\t\tFROM start_end_bridges s \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_CLOSESTPOINT(w.geom,s.geom) AS closest_point, ST_LineLocatePoint(w.geom,s.geom) AS fraction\n\t\t\tFROM basic.edge w \n\t\t\tWHERE w.scenario_id IS NULL \n\t\t\tAND ST_Intersects(St_buffer(s.geom,0.00001), w.geom)\n\t\t\tORDER BY ST_CLOSESTPOINT(geom,s.geom) <-> s.geom\n\t\t  \tLIMIT 1\n\t\t) x\n\t) \n\tSELECT a.geom\n\tFROM to_add a \n\tLEFT JOIN intersection_existing_network i \n\tON ST_Intersects(ST_BUFFER(a.geom, 0.00001), i.geom)\n\tWHERE i.geom IS NULL;  \n\t\n\tDROP TABLE IF EXISTS distinct_intersection_existing_network; \n\tCREATE TABLE distinct_intersection_existing_network AS \n\tSELECT DISTINCT geom\n\tFROM intersection_existing_network i;  \n\t\n\tCREATE INDEX ON distinct_intersection_existing_network USING GIST(geom);\n\tALTER TABLE distinct_intersection_existing_network ADD COLUMN id serial;\n\tALTER TABLE distinct_intersection_existing_network ADD PRIMARY key(id);\n\t\n\t/*Filter out snapped start or end point*/\n\tDELETE FROM intersection_existing_network h\n\tUSING \n\t(\n\t\tSELECT h.geom \n\t\tFROM snapped_to_node n, distinct_intersection_existing_network h \n\t\tWHERE ST_Intersects(ST_BUFFER(n.node_geom,0.00001), h.geom)\n\t) d \n\tWHERE h.geom = d.geom; \n\n\tDROP TABLE IF EXISTS split_drawn_features;\n\t/*Split network with itself*/\n\tSELECT count(*) \n\tINTO cnt\n\tFROM drawn_features\n\tWHERE (way_type IS NULL OR way_type <> 'bridge')\n\tLIMIT 2;\n\t\n\tIF cnt <= 1 THEN\n\t    CREATE TEMP TABLE split_drawn_features as\n\t    SELECT id as did, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id  \n\t\tFROM drawn_features;\n\tELSE \n\t\tCREATE TEMP TABLE split_drawn_features AS\n\t\tSELECT id AS did, basic.split_by_drawn_lines(id::integer,geom) AS geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id  \n\t\tFROM drawn_features\n\t\tWHERE (way_type IS NULL OR way_type <> 'bridge')\n\t\tUNION ALL \n\t\tSELECT id AS did, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id  \n\t\tFROM drawn_features\n\t\tWHERE way_type = 'bridge';\n\tEND IF;\n\tCREATE INDEX ON split_drawn_features USING GIST(geom);\n\n\t/*Create perpendicular lines to split new network*/\n\tDROP TABLE IF EXISTS perpendicular_split_lines;\n\tCREATE TEMP TABLE perpendicular_split_lines AS \n\tSELECT basic.create_intersection_line(i.geom, 0.000001) AS geom \n\tFROM intersection_existing_network i;\n\t\n\tDROP TABLE IF EXISTS union_perpendicular_split_lines; \n\tCREATE TEMP TABLE union_perpendicular_split_lines AS \n\tSELECT ST_Union(geom) AS geom  \n\tFROM perpendicular_split_lines p; \n\t\n\t/*Split new network with existing network*/\n\tDROP TABLE IF EXISTS new_network;\n\tCREATE TEMP TABLE new_network AS\n\tSELECT d.did, (dp.geom).geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id, 'geom' AS edit_type  \n\tFROM split_drawn_features d, union_perpendicular_split_lines w, \n\tLATERAL (SELECT ST_DUMP(ST_CollectionExtract(ST_SPLIT(d.geom,w.geom),2)) AS geom) dp\n\tWHERE (d.way_type IS NULL OR d.way_type <> 'bridge');\n\tCREATE INDEX ON new_network USING GIST(geom);\n\n\t/*Delete extended part*/\n\tDELETE FROM new_network\n\tWHERE st_length(geom) < 0.0000011;\n\n\t/*Inject drawn bridges*/\n\tINSERT INTO new_network(did, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id, edit_type) \n\tSELECT id, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id, 'geom'\n\tFROM drawn_features \n\tWHERE way_type = 'bridge';\n\n\tALTER TABLE new_network ADD COLUMN id serial;\n\tALTER TABLE new_network ADD COLUMN source integer;\n\tALTER TABLE new_network ADD COLUMN target integer;\n\t\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Prepare source and target\n\t---------------------------------------------------------------------------------------------------------------------\n\t/*Existing network is split using perpendicular lines*/\n\tDROP TABLE IF EXISTS existing_network;\n\tCREATE TEMP TABLE existing_network as \n\tSELECT w.id AS original_id, w.class_id, w.surface, w.foot, w.bicycle, (dp.geom).geom, w.source, w.target, \n\tw.lit_classified, w.wheelchair_classified, w.impedance_surface\n\tFROM basic.edge w, union_perpendicular_split_lines p, \n\tLATERAL (SELECT ST_DUMP(ST_CollectionExtract(ST_SPLIT(w.geom,p.geom),2)) AS geom) dp\n\tWHERE ST_Intersects(w.geom, p.geom)\n\tAND w.scenario_id IS NULL\n\tAND w.id NOT IN (SELECT way_id FROM modified_attributes_only);\n\tALTER TABLE existing_network ADD COLUMN id serial;\n\tALTER TABLE existing_network ADD PRIMARY KEY(id);\n\tCREATE INDEX ON existing_network USING GIST(geom);\n\t\n\t/*Assign vertices that where snapped to new features*/\n\tUPDATE new_network n\n\tSET SOURCE = s.node_id\n\tFROM snapped_drawn_features s\n\tWHERE n.did = s.did \n\tAND s.node_id IS NOT NULL \n\tAND s.point_type = 's'; \n\t\n\tUPDATE new_network n\n\tSET target = s.node_id\n\tFROM snapped_drawn_features s\n\tWHERE n.did = s.did \n\tAND s.node_id IS NOT NULL \n\tAND s.point_type = 'e'; \n\n\t/*Create new vertices*/\n\tDROP TABLE IF EXISTS loop_vertices; \n\tCREATE TEMP TABLE loop_vertices AS \n\tSELECT d.geom, ARRAY_AGG(id)::integer[] new_network_ids , ARRAY_AGG(point_type)::text[] AS point_types  \n\tFROM \n\t(\n\t\tSELECT st_startpoint(geom) geom, e.id, 's' AS point_type \n\t\tFROM new_network e \n\t\tWHERE SOURCE IS NULL \n\t\tUNION ALL \n\t\tSELECT st_endpoint(geom) geom, e.id, 'e' AS point_type \n\t\tFROM new_network e \n\t\tWHERE target IS NULL \n\t) d\n\tGROUP BY d.geom;\n\n\tDROP TABLE IF EXISTS new_vertices;  \n\tCREATE TEMP TABLE new_vertices \n\t(\n\t\tnode_id integer,\n\t\tnew_network_ids integer[],\n\t\tpoint_types text[],\n\t\tgeom geometry\n\t);\n\t/*\n\tDO $$\n\tDECLARE \n\t\trec record;\n\t\tmax_id integer; \n\tBEGIN*/\n\tFOR rec IN SELECT * FROM loop_vertices v\n\tLOOP \n\t\tmax_id = (SELECT max(id) FROM basic.node);\n\t\tWITH i AS \n\t\t(\n\t\t\tINSERT INTO basic.node (id, scenario_id, geom) \n\t\t\tVALUES(max_id + 1, scenario_id_input, rec.geom)\n\t\t\tRETURNING id, geom\n\t\t)\n\t\tINSERT INTO new_vertices(node_id, new_network_ids, point_types, geom)\n\t\tSELECT i.id, rec.new_network_ids, rec.point_types, i.geom  \n\t\tFROM i;\t\t\t\n\tEND LOOP;\n\t/*END $$;*/\n\tCREATE INDEX ON new_vertices USING GIST(geom);\n\t\n\tWITH unnest_to_update AS \n\t(\n\t\tSELECT v.node_id, UNNEST(v.new_network_ids) new_network_id, UNNEST(v.point_types) point_type\n\t\tFROM new_vertices v \n\t)\n\tUPDATE new_network n\n\tSET SOURCE = u.node_id \n\tFROM unnest_to_update u\n\tWHERE n.id = u.new_network_id \n\tAND point_type = 's';\n\t\n\tWITH unnest_to_update AS \n\t(\n\t\tSELECT v.node_id, UNNEST(v.new_network_ids) new_network_id, UNNEST(v.point_types) point_type\n\t\tFROM new_vertices v \n\t)\n\tUPDATE new_network n  \n\tSET target = u.node_id \n\tFROM unnest_to_update u\n\tWHERE n.id = u.new_network_id  \n\tAND point_type = 'e';\n\n\tDROP TABLE IF EXISTS new_source_target_existing; \n\tCREATE TEMP TABLE new_source_target_existing AS \n\tWITH start_and_end AS \n\t(\n\t\tSELECT e.id, st_startpoint(geom) geom, 's' AS point_type\n\t\tFROM existing_network e \n\t\tUNION ALL \n\t\tSELECT e.id,  st_endpoint(geom) geom, 'e' AS point_type  \n\t\tFROM existing_network e\n\t)\n\tSELECT v.id, point_type, c.node_id, v.geom  \n\tFROM start_and_end v\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT n.node_id \n\t\tFROM new_vertices n\n\t\tWHERE ST_Intersects(ST_BUFFER(v.geom, 0.00001), n.geom)\n\t\tORDER BY n.geom <-> v.geom \n\t\tLIMIT 1 \n\t) c;\n\t\n\tUPDATE existing_network e\n\tSET SOURCE = n.node_id \n\tFROM new_source_target_existing n \n\tWHERE e.id = n.id \n\tAND n.point_type = 's';\n\t\n\tUPDATE existing_network e\n\tSET target = n.node_id \n\tFROM new_source_target_existing n \n\tWHERE e.id = n.id \n\tAND n.point_type = 'e';\n\n\tDROP TABLE IF EXISTS network_to_add;\n\tCREATE TEMP TABLE network_to_add AS \n\tSELECT original_id, class_id, surface, foot, bicycle, geom, SOURCE, target, lit_classified, wheelchair_classified, impedance_surface  \n\tFROM existing_network  \n\tUNION ALL \n\tSELECT NULL, 100, surface, foot, bicycle, geom, SOURCE, target, lit, wheelchair, NULL \n\tFROM new_network;\n\t\n\tCREATE INDEX ON network_to_add USING GIST(geom);\n\t\n\t---Attach attributes to vertices\n\tDROP TABLE IF EXISTS vertices_to_add;\n\tCREATE TEMP TABLE vertices_to_add AS \n\tSELECT vv.node_id, array_remove(array_agg(DISTINCT x.class_id),NULL) class_ids,\n\tarray_remove(array_agg(DISTINCT x.foot),NULL) AS foot,\n\tarray_remove(array_agg(DISTINCT x.bicycle),NULL) bicycle,\n\tarray_remove(array_agg(DISTINCT x.lit_classified),NULL) lit_classified,\n\tarray_remove(array_agg(DISTINCT x.wheelchair_classified),NULL) wheelchair_classified,\n\tvv.geom\n\tFROM new_vertices  vv\n\tLEFT JOIN\n\t(\t\n\t\tSELECT v.node_id, w.class_id, w.foot, w.bicycle, w.lit_classified, w.wheelchair_classified \n\t\tFROM new_vertices v, network_to_add w \n\t\tWHERE st_intersects(ST_BUFFER(v.geom,0.00001),w.geom)\n\t) x\n\tON vv.node_id = x.node_id\n\tGROUP BY vv.node_id, vv.geom;\n\tCREATE INDEX ON vertices_to_add (node_id);\n\n\t----------------------------------------------------------------------------------------------------------------------\n\t--INSERT NEW VERTICES AND WAYS INTO THE EXISTING TABLES\n\t----------------------------------------------------------------------------------------------------------------------\n\n\tUPDATE basic.node n \n\tSET class_ids = v.class_ids, foot = v.foot, bicycle = v.bicycle, lit_classified = v.lit_classified, wheelchair_classified = v.wheelchair_classified \n\tFROM vertices_to_add v \n\tWHERE n.id = v.node_id\n\tAND n.scenario_id = scenario_id_input; \n\n\t/*DO $$\n\tDECLARE \n\t\trec record;\n\t\tmax_id integer; \n\tBEGIN*/\n\tFOR rec IN SELECT * FROM network_to_add  v\n\tLOOP \n\t\tmax_id = (SELECT max(id) FROM basic.edge);\n\t\n\t\tINSERT INTO basic.edge(id, class_id, source, target, foot, bicycle, wheelchair_classified, lit_classified, impedance_surface, geom, coordinates_3857, length_m, length_3857, scenario_id, edge_id) \n\t\tSELECT max_id + 1, rec.class_id, rec.SOURCE, rec.target, rec.foot, rec.bicycle, rec.wheelchair_classified, \n\t\trec.lit_classified, rec.impedance_surface, rec.geom, (ST_AsGeoJSON(ST_Transform(rec.geom,3857))::json->'coordinates')::json, \n\t\tST_LENGTH(rec.geom::geography), ST_LENGTH(ST_TRANSFORM(rec.geom, 3857)), scenario_id_input, rec.original_id\n\t\t;\t\t\n\tEND LOOP;\n\t/*END $$;*/\n\t\n\t\n    /*Set impedances for existing but now split network\n\tUPDATE ways_userinput ww\n\tSET s_imp = w.s_imp, rs_imp = w.rs_imp\n\tFROM ways_userinput w\n\tWHERE ww.original_id = w.id \n\tAND ww.scenario_id = 1\n\tAND w.scenario_id IS NULL; \n\t\n\tIF EXISTS\n\t\t( SELECT 1\n\t\t\tFROM   information_schema.tables \n\t\t\tWHERE  table_schema = 'public'\n\t\t\tAND    table_name = 'dem'\n\t\t)\n\tTHEN\n\t\tWITH impedances AS \n\t\t(\n\t\t\tSELECT w.id, ci.imp, ci.rs_imp\n\t\t\tFROM ways_userinput w,\n\t\t\tLATERAL get_slope_profile(w.id, 10, 'ways_userinput') sp, LATERAL compute_impedances(sp.elevs, sp.linkLength, 10) ci\n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND original_id IS NULL \n\t\t)\n\t\tUPDATE ways_userinput w\n\t\tSET s_imp = i.imp, rs_imp = i.rs_imp \n\t\tFROM impedances i \n\t\tWHERE w.id = i.id;\n\t\t\t\t\t\n\tEND IF;\n\t*/\nEND\n$function$"
    )
    op.create_entity(basic_network_modification)

    basic_split_by_drawn_lines = PGFunction(
        schema="basic",
        signature="split_by_drawn_lines(id_input integer, input_geom geometry)",
        definition="returns SETOF geometry\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tunion_geom geometry;\n\tdoes_intersect boolean := FALSE; \nBEGIN \n\t\n\tdoes_intersect = (\n\t\tSELECT TRUE \n\t\tFROM drawn_features d \n\t\tWHERE ST_Intersects(d.geom, (SELECT geom FROM drawn_features WHERE id = 82))\n\t\tLIMIT 1\n\t); \n\t\n\tIF does_intersect = TRUE THEN \n\t\tunion_geom = \n\t\t(\n\t\t\tSELECT ST_UNION(geom) AS geom \n\t\t\tFROM drawn_features \n\t\t\tWHERE id <> id_input\n\t\t\tAND ST_Intersects(geom, input_geom)\n\t\t\tAND (way_type IS NULL OR way_type <> 'bridge') \n\t\t);\n\tEND IF; \n\n\tIF union_geom IS NOT NULL THEN\n\t\tRETURN query\n\t\tSELECT (dump).geom\n\t\tFROM (SELECT ST_DUMP(ST_CollectionExtract(ST_SPLIT(input_geom,union_geom),2)) AS dump) d;\n\tELSE \n\t\tRETURN query SELECT input_geom;\n\tEND IF;\nEND \n$function$"
    )
    op.create_entity(basic_split_by_drawn_lines)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    basic_split_by_drawn_lines = PGFunction(
        schema="basic",
        signature="split_by_drawn_lines(id_input integer, input_geom geometry)",
        definition="returns SETOF geometry\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tunion_geom geometry;\n\tdoes_intersect boolean := FALSE; \nBEGIN \n\t\n\tdoes_intersect = (\n\t\tSELECT TRUE \n\t\tFROM drawn_features d \n\t\tWHERE ST_Intersects(d.geom, (SELECT geom FROM drawn_features WHERE id = 82))\n\t\tLIMIT 1\n\t); \n\t\n\tIF does_intersect = TRUE THEN \n\t\tunion_geom = \n\t\t(\n\t\t\tSELECT ST_UNION(geom) AS geom \n\t\t\tFROM drawn_features \n\t\t\tWHERE id <> id_input\n\t\t\tAND ST_Intersects(geom, input_geom)\n\t\t\tAND (way_type IS NULL OR way_type <> 'bridge') \n\t\t);\n\tEND IF; \n\n\tIF union_geom IS NOT NULL THEN\n\t\tRETURN query\n\t\tSELECT (dump).geom\n\t\tFROM (SELECT ST_DUMP(ST_CollectionExtract(ST_SPLIT(input_geom,union_geom),2)) AS dump) d;\n\tELSE \n\t\tRETURN query SELECT input_geom;\n\tEND IF;\nEND \n$function$"
    )
    op.drop_entity(basic_split_by_drawn_lines)

    basic_network_modification = PGFunction(
        schema="basic",
        signature="network_modification(scenario_id_input integer)",
        definition="returns SETOF integer\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n   cnt integer;\n   rec record;\n   max_id integer; \nBEGIN\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Prepare Table\n\t---------------------------------------------------------------------------------------------------------------------\n\t\n\t/*Assumption Translation Meters and Degree\\: 1m = 0.000009 degree */\n\tDELETE FROM basic.edge e\n\tWHERE e.scenario_id = scenario_id_input;\n\tDELETE FROM basic.node n \n\tWHERE n.scenario_id = scenario_id_input; \n\tDROP TABLE IF EXISTS drawn_features, existing_network, intersection_existing_network, drawn_features_union, new_network, delete_extended_part, vertices_to_assign; \n\t\t\n\tDROP TABLE IF EXISTS modified_attributes_only;\n\tCREATE TEMP TABLE modified_attributes_only AS \n\tSELECT w.*\n\tFROM basic.edge e, customer.way_modified w \n\tWHERE w.scenario_id = scenario_id_input \n\tAND e.id = w.way_id \n\tAND ST_ASTEXT(ST_ReducePrecision(w.geom,0.00001)) = ST_ASTEXT(ST_ReducePrecision(e.geom,0.00001))\n\tAND edit_type = 'm'; \n\tCREATE INDEX ON modified_attributes_only USING GIST(geom);\n\n\tDROP TABLE IF EXISTS drawn_features; \n\tCREATE TEMP TABLE drawn_features as\n\tSELECT w.id, w.geom, \n\tw.way_type, w.surface, w.wheelchair, w.lit, w.foot, w.bicycle, w.scenario_id, w.way_id AS original_id \n\tFROM customer.way_modified w\n\tWHERE w.scenario_id = scenario_id_input\n\tAND w.edit_type IN ('n', 'm');\n\tCREATE INDEX ON drawn_features USING GIST(geom);\n\t\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Snap start and end points\n\t---------------------------------------------------------------------------------------------------------------------\n\t/*Round start and end point for snapping*/\n\tDROP TABLE IF EXISTS snapped_drawn_features; \n \tCREATE TEMP TABLE snapped_drawn_features AS \n\tSELECT d.id AS did, ST_ReducePrecision(st_startpoint(d.geom), 0.00001) geom, 's' AS point_type, FALSE AS snapped, NULL::integer AS node_id \n\tFROM drawn_features d\n\tUNION ALL \n\tSELECT d.id AS did, ST_ReducePrecision(st_endpoint(d.geom), 0.00001) geom, 'e' AS point_type, FALSE AS snapped, NULL AS node_id  \n\tFROM drawn_features d; \n\n\tALTER TABLE snapped_drawn_features ADD COLUMN id serial; \n\tCREATE INDEX ON snapped_drawn_features USING GIST(geom);\n\tCREATE INDEX ON snapped_drawn_features (id);\n\t\n\t/*Snapping to existing Nodes*/\n\tDROP TABLE IF EXISTS snapped_to_node; \n\tCREATE TEMP TABLE snapped_to_node AS  \n\tSELECT r.id, r.did, r.point_type, r.geom original_geom, s.geom node_geom, s.id AS node_id \n\tFROM snapped_drawn_features r\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT n.id, n.geom\n\t\tFROM basic.node n\n\t\tWHERE ST_Intersects(ST_BUFFER(r.geom,0.00001), n.geom)\n\t\tAND n.scenario_id IS NULL \n\t\tORDER BY r.geom <-> n.geom\n\t\tLIMIT 1\n\t) s;\n\tCREATE INDEX ON snapped_to_node USING GIST(node_geom); \t\n\n\tUPDATE snapped_drawn_features d\n\tSET geom = node_geom, snapped = TRUE, node_id = s.node_id \n\tFROM snapped_to_node s \n\tWHERE s.did = d.did \n\tAND d.point_type = s.point_type;  \n\t\t\n\t/*Snapping to existing edges*/\n\tDROP TABLE IF EXISTS snapped_to_edge; \n\tCREATE TEMP TABLE snapped_to_edge AS  \n\tSELECT r.id, r.did, r.point_type, r.geom original_geom, s.geom closest_point_edge \n\tFROM snapped_drawn_features r\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT n.id, ST_CLOSESTPOINT(n.geom, r.geom) AS geom \n\t\tFROM basic.edge n\n\t\tWHERE ST_Intersects(ST_BUFFER(r.geom,0.00001), n.geom)\n\t\tAND n.scenario_id IS NULL \n\t\tORDER BY r.geom <-> ST_CLOSESTPOINT(n.geom, r.geom)\n\t\tLIMIT 1\n\t) s\n\tWHERE r.snapped = False;\n\t\n\tUPDATE snapped_drawn_features d\n\tSET geom = closest_point_edge, snapped = True\n\tFROM snapped_to_edge s \n\tWHERE s.did = d.did \n\tAND d.point_type = s.point_type;  \n\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, 0, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE d.id = s.did \n\tAND s.snapped = TRUE \n\tAND s.point_type = 's';\n\t\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, -1, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE d.id = s.did \n\tAND s.snapped = TRUE \n\tAND s.point_type = 'e';\n\n\t/*Snapping drawn features to each other*/\t\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, 0, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE s.snapped = FALSE \n\tAND s.point_type = 's'\n\tAND d.id = s.did; \n\t\n\tUPDATE drawn_features d\n\tSET geom = st_setpoint(d.geom, -1, s.geom)\n\tFROM snapped_drawn_features s\n\tWHERE s.snapped = FALSE \n\tAND s.point_type = 'e'\n\tAND d.id = s.did; \n\t\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Cut network\n\t---------------------------------------------------------------------------------------------------------------------\n\t/*Extend lines to cut network*/\t\t\n\tDROP TABLE IF EXISTS extended_lines; \n\tCREATE TEMP TABLE extended_lines AS  \n\tWITH agg_snapped_nodes AS \n\t(\n\t\tSELECT d.id, ARRAY_AGG(point_type) AS point_type \n\t\tFROM snapped_to_node s, drawn_features d \n\t\tWHERE d.id = s.did \n\t\tGROUP BY d.id\n\t)\n\tSELECT CASE WHEN ARRAY['e', 's'] && point_type THEN d.geom\n\tWHEN ARRAY['s'] = point_type THEN basic.extend_line(d.geom, 0.00001, 'end')\n\tWHEN ARRAY['e'] = point_type THEN basic.extend_line(d.geom, 0.00001, 'start')\n\tEND AS geom \n\tFROM agg_snapped_nodes a, drawn_features d\n\tWHERE a.id = d.id \n\tAND d.way_type <> 'bridge'\n\tUNION ALL \n\tSELECT basic.extend_line(d.geom, 0.00001, 'both') \n\tFROM drawn_features d \n\tLEFT JOIN snapped_to_node s \n\tON d.id = s.did \n\tWHERE s.id IS NULL\n\tAND d.way_type <> 'bridge';  \n\t\t\n\t/*Intersects drawn bridges*/\n\tDROP TABLE IF EXISTS start_end_bridges;\n\tCREATE TEMP TABLE start_end_bridges AS \n\tSELECT st_startpoint(geom) AS geom \n\tFROM drawn_features\n\tWHERE way_type = 'bridge'\n\tUNION \n\tSELECT ST_endpoint(geom) AS geom \n\tFROM drawn_features\n\tWHERE way_type = 'bridge';\n\tCREATE INDEX ON start_end_bridges USING GIST(geom);\n\n\t/*Intersect drawn ways with existing ways*/\n\tDROP TABLE IF EXISTS intersection_existing_network;\n\tCREATE TEMP TABLE intersection_existing_network AS \n\t\n\tWITH intersection_result AS \n\t(\n\t\tSELECT (ST_DUMP(ST_Intersection(d.geom, w.geom))).geom AS geom \n\t\tFROM extended_lines d, basic.edge w\n\t\tWHERE ST_Intersects(ST_BUFFER(d.geom, 0.00001), w.geom)\n\t\tAND w.scenario_id IS NULL\n\t)\n\tSELECT i.geom AS geom \n\tFROM intersection_result i \n\tWHERE st_geometrytype(i.geom) = 'ST_Point'; \n\n\tINSERT INTO intersection_existing_network\n\tWITH to_add AS\n\t(\n\t\tSELECT scenario_id_input AS scenario_id, x.closest_point AS geom \n\t\tFROM start_end_bridges s \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_CLOSESTPOINT(w.geom,s.geom) AS closest_point, ST_LineLocatePoint(w.geom,s.geom) AS fraction\n\t\t\tFROM basic.edge w \n\t\t\tWHERE w.scenario_id IS NULL \n\t\t\tAND ST_Intersects(St_buffer(s.geom,0.00001), w.geom)\n\t\t\tORDER BY ST_CLOSESTPOINT(geom,s.geom) <-> s.geom\n\t\t  \tLIMIT 1\n\t\t) x\n\t) \n\tSELECT a.geom\n\tFROM to_add a \n\tLEFT JOIN intersection_existing_network i \n\tON ST_Intersects(ST_BUFFER(a.geom, 0.00001), i.geom)\n\tWHERE i.geom IS NULL;  \n\t\n\tDROP TABLE IF EXISTS distinct_intersection_existing_network; \n\tCREATE TABLE distinct_intersection_existing_network AS \n\tSELECT DISTINCT geom\n\tFROM intersection_existing_network i;  \n\t\n\tCREATE INDEX ON distinct_intersection_existing_network USING GIST(geom);\n\tALTER TABLE distinct_intersection_existing_network ADD COLUMN id serial;\n\tALTER TABLE distinct_intersection_existing_network ADD PRIMARY key(id);\n\t\n\t/*Filter out snapped start or end point*/\n\tDELETE FROM intersection_existing_network h\n\tUSING \n\t(\n\t\tSELECT h.geom \n\t\tFROM snapped_to_node n, distinct_intersection_existing_network h \n\t\tWHERE ST_Intersects(ST_BUFFER(n.node_geom,0.00001), h.geom)\n\t) d \n\tWHERE h.geom = d.geom; \n\n\tDROP TABLE IF EXISTS split_drawn_features;\n\t/*Split network with itself*/\n\tSELECT count(*) \n\tINTO cnt\n\tFROM drawn_features\n\tWHERE (way_type IS NULL OR way_type <> 'bridge')\n\tLIMIT 2;\n\t\n\tIF cnt <= 1 THEN\n\t    CREATE TEMP TABLE split_drawn_features as\n\t    SELECT id as did, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id  \n\t\tFROM drawn_features;\n\tELSE \n\t\tCREATE TEMP TABLE split_drawn_features AS\n\t\tSELECT id AS did, basic.split_by_drawn_lines(id::integer,geom) AS geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id  \n\t\tFROM drawn_features\n\t\tWHERE (way_type IS NULL OR way_type <> 'bridge')\n\t\tUNION ALL \n\t\tSELECT id AS did, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id  \n\t\tFROM drawn_features\n\t\tWHERE way_type = 'bridge';\n\tEND IF;\n\tCREATE INDEX ON split_drawn_features USING GIST(geom);\n\n\t/*Create perpendicular lines to split new network*/\n\tDROP TABLE IF EXISTS perpendicular_split_lines;\n\tCREATE TEMP TABLE perpendicular_split_lines AS \n\tSELECT basic.create_intersection_line(i.geom, 0.000001) AS geom \n\tFROM intersection_existing_network i;\n\t\n\tDROP TABLE IF EXISTS union_perpendicular_split_lines; \n\tCREATE TEMP TABLE union_perpendicular_split_lines AS \n\tSELECT ST_Union(geom) AS geom  \n\tFROM perpendicular_split_lines p; \n\t\n\t/*Split new network with existing network*/\n\tDROP TABLE IF EXISTS new_network;\n\tCREATE TEMP TABLE new_network AS\n\tSELECT d.did, (dp.geom).geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id, 'geom' AS edit_type  \n\tFROM split_drawn_features d, union_perpendicular_split_lines w, \n\tLATERAL (SELECT ST_DUMP(ST_CollectionExtract(ST_SPLIT(d.geom,w.geom),2)) AS geom) dp\n\tWHERE (d.way_type IS NULL OR d.way_type <> 'bridge');\n\tCREATE INDEX ON new_network USING GIST(geom);\n\n\t/*Delete extended part*/\n\tDELETE FROM new_network\n\tWHERE st_length(geom) < 0.0000011;\n\n\t/*Inject drawn bridges*/\n\tINSERT INTO new_network(did, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id, edit_type) \n\tSELECT id, geom, way_type, surface, wheelchair, lit, foot, bicycle, scenario_id, original_id, 'geom'\n\tFROM drawn_features \n\tWHERE way_type = 'bridge';\n\n\tALTER TABLE new_network ADD COLUMN id serial;\n\tALTER TABLE new_network ADD COLUMN source integer;\n\tALTER TABLE new_network ADD COLUMN target integer;\n\t\n\t---------------------------------------------------------------------------------------------------------------------\n\t--Prepare source and target\n\t---------------------------------------------------------------------------------------------------------------------\n\t/*Existing network is split using perpendicular lines*/\n\tDROP TABLE IF EXISTS existing_network;\n\tCREATE TEMP TABLE existing_network as \n\tSELECT w.id AS original_id, w.class_id, w.surface, w.foot, w.bicycle, (dp.geom).geom, w.source, w.target, \n\tw.lit_classified, w.wheelchair_classified, w.impedance_surface\n\tFROM basic.edge w, union_perpendicular_split_lines p, \n\tLATERAL (SELECT ST_DUMP(ST_CollectionExtract(ST_SPLIT(w.geom,p.geom),2)) AS geom) dp\n\tWHERE ST_Intersects(w.geom, p.geom)\n\tAND w.scenario_id IS NULL\n\tAND w.id NOT IN (SELECT way_id FROM modified_attributes_only);\n\tALTER TABLE existing_network ADD COLUMN id serial;\n\tALTER TABLE existing_network ADD PRIMARY KEY(id);\n\tCREATE INDEX ON existing_network USING GIST(geom);\n\t\n\t/*Assign vertices that where snapped to new features*/\n\tUPDATE new_network n\n\tSET SOURCE = s.node_id\n\tFROM snapped_drawn_features s\n\tWHERE n.did = s.did \n\tAND s.node_id IS NOT NULL \n\tAND s.point_type = 's'; \n\t\n\tUPDATE new_network n\n\tSET target = s.node_id\n\tFROM snapped_drawn_features s\n\tWHERE n.did = s.did \n\tAND s.node_id IS NOT NULL \n\tAND s.point_type = 'e'; \n\n\t/*Create new vertices*/\n\tDROP TABLE IF EXISTS loop_vertices; \n\tCREATE TEMP TABLE loop_vertices AS \n\tSELECT d.geom, ARRAY_AGG(id)::integer[] new_network_ids , ARRAY_AGG(point_type)::text[] AS point_types  \n\tFROM \n\t(\n\t\tSELECT st_startpoint(geom) geom, e.id, 's' AS point_type \n\t\tFROM new_network e \n\t\tWHERE SOURCE IS NULL \n\t\tUNION ALL \n\t\tSELECT st_endpoint(geom) geom, e.id, 'e' AS point_type \n\t\tFROM new_network e \n\t\tWHERE target IS NULL \n\t) d\n\tGROUP BY d.geom;\n\n\tDROP TABLE IF EXISTS new_vertices;  \n\tCREATE TEMP TABLE new_vertices \n\t(\n\t\tnode_id integer,\n\t\tnew_network_ids integer[],\n\t\tpoint_types text[],\n\t\tgeom geometry\n\t);\n\t/*\n\tDO $$\n\tDECLARE \n\t\trec record;\n\t\tmax_id integer; \n\tBEGIN*/\n\tFOR rec IN SELECT * FROM loop_vertices v\n\tLOOP \n\t\tmax_id = (SELECT max(id) FROM basic.node);\n\t\tWITH i AS \n\t\t(\n\t\t\tINSERT INTO basic.node (id, scenario_id, geom) \n\t\t\tVALUES(max_id + 1, scenario_id_input, rec.geom)\n\t\t\tRETURNING id, geom\n\t\t)\n\t\tINSERT INTO new_vertices(node_id, new_network_ids, point_types, geom)\n\t\tSELECT i.id, rec.new_network_ids, rec.point_types, i.geom  \n\t\tFROM i;\t\t\t\n\tEND LOOP;\n\t/*END $$;*/\n\tCREATE INDEX ON new_vertices USING GIST(geom);\n\t\n\tWITH unnest_to_update AS \n\t(\n\t\tSELECT v.node_id, UNNEST(v.new_network_ids) new_network_id, UNNEST(v.point_types) point_type\n\t\tFROM new_vertices v \n\t)\n\tUPDATE new_network n\n\tSET SOURCE = u.node_id \n\tFROM unnest_to_update u\n\tWHERE n.id = u.new_network_id \n\tAND point_type = 's';\n\t\n\tWITH unnest_to_update AS \n\t(\n\t\tSELECT v.node_id, UNNEST(v.new_network_ids) new_network_id, UNNEST(v.point_types) point_type\n\t\tFROM new_vertices v \n\t)\n\tUPDATE new_network n  \n\tSET target = u.node_id \n\tFROM unnest_to_update u\n\tWHERE n.id = u.new_network_id  \n\tAND point_type = 'e';\n\n\tDROP TABLE IF EXISTS new_source_target_existing; \n\tCREATE TEMP TABLE new_source_target_existing AS \n\tWITH start_and_end AS \n\t(\n\t\tSELECT e.id, st_startpoint(geom) geom, 's' AS point_type\n\t\tFROM existing_network e \n\t\tUNION ALL \n\t\tSELECT e.id,  st_endpoint(geom) geom, 'e' AS point_type  \n\t\tFROM existing_network e\n\t)\n\tSELECT v.id, point_type, c.node_id, v.geom  \n\tFROM start_and_end v\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT n.node_id \n\t\tFROM new_vertices n\n\t\tWHERE ST_Intersects(ST_BUFFER(v.geom, 0.00001), n.geom)\n\t\tORDER BY n.geom <-> v.geom \n\t\tLIMIT 1 \n\t) c;\n\t\n\tUPDATE existing_network e\n\tSET SOURCE = n.node_id \n\tFROM new_source_target_existing n \n\tWHERE e.id = n.id \n\tAND n.point_type = 's';\n\t\n\tUPDATE existing_network e\n\tSET target = n.node_id \n\tFROM new_source_target_existing n \n\tWHERE e.id = n.id \n\tAND n.point_type = 'e';\n\n\tDROP TABLE IF EXISTS network_to_add;\n\tCREATE TEMP TABLE network_to_add AS \n\tSELECT original_id, class_id, surface, foot, bicycle, geom, SOURCE, target, lit_classified, wheelchair_classified, impedance_surface  \n\tFROM existing_network  \n\tUNION ALL \n\tSELECT NULL, 100, surface, foot, bicycle, geom, SOURCE, target, lit, wheelchair, NULL \n\tFROM new_network;\n\t\n\tCREATE INDEX ON network_to_add USING GIST(geom);\n\t\n\t---Attach attributes to vertices\n\tDROP TABLE IF EXISTS vertices_to_add;\n\tCREATE TEMP TABLE vertices_to_add AS \n\tSELECT vv.node_id, array_remove(array_agg(DISTINCT x.class_id),NULL) class_ids,\n\tarray_remove(array_agg(DISTINCT x.foot),NULL) AS foot,\n\tarray_remove(array_agg(DISTINCT x.bicycle),NULL) bicycle,\n\tarray_remove(array_agg(DISTINCT x.lit_classified),NULL) lit_classified,\n\tarray_remove(array_agg(DISTINCT x.wheelchair_classified),NULL) wheelchair_classified,\n\tvv.geom\n\tFROM new_vertices  vv\n\tLEFT JOIN\n\t(\t\n\t\tSELECT v.node_id, w.class_id, w.foot, w.bicycle, w.lit_classified, w.wheelchair_classified \n\t\tFROM new_vertices v, network_to_add w \n\t\tWHERE st_intersects(ST_BUFFER(v.geom,0.00001),w.geom)\n\t) x\n\tON vv.node_id = x.node_id\n\tGROUP BY vv.node_id, vv.geom;\n\tCREATE INDEX ON vertices_to_add (node_id);\n\n\t----------------------------------------------------------------------------------------------------------------------\n\t--INSERT NEW VERTICES AND WAYS INTO THE EXISTING TABLES\n\t----------------------------------------------------------------------------------------------------------------------\n\n\tUPDATE basic.node n \n\tSET class_ids = v.class_ids, foot = v.foot, bicycle = v.bicycle, lit_classified = v.lit_classified, wheelchair_classified = v.wheelchair_classified \n\tFROM vertices_to_add v \n\tWHERE n.id = v.node_id\n\tAND n.scenario_id = scenario_id_input; \n\n\t/*DO $$\n\tDECLARE \n\t\trec record;\n\t\tmax_id integer; \n\tBEGIN*/\n\tFOR rec IN SELECT * FROM network_to_add  v\n\tLOOP \n\t\tmax_id = (SELECT max(id) FROM basic.edge);\n\t\n\t\tINSERT INTO basic.edge(id, class_id, source, target, foot, bicycle, wheelchair_classified, lit_classified, impedance_surface, geom, coordinates_3857, length_m, length_3857, scenario_id, edge_id) \n\t\tSELECT max_id + 1, rec.class_id, rec.SOURCE, rec.target, rec.foot, rec.bicycle, rec.wheelchair_classified, \n\t\trec.lit_classified, rec.impedance_surface, rec.geom, (ST_AsGeoJSON(ST_Transform(rec.geom,3857))::json->'coordinates')::json, \n\t\tST_LENGTH(rec.geom::geography), ST_LENGTH(ST_TRANSFORM(rec.geom, 3857)), scenario_id_input, rec.original_id\n\t\t;\t\t\n\tEND LOOP;\n\t/*END $$;*/\n\t\n\t\n    /*Set impedances for existing but now split network\n\tUPDATE ways_userinput ww\n\tSET s_imp = w.s_imp, rs_imp = w.rs_imp\n\tFROM ways_userinput w\n\tWHERE ww.original_id = w.id \n\tAND ww.scenario_id = 1\n\tAND w.scenario_id IS NULL; \n\t\n\tIF EXISTS\n\t\t( SELECT 1\n\t\t\tFROM   information_schema.tables \n\t\t\tWHERE  table_schema = 'public'\n\t\t\tAND    table_name = 'dem'\n\t\t)\n\tTHEN\n\t\tWITH impedances AS \n\t\t(\n\t\t\tSELECT w.id, ci.imp, ci.rs_imp\n\t\t\tFROM ways_userinput w,\n\t\t\tLATERAL get_slope_profile(w.id, 10, 'ways_userinput') sp, LATERAL compute_impedances(sp.elevs, sp.linkLength, 10) ci\n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND original_id IS NULL \n\t\t)\n\t\tUPDATE ways_userinput w\n\t\tSET s_imp = i.imp, rs_imp = i.rs_imp \n\t\tFROM impedances i \n\t\tWHERE w.id = i.id;\n\t\t\t\t\t\n\tEND IF;\n\t*/\nEND\n$function$"
    )
    op.drop_entity(basic_network_modification)

    basic_population_modification = PGFunction(
        schema="basic",
        signature="population_modification(scenario_id_input integer)",
        definition="returns SETOF void\nLANGUAGE plpgsql\nAS $function$\nDECLARE \n\taverage_gross_living_area integer := basic.select_customization('average_gross_living_area');\nBEGIN \n\n\tUPDATE customer.building_modified b\n\tSET area = ST_AREA(geom::geography), population = (b.building_levels_residential * ST_AREA(b.geom::geography) / average_gross_living_area) \n\tWHERE scenario_id = scenario_id_input; \n\t\n\tWITH count_pop AS (\n\t\tSELECT count(*) AS count_points, building_modified_id \n\t\tFROM customer.population_modified \n\t\tWHERE scenario_id = scenario_id_input\n\t\tGROUP BY building_modified_id  \n\t),\n\tpoints_to_update AS \n\t(\n\t\tSELECT p.id, b.id AS building_modified_id, b.population / c.count_points AS population \n\t\tFROM customer.building_modified b, customer.population_modified p, count_pop c  \n\t\tWHERE b.id = p.building_modified_id  \n\t\tAND b.id = c.building_modified_id  \n\t\tAND b.scenario_id = scenario_id_input\n\t\tAND p.scenario_id = scenario_id_input\n\t\tAND b.building_type = 'residential'\n\t)\n\tUPDATE customer.population_modified p \n\tSET population = u.population \n\tFROM points_to_update u \n\tWHERE p.id = u.id; \n\nEND\n$function$;\n/*\nSELECT basic.population_modification(13)\n*/"
    )
    op.drop_entity(basic_population_modification)

    basic_prepare_heatmap_population = PGFunction(
        schema="basic",
        signature="prepare_heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default'::text, scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population double precision, percentile_population integer, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_buildings integer[] := basic.modified_buildings(scenario_id_input);\nBEGIN \n\t\n\tIF modus_input = 'default' THEN \n\t\tscenario_id_input = 0;\n\tEND IF;\n\t\n\tRETURN query\n\tWITH modified_population AS \n\t(\n\t\tSELECT p.geom, -p.population AS population\n\t\tFROM basic.population p \n\t\tWHERE building_id IN (SELECT UNNEST(modified_buildings))\n\t\tUNION ALL \n\t\tSELECT p.geom, p.population \n\t\tFROM customer.population_modified p \n\t\tWHERE p.scenario_id = scenario_id_input \n\t),\n\tsum_pop AS (\n\t\tSELECT g.id, sum(p.population) + COALESCE(g.population,0) population, \n\t\tCASE WHEN sum(p.population) + COALESCE(g.population,0) BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 20 AND 80 THEN 2\n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  > 400 THEN 5 END AS percentile_population, g.geom\n\t\tFROM basic.grid_visualization g, modified_population p, basic.study_area_grid_visualization s\n\t\tWHERE ST_Intersects(g.geom,p.geom)\n\t\tAND p.population IS NOT NULL \n\t\tAND g.id = s.grid_visualization_id \n\t\tAND s.study_area_id = active_study_area_id\n\t\tGROUP BY g.id, g.population, g.geom\n\t) \n\tSELECT s.id AS grid_visualization_id ,s.population, s.percentile_population, s.geom \n\tFROM sum_pop s\n\tUNION ALL \n\tSELECT g.id AS grid_visualization_id, g.population, g.percentile_population, g.geom\n\tFROM \n\t(\n\t\tSELECT g.* \n\t\tFROM basic.grid_visualization  g, basic.study_area_grid_visualization sa\n\t\tWHERE sa.study_area_id = active_study_area_id \n\t\tAND g.id = sa.grid_visualization_id \n\t) g \n\tLEFT JOIN sum_pop s\n\tON g.id = s.id\n\tWHERE s.id IS NULL;\n\t\nEND\n$function$;\n/*\nSELECT * \nFROM basic.prepare_heatmap_population(13)\n*/"
    )
    op.drop_entity(basic_prepare_heatmap_population)

    basic_reached_population_polygon = PGFunction(
        schema="basic",
        signature="reached_population_polygon(ischrone_calculation_id_input integer, scenario_id_input integer, modus TEXT, region TEXT)",
        definition="returns TABLE (isochrone_feature_id integer, step integer, reached_opportunities jsonb)\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[];\n\tregion_geom geometry := ST_SETSRID(ST_GeomFromText(region), 4326);\n\treachable_population integer; \n\treachable_population_default integer; \n\treachable_population_scenario integer;  \nBEGIN\n\t\n\t/*Check if invalid modus*/\n\tIF modus NOT IN ('default','scenario') THEN \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t/*Get reachable population*/\n\tIF modus IN ('default','scenario')  THEN\n\t\tSELECT COALESCE(population, 0)  \n\t\tINTO reachable_population_default\n\t\tFROM basic.population p \n\t\tWHERE ST_Intersects(p.geom, region_geom); \n\tEND IF; \n\t\n\tIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE ST_Intersects(p.geom, region_geom)\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tUNION ALL \n\t\t\tSELECT sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE ST_Intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t \t)\n \t\tSELECT COALESCE(sum(population), 0)::integer \n \t\tINTO reachable_population_scenario  \n\t\tFROM prepared_scenario p; \n\t\n\t\treachable_population = floor((reachable_population_default  + reachable_population_scenario / 5)*5); \n\t\t\n\tEND IF; \n\t\n\treachable_population = floor((reachable_population_default / 5)*5);\n\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t)\n\tSELECT g.id AS isochrone_feature_id,(floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population\n\tFROM to_group g\n\tGROUP BY g.id;\n\t\n    /*Combine and return results*/\n\tRETURN query \n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = jsonb_build_object('name', 'polygon', 'reached_population', population, 'total_population', reachable_population)  \n\tFROM reached_population r \n\tWHERE i.id = r.isochrone_feature_id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n\nEND; \n$function$ LANGUAGE plpgsql;\n\n/*\nSELECT * \nFROM basic.reached_population_polygon(88, 2, 'default',\n'POLYGON ((11.570115749093093 48.15360025891228, 11.570274296106232 48.1518693270582, 11.572708788648153 48.15118483030911, 11.574984827528402 48.15223125586774, 11.574826384986741 48.15396220424526, 11.57239179909107 48.154646710542, 11.570115749093093 48.15360025891228))') \n*/"
    )
    op.drop_entity(basic_reached_population_polygon)

    basic_heatmap_prepare_artificial = PGFunction(
        schema="basic",
        signature="heatmap_prepare_artificial(grid_helper_classes integer[])",
        definition="returns void\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tx float[];\n\ty float[]; \nBEGIN \n\tWITH p AS \n\t(\n\t\tSELECT ST_CENTROID(c.geom) AS geom \n\t\tFROM temporal.heatmap_grid_helper h, basic.grid_calculation c \n\t\tWHERE cid IN (SELECT UNNEST(grid_helper_classes))\n\t\tAND h.id = c.grid_visualization_id \n\t)\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p\n\tINTO x, y; \n\n\tPERFORM basic.create_multiple_artificial_edges(x, y, 1200., 1.33, 'default', 1, 'walking_standard'); \n\t\n\t\n\tDROP TABLE IF EXISTS temporal.heatmap_edges_artificial; \n\tCREATE TABLE temporal.heatmap_edges_artificial AS\n\tSELECT * FROM final_artificial_edges;\n\tALTER TABLE temporal.heatmap_edges_artificial ADD PRIMARY KEY(id);\n\tCREATE INDEX ON temporal.heatmap_edges_artificial USING GIST(geom);\n\t\n\tDROP TABLE IF EXISTS temporal.heatmap_starting_vertices; \n\tCREATE TABLE temporal.heatmap_starting_vertices AS\n\tSELECT * FROM starting_vertices;\n\tCREATE INDEX ON temporal.heatmap_starting_vertices USING GIST(geom);\n\nEND;\n$function$;\n/*\n * SELECT basic.heatmap_prepare_artificial(ARRAY[1,2,3,4])\n */"
    )
    op.drop_entity(basic_heatmap_prepare_artificial)

    basic_poi_aoi_visualization = PGFunction(
        schema="basic",
        signature="poi_aoi_visualization(user_id_input integer, scenario_id_input integer, active_upload_ids integer[], active_study_area_id integer)",
        definition="returns TABLE (id integer, uid TEXT, category TEXT, name TEXT, opening_hours TEXT, street TEXT, housenumber TEXT, zipcode TEXT, edit_type TEXT, geom geometry)\nLANGUAGE plpgsql\nAS $function$\nDECLARE \t\n\taoi_categories TEXT[]; \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tcombined_poi_categories text[];\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\tbuffer_geom_study_area geometry; \nBEGIN\n\t\n\t/*Get combined poi categories*/\n\tSELECT ARRAY_AGG(c.category)\n\tINTO combined_poi_categories\n\tFROM \t\n\t(\n\t\tSELECT jsonb_array_elements_text(poi_categories -> 'true') category\n\t\tUNION ALL \n\t\tSELECT jsonb_array_elements_text(poi_categories -> 'false') category\n\t) c;\n\n\t/*Prepare AOI categories*/\n\tDROP TABLE IF EXISTS aoi_groups_default; \n\tCREATE TEMP TABLE aoi_groups_default AS \n\tWITH aoi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(basic.select_customization('aoi_groups')) aoi_group\n\t)\n\tSELECT jsonb_array_elements(p.aoi_group -> jsonb_object_keys(p.aoi_group) -> 'children') AS aoi_category \n\tFROM aoi_groups p;\n\n\tSELECT ARRAY_AGG(object_keys) AS aoi_category\n\tINTO aoi_categories\n\tFROM aoi_groups_default  p, LATERAL jsonb_object_keys(p.aoi_category) object_keys;  \n\t\n\t/*Check if POI scenario*/\n\tIF scenario_id_input <> 0 THEN \n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\tEND IF; \n\t/*Buffer study area to avoid border effects*/\n\tbuffer_geom_study_area = (SELECT buffer_geom_heatmap AS geom FROM basic.study_area s WHERE s.id = active_study_area_id);\n\n    RETURN query\n   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM basic.poi p\n\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM customer.poi_user p\n\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\t/*No scenarios nor aoi_user is implemented at the moment*/\n\tSELECT p.id, NULL, p.category, p.name, p.opening_hours, NULL AS street, NULL AS housenumber, NULL AS zipcode, NULL AS edit_type, p.geom\n\tFROM basic.aoi p \n\tWHERE p.category IN (SELECT UNNEST(aoi_categories))\n\tAND p.geom && buffer_geom_study_area; \n\t\n\tIF scenario_id_input <> 0 THEN \n\t   \tRETURN query \n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, p.edit_type, p.geom  \n\t\tFROM customer.poi_modified p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.scenario_id = scenario_id_input; \n\t   \t\n\t\tRETURN query\n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM basic.poi p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\t\n\t\tRETURN query \n\t\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM customer.poi_user p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\tEND IF; \nEND ;\n$function$;\n\n\n/*\nModus should be default, scenario, comparison\nSELECT * \nFROM basic.poi_aoi_visualization(4, 2, 'default', ARRAY[0], 1)\n*/"
    )
    op.drop_entity(basic_poi_aoi_visualization)

    basic_reached_pois_heatmap = PGFunction(
        schema="basic",
        signature="reached_pois_heatmap(table_name TEXT, calculation_geom geometry, user_id_input integer, scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[], poi_modified_uid text DEFAULT '')",
        definition="returns VOID\nAS $function$\nDECLARE\n\tsensitivities jsonb:= basic.select_customization('heatmap_sensitivities'); \n\tsnap_distance integer := basic.select_customization('snap_distance_poi_heatmap')::integer; \n\tbuffer_pois geometry := ST_BUFFER(calculation_geom::geography, snap_distance)::geometry;\n\tpoi_categories jsonb := basic.poi_categories(user_id_input); \n\tarr_categories text[];\nBEGIN \n\t\n\tIF table_name = 'poi_user' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap \n\t\tWHERE data_upload_id IN (SELECT UNNEST(data_upload_ids));\n\t\n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap r\n\t\tWHERE poi_uid = poi_modified_uid\n\t\tAND scenario_id = scenario_id_input;\n\t\n\tEND IF; \n\n\tWITH categories AS\n\t(\n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'true') AS category\n\t\tUNION ALL \n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'false') AS category\n\t)\n\tSELECT array_agg(category)\n\tFROM categories \n\tINTO arr_categories; \n\t\n\tIF table_name = 'poi' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, NULL AS data_upload_id  \n\t\tFROM basic.poi p \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE p.category IN (SELECT UNNEST(arr_categories))\n\t\tAND ST_Intersects(p.geom, buffer_pois); \n\tELSEIF table_name = 'poi_user' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, p.data_upload_id \n\t\tFROM customer.poi_user p \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE ST_Intersects(p.geom, buffer_pois)\n\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids)); \n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, scenario_id_input AS scenario_id, p.data_upload_id  \n\t\tFROM (SELECT * FROM customer.poi_modified x WHERE x.uid = poi_modified_uid AND x.scenario_id = scenario_id_input) p\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f;\n\tELSE \n\t\tRAISE EXCEPTION 'Please specify a valid table name.';\n\tEND IF;\n\t\n\tCREATE INDEX ON pois_edges_full (edge_id);\t\n\tINSERT INTO customer.reached_poi_heatmap(poi_uid, scenario_id, data_upload_id, grid_visualization_ids, costs, accessibility_indices)\n\tWITH pois_with_cost AS \n\t(\n\t\tSELECT f.poi_uid, f.scenario_id, c.grid_visualization_id, c.COST, f.data_upload_id \n\t\tFROM pois_edges_full f\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT e.grid_visualization_id, avg(e.cost) AS COST \n\t\t\tFROM \n\t\t\t(\n\t\t\t\tSELECT c.grid_visualization_id,\n\t\t\t\tCASE WHEN r.start_cost < r.end_cost THEN (r.start_cost + f.fraction * (r.end_cost-r.start_cost))\n\t\t\t\tELSE (r.end_cost + (1-f.fraction) * (r.start_cost - r.end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND (r.edge_type IS NULL or r.edge_type = 'a')\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t\tUNION ALL \n\t\t\t\tSELECT c.grid_visualization_id, CASE WHEN start_cost < end_cost THEN (start_cost + fraction * (end_cost-start_cost))\n\t\t\t\tELSE (end_cost + (1-fraction) * (start_cost - end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND edge_type IN ('p', 'ap')\n\t\t\t\tAND f.fraction BETWEEN least(r.start_perc,r.end_perc) AND greatest(r.start_perc,r.end_perc)\t\t\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t) e\t\n\t\t\tGROUP BY e.grid_visualization_id \n\t\t) AS c \n\t),\n\tfirst_merge AS\n\t(\n\t\tSELECT poi_uid, scenario_id, data_upload_id, array_agg(grid_visualization_id) AS grid_visualization_ids , array_agg(cost) AS costs   \n\t\tFROM pois_with_cost \n\t\tGROUP BY poi_uid, scenario_id, data_upload_id  \n\t)\n\tSELECT f.poi_uid, f.scenario_id::integer, f.data_upload_id::integer, f.grid_visualization_ids, f.costs, a.accessibility_indices\n\tFROM first_merge f\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT ARRAY_AGG(accessibility_indices) AS accessibility_indices \n\t\tFROM \n\t\t(\n\t\t\tSELECT array_AGG((pow(exp(1.0)::real,(p.cost::real * p.cost::real) / -s.sensitivity) * (10000))::integer) AS accessibility_indices, s.sensitivity  \n\t\t\tFROM (SELECT sensitivity::REAL FROM jsonb_array_elements(basic.select_customization('heatmap_sensitivities')) sensitivity) s, \n\t\t\t(SELECT UNNEST(f.costs) cost) p\n\t\t\tGROUP BY sensitivity \n\t\t\tORDER BY sensitivity \n\t\t) s\n\t) AS a;\n\t\nEND;\n$function$ LANGUAGE plpgsql\n\n/*\nEXPLAIN ANALYZE \nSELECT basic.reached_pois_heatmap('poi_modified'::text, geom, 4, 75, ARRAY[0]::integer[], 'd0c79777fcdc4d55b02da0ef17470bef'::text) \nFROM (SELECT * FROM customer.poi_modified pm WHERE uid = 'd0c79777fcdc4d55b02da0ef17470bef') p\n*/"
    )
    op.drop_entity(basic_reached_pois_heatmap)

    basic_heatmap_accessibility_population = PGFunction(
        schema="basic",
        signature="heatmap_accessibility_population(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition='returns TABLE(grid_visualization_id bigint, accessibility_index bigint, percentile_accessibility integer, percentile_population integer, population_accessibility integer, modus text, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n\t\n\tIF modus_input IN (\'default\',\'scenario\') THEN  \n\t\tRETURN query \n\t\tSELECT h.grid_visualization_id, h.accessibility_index, h.percentile_accessibility, p.percentile_population, \n\t\t(p.percentile_population-h.percentile_accessibility) AS population_accessibility, modus_input, h.geom  \n\t\tFROM basic.heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, modus_input, scenario_id_input, data_upload_ids) h, \n\t\tbasic.heatmap_population(active_study_area_id, modus_input, scenario_id_input) p \n\t\tWHERE p.grid_visualization_id = h.grid_visualization_id;\n\t\t\n\tELSEIF modus_input = \'comparison\' THEN \n\n\t\tDROP TABLE IF EXISTS calc_default; \n\t\tCREATE TEMP TABLE calc_default AS \n\t\tSELECT h.grid_visualization_id, h.accessibility_index, h.percentile_accessibility, p.percentile_population, \n\t\t(p.percentile_population-h.percentile_accessibility) AS population_accessibility, h.geom  \n\t\tFROM basic.heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'default\', scenario_id_input, data_upload_ids) h, \n\t\tbasic.heatmap_population(active_study_area_id, \'default\', scenario_id_input) p \n\t\tWHERE p.grid_visualization_id = h.grid_visualization_id;\n\t\t\n\t\tALTER TABLE calc_default ADD PRIMARY KEY(grid_visualization_id);\n\t\t\n\t\tDROP TABLE IF EXISTS calc_scenario;\n\t\tCREATE TEMP TABLE calc_scenario AS \n\t\tSELECT h.grid_visualization_id, h.accessibility_index, h.percentile_accessibility, p.percentile_population, \n\t\t(p.percentile_population-h.percentile_accessibility) AS population_accessibility, h.geom  \n\t\tFROM basic.heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'scenario\', scenario_id_input, data_upload_ids) h, \n\t\tbasic.heatmap_population(active_study_area_id, \'scenario\', scenario_id_input) p \n\t\tWHERE p.grid_visualization_id = h.grid_visualization_id;\n\t\n\t\tALTER TABLE calc_scenario ADD PRIMARY KEY(grid_visualization_id);\n\t\n\t\tRETURN query\n\t\tSELECT d.grid_visualization_id, NULL::bigint AS accessibility_index, NULL::integer AS percentile_accessibility, NULL::integer AS percentile_population, \n\t\tCASE WHEN d.population_accessibility <> s.population_accessibility \n\t\tTHEN abs(d.population_accessibility) - abs(s.population_accessibility)  \n\t\tELSE 0 END AS population_accessibility, modus_input, d.geom\n\t\tFROM calc_default d, calc_scenario s\n\t\tWHERE d.grid_visualization_id = s.grid_visualization_id;\n\t\n\tEND IF; \nEND\n$function$;\n\n/*\nSELECT * \nFROM basic.heatmap_accessibility_population(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'comparison\', 11, \'{}\'::integer[]) h;\n*/'
    )
    op.drop_entity(basic_heatmap_accessibility_population)

    basic_prepare_heatmap_local_accessibility = PGFunction(
        schema="basic",
        signature="prepare_heatmap_local_accessibility(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition='returns TABLE(grid_visualization_id bigint, accessibility_index bigint)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tarray_amenities text[];\n\tpois_one_entrance jsonb := basic.poi_categories(user_id_input) -> \'false\';\n\tpois_more_entrances jsonb := basic.poi_categories(user_id_input) -> \'true\';\n\tsensitivities integer[]; \n\ttranslation_sensitivities jsonb;\n\texcluded_poi_uids text[] := \'{}\'::TEXT[];\nBEGIN\n  \t\n\tSELECT ARRAY_AGG(s.sensitivity::integer) \n\tINTO sensitivities \n\tFROM (\n\t\tSELECT jsonb_array_elements_text(basic.select_customization(\'heatmap_sensitivities\')) sensitivity \n\t) s;\n\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_one_entrance  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_one_entrance) AS o(category) \n\tWHERE a.category = o.category; \n\t\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_more_entrances  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_more_entrances) AS o(category) \n\tWHERE a.category = o.category; \n\n\tSELECT jsonb_object_agg(k, (sensitivities  # (v ->> \'sensitivity\')::integer)::smallint)\n\tINTO translation_sensitivities\n\tFROM jsonb_each(amenities_json) AS u(k, v);\n\n\tIF modus_input <> \'default\' AND scenario_id_input <> 0 THEN \n\t\texcluded_poi_uids = basic.modified_pois(scenario_id_input); \n\tEND IF; \n\n\tRETURN query\n\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\n\tRETURN query \n\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\tp.category, p.name\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\t\n\tIF data_upload_ids <> \'{}\'::integer[] THEN \n\t\tRETURN query\n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \t\n\tEND IF;\n\n\tIF modus_input <> \'default\' AND scenario_id_input <> 0 THEN \n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p  \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\t\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\tEND IF; \n\t\nEND;\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_heatmap;\nCREATE TABLE default_heatmap AS \nWITH heatmap_grids AS \n(\n\tSELECT grid_visualization_id, sum(accessibility_index) \n\tFROM basic.prepare_heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'default\',10) h\n\tGROUP BY grid_visualization_id \n)\nSELECT h.*, g.geom \nFROM basic.grid_visualization g, heatmap_grids h \nWHERE h.grid_visualization_id = g.id;  \n\nDROP TABLE IF EXISTS pois_to_explore; \nCREATE TABLE pois_to_explore AS \nSELECT * \nFROM basic.poi_aoi_visualization(4, 2, \'default\', ARRAY[0], 1)\nWHERE category = \'supermarket\'\n*/'
    )
    op.drop_entity(basic_prepare_heatmap_local_accessibility)

    basic_count_pois_multi_isochrones = PGFunction(
        schema="basic",
        signature="count_pois_multi_isochrones (userid_input integer, modus text, minutes integer, speed_input numeric, region_type text, region TEXT[], amenities text[], scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE (region_name text, count_pois integer, geom geometry)\n    AS $function$\nDECLARE\n    buffer_geom geometry;\n    region_geom geometry;\n    region_name text;\n    excluded_pois_id text[] := ARRAY[]::text[];\nBEGIN\n\n    IF modus = 'scenario' THEN\n        excluded_pois_id = basic.modified_pois(scenario_id_input);\n    END IF;\n\n    IF region_type = 'study_area' THEN\n        SELECT s.geom, name  \n        INTO region_geom, region_name\n        FROM basic.sub_study_area s\n        WHERE id IN (SELECT UNNEST(region::integer[]));\n    ELSEIF region_type = 'draw' THEN\n        SELECT ST_GeomFromText(region[1]) \n        INTO region_geom;\n        region_name = 'draw';\n    ELSE \n        RAISE EXCEPTION 'Unknown region type\\: %', region_type;\n    END IF;\n    buffer_geom = ST_Buffer(region_geom::geography, speed_input  * 60 * minutes)::geometry;\n    \n    RETURN query \n\tWITH intersected_pois AS (\n        SELECT p.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT p.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.id\n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.scenario_id = scenario_id_input \n    ),\n    count_pois AS \n    (\n    \tSELECT count(*) AS cnt\n    \tFROM intersected_pois\n    )    \n    SELECT region_name, c.cnt::integer,\n    region_geom\n\tFROM count_pois c;\nEND\n$function$\nLANGUAGE plpgsql;\n\n/* Example with starting point to find study_area\nSELECT * FROM basic.count_pois_multi_isochrones(1,'scenario',10,1.33,'study_area',\n'POINT(11.570115749093093 48.15360025891228)', ARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 1, ARRAY[3]);\n \n * Example with drawn polygon\nSELECT * FROM basic.count_pois_multi_isochrones(1,'scenario',10,1.33,'draw',\n'POLYGON ((11.570115749093093 48.15360025891228, 11.570274296106232 48.1518693270582, 11.572708788648153 48.15118483030911, 11.574984827528402 48.15223125586774, 11.574826384986741 48.15396220424526, 11.57239179909107 48.154646710542, 11.570115749093093 48.15360025891228))',\nARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 1, ARRAY[3]);\n */"
    )
    op.drop_entity(basic_count_pois_multi_isochrones)

    basic_thematic_data_sum = PGFunction(
        schema="basic",
        signature="thematic_data_sum(user_id_input integer, input_isochrone_calculation_id integer, modus text, scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE(isochrone_feature_id integer, isochrone_feature_step integer, isochrone_feature_reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tpois_one_entrance jsonb = poi_categories -> 'false'; \n\tpois_more_entrance jsonb = poi_categories -> 'true';\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\texcluded_buildings_id integer[] := ARRAY[]::integer[];\n\tactive_upload_ids integer[];\nBEGIN \t\t\n\n\tIF modus = 'scenario' THEN\n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\tEND IF;\n\n    --Calculate reached AOIs\n\tDROP TABLE IF EXISTS reached_aois; \n\tCREATE TEMP TABLE reached_aois AS  \n\tWITH area_cnt AS \n\t(\n\t\tSELECT i.id, a.category, count(*) as cnt, intersec.area \n\t\tFROM customer.isochrone_feature i, basic.aoi a, \n\t\tLATERAL (SELECT ST_Area(st_intersection(i.geom,a.geom)::geography)::integer area) AS intersec  \n\t\tWHERE isochrone_calculation_id  = input_isochrone_calculation_id\n\t\tAND st_intersects(i.geom,a.geom)\n\t\tGROUP BY i.id, category, name, intersec.area\n\t),\n\tjson_area_cnt AS\n\t(\n\t\tSELECT p.id, p.category, jsonb_build_object('cnt',sum(cnt),'area',sum(area)) AS aois_json\n\t\tFROM area_cnt p \n\t\tGROUP BY p.id, p.category\n\t)\n\tSELECT j.id, jsonb_object_agg(category, aois_json) aois_json_agg\n\tFROM json_area_cnt j\n\tGROUP BY j.id; \n\t\n\n\tDROP TABLE IF EXISTS reached_opportunities; \n\tCREATE TEMP TABLE reached_opportunities \n\t(\n\t\tid integer,\n\t\topportunity_type TEXT, \n\t\tcnt integer\n\t);\n\n\t--Calculate reached population \n\tINSERT INTO reached_opportunities\n\tWITH temp_sum AS \n\t(\n\t\tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM basic.population p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n     \tUNION ALL \n     \tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM customer.population_modified p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.scenario_id = scenario_id_input \n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t)\n\tSELECT s.id, 'sum_pop', sum(s.population)::integer+(5-(sum(s.population)::integer % 5)) as sum_pop \n\tFROM temp_sum s     \t     \n\tGROUP BY s.id; \n\n\t--Calculate reached POIs one entrance \n\tINSERT INTO reached_opportunities\n\tSELECT i.id, s.category, count(*)\n \tFROM customer.isochrone_feature i\n \tCROSS JOIN LATERAL \n\t(\n\t\tSELECT p.category, i.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id \n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.scenario_id = scenario_id_input \n\t) s\n\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n\tGROUP BY category, i.id;\n\n\t--Calculate reached POIs more entrances \n\tINSERT INTO reached_opportunities\n\tWITH more_entrances AS \n\t(\n\t\tSELECT s.category, i.id\n\t \tFROM customer.isochrone_feature i\n\t \tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM basic.poi p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM customer.poi_user p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids)) \n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id \n\t\t\tFROM customer.poi_modified p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t\tGROUP BY name, category, i.id\n\t)\n\tSELECT m.id, m.category, count(*) \n\tFROM more_entrances m \n\tGROUP BY m.category, m.id;\n\n\tRETURN QUERY \n\tWITH group_reached_opportunities AS \n\t(\n\t\tSELECT r.id, jsonb_object_agg(opportunity_type, cnt) reached_opportunities  \n\t\tFROM reached_opportunities r \n\t\tGROUP BY id \n\t),\n\tcombined_opportunities AS \n\t(\n\t\tSELECT COALESCE(g.id, r.id) AS id, COALESCE(reached_opportunities, '{}'::jsonb) || COALESCE(aois_json_agg, '{}'::jsonb) AS reached_opportunities \n\t\tFROM group_reached_opportunities g\n\t\tFULL JOIN reached_aois r  \n\t\tON r.id = g.id \n\t)\n\tUPDATE customer.isochrone_feature i  \n\tSET reached_opportunities = c.reached_opportunities \n\tFROM combined_opportunities c \n\tWHERE i.id = c.id\n\tRETURNING i.id, i.step, i.reached_opportunities; \nEND ;\n$function$\n/*Intersects the isochrone with opportunity data-sets to produce cumulative opportunities*/\n/*\nSELECT * FROM basic.thematic_data_sum(3, 61, 'default', 0, ARRAY[0])\n*/"
    )
    op.drop_entity(basic_thematic_data_sum)

    basic_reached_population_study_area = PGFunction(
        schema="basic",
        signature="reached_population_study_area(ischrone_calculation_id_input integer, scenario_id_input integer, modus text, study_area_ids integer[])",
        definition="returns TABLE(id integer, step integer, reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[];\nBEGIN\n\t\n\tDROP TABLE IF EXISTS reachable_population; \n\n\t/*Get reachable population*/\n\tIF modus = 'default' THEN\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tSELECT s.id AS sub_study_area_id, s.name, s.population \n\t\tFROM basic.sub_study_area s\n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)); \n\t\n\tELSEIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT p.sub_study_area_id, -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tGROUP BY p.sub_study_area_id \n\t\t\tUNION ALL \n\t\t\tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t \t),\n\t \tscenario_population AS \n\t \t(\n\t\t \tSELECT p.sub_study_area_id, sum(population) population \n\t\t \tFROM prepared_scenario p \n\t\t \tGROUP BY p.sub_study_area_id\n\t\t) \n\t\tSELECT s.id AS sub_study_area_id, s.name, (s.population + COALESCE(sp.population, 0)) AS population \n\t\tFROM basic.sub_study_area s\n\t\tLEFT JOIN scenario_population sp \n\t\tON s.id = sp.sub_study_area_id\n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)); \t\n\n\tELSE \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input \n\t)\n\tSELECT g.id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population, g.sub_study_area_id \n\tFROM to_group g\n\tGROUP BY g.id, g.sub_study_area_id; \n\t\n\t/*Combine and return results*/\n\tRETURN query \n\tWITH combined AS \n\t(\n\t\tSELECT r.id AS isochrone_feature_id, a.sub_study_area_id, a.name, \n\t\tCASE WHEN COALESCE(r.population, 0) > a.population THEN a.population \n\t\tELSE COALESCE(r.population, 0) END AS reached_population, a.population AS total_population \n\t\tFROM reachable_population a\n\t\tLEFT JOIN reached_population r \n\t\tON a.sub_study_area_id = r.sub_study_area_id \n\t),\n\tas_object AS \n\t(\n\t\tSELECT c.isochrone_feature_id, jsonb_object_agg(c.sub_study_area_id, \n\t\tjsonb_build_object('name', c.name, 'reached_population', c.reached_population, 'total_population', c.total_population)) AS population \n\t\tFROM combined c\n\t\tGROUP BY c.isochrone_feature_id \n\t)\n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = o.population \n\tFROM as_object o \n\tWHERE o.isochrone_feature_id = i.id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n \nEND; \n$function$;\n\n/*\nSELECT * \nFROM basic.reached_population_study_area(39, 2,'default', ARRAY[17,24,26])\n*/"
    )
    op.drop_entity(basic_reached_population_study_area)

    basic_heatmap_population = PGFunction(
        schema="basic",
        signature="heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population float, percentile_population integer, modus text, geom geometry)\nLANGUAGE plpgsql\nAS $function$\nBEGIN \n\t\n\tIF modus_input IN ('default', 'comparison') THEN \n\t\tDROP TABLE IF EXISTS population_default;\n\t\tCREATE TEMP TABLE population_default AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'default', scenario_id_input);\n\tEND IF; \n\tIF modus_input IN ('scenario','comparison') THEN \n\t\tDROP TABLE IF EXISTS population_scenario;\n\t\tCREATE TEMP TABLE population_scenario AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'scenario', scenario_id_input);\n\tEND IF;\n\tIF modus_input IN ('comparison') THEN \n\t\tALTER TABLE population_default ADD PRIMARY KEY(grid_visualization_id); \n\t\tALTER TABLE population_scenario ADD PRIMARY KEY(grid_visualization_id); \n\t\tDROP TABLE IF EXISTS population_comparison;\n\t\t\n\t\tCREATE TEMP TABLE population_comparison AS \n\t\tWITH pop_difference AS \n\t\t(\n\t\t\tSELECT d.grid_visualization_id, (COALESCE(s.population,0) - COALESCE(d.population,0)) AS population, d.geom\n\t\t\tFROM population_default d, population_scenario s\n\t\t\tWHERE d.grid_visualization_id = s.grid_visualization_id\n\t\t) \n\t\tSELECT p.grid_visualization_id, p.population, \n\t\tCASE \n\t\tWHEN p.population = 0 THEN 0\n\t\tWHEN p.population < -400 THEN -5 \n\t\tWHEN p.population BETWEEN -400 AND -200 THEN -4 \n\t\tWHEN p.population BETWEEN -200 AND -80 THEN -3 \n\t\tWHEN p.population BETWEEN -80 AND -20 THEN -2 \n\t\tWHEN p.population BETWEEN -20 AND -1 THEN -1 \n\t\tWHEN p.population BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN p.population BETWEEN 20 AND 80 THEN 2\n\t\tWHEN p.population BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN p.population BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN p.population  > 400 THEN 5 END AS percentile_population, p.geom \n\t\tFROM pop_difference p;\n\tEND IF; \n\t\t\n\tIF modus_input = 'default' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_default p;\n\tELSEIF modus_input = 'scenario' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_scenario p;\n\tELSEIF modus_input = 'comparison' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_comparison p;\n\tEND IF; \n\nEND\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_pop;\nCREATE TABLE default_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'default',0)\n\nDROP TABLE IF EXISTS scenario_pop;\nCREATE TABLE scenario_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'scenario',13)\n\nDROP TABLE IF EXISTS comparison_pop;\nCREATE TABLE comparison_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'comparison',13)\n*/"
    )
    op.drop_entity(basic_heatmap_population)

    basic_starting_points_multi_isochrones = PGFunction(
        schema="basic",
        signature="starting_points_multi_isochrones(modus text, minutes integer, speed_input numeric, amenities text[], scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[], region TEXT DEFAULT NULL, study_area_ids integer[] DEFAULT NULL)",
        definition="returns TABLE (x float[], y float[])\nAS $function$\n\nDECLARE \n\texcluded_pois_id text[] := ARRAY[]::text[];\n\tregion_geom geometry;  \n\tbuffer_geom geometry; \nBEGIN \n\n\tIF region IS NULL AND study_area_ids IS NOT NULL THEN\n        SELECT ST_UNION(s.geom)   \n        INTO region_geom\n        FROM basic.sub_study_area s\n        WHERE s.id IN (SELECT UNNEST(study_area_ids));\n    ELSEIF region IS NOT NULL AND study_area_ids IS NULL THEN\n        SELECT ST_GeomFromText(region) AS geom  \n        INTO region_geom;\n    ELSE \n        RAISE EXCEPTION 'Please specify either region or study_area_ids but not both.';\n    END IF;\n\t\n   \tbuffer_geom = ST_Buffer(region_geom::geography, speed_input  * 60 * minutes)::geometry;\n   \n\tIF modus = 'scenario' THEN\n        excluded_pois_id = basic.modified_pois(scenario_id_input);\n    END IF;\n\t\n\n   \tRETURN QUERY \n   \tWITH relevant_pois AS \n   \t(\n\t\tSELECT ST_X(p.geom) x, ST_Y(p.geom) y\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT ST_X(p.geom) x, ST_Y(p.geom) y \n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT ST_X(p.geom) x, ST_Y(p.geom) y\n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(buffer_geom, p.geom)\n\t\tAND p.category IN (SELECT UNNEST(amenities))\n\t\tAND p.scenario_id = scenario_id_input\n\t)\n\tSELECT ARRAY_AGG(r.x) AS x, ARRAY_AGG(r.y) AS y \n\tFROM relevant_pois r;\n\t\nEND; \n$function$\nLANGUAGE plpgsql;\n\n/*\nSELECT * \nFROM basic.starting_points_multi_isochrones('default', 10, 1.33, ARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 0, ARRAY[0], NULL, ARRAY[1,2,3,4])\n */"
    )
    op.drop_entity(basic_starting_points_multi_isochrones)

    basic_heatmap_local_accessibility = PGFunction(
        schema="basic",
        signature="heatmap_local_accessibility(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition='returns TABLE(grid_visualization_id bigint, percentile_accessibility integer, accessibility_index bigint, modus text, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tborders_quintiles bigint[]; \nBEGIN\n\t\n\tDROP TABLE IF EXISTS heatmap_default; \n\tCREATE TEMP TABLE heatmap_default AS\n\tWITH grouped AS \n\t(\n\t\tSELECT h.grid_visualization_id, sum(h.accessibility_index) AS accessibility_index \n\t\tFROM basic.prepare_heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'default\', scenario_id_input, data_upload_ids) h\n\t\tGROUP BY h.grid_visualization_id \t\n\t)\n\tSELECT g.id AS grid_visualization_id, \n\tCOALESCE(h.percentile_accessibility,0) AS percentile_accessibility, COALESCE(h.accessibility_index, 0)::bigint AS accessibility_index, \'default\' AS modus, g.geom  \n\tFROM basic.grid_visualization g\n\tLEFT JOIN (\n\t\tSELECT h.grid_visualization_id, ntile(5) over (order by h.accessibility_index) AS percentile_accessibility, h.accessibility_index \n\t\tFROM grouped h\n\t\tWHERE h.accessibility_index IS NOT NULL \n\t) h\n\tON g.id = h.grid_visualization_id;\t\n\t\n\tIF modus_input IN (\'scenario\',\'comparison\') THEN  \n\t\tSELECT array_agg(border)\n\t\tINTO borders_quintiles\n\t\tFROM \n\t\t(\n\t\t\tSELECT min(h.accessibility_index) border\n\t\t\tFROM heatmap_default h\n\t\t\tWHERE h.accessibility_index <> 0\n\t\t\tGROUP BY h.percentile_accessibility \n\t\t\tORDER BY h.percentile_accessibility\n\t\t) b;\n\t\t\n\t\tDROP TABLE IF EXISTS heatmap_scenario;\n\t\tCREATE TEMP TABLE heatmap_scenario AS \n\t\tWITH grouped AS \n\t\t(\n\t\t\tSELECT h.grid_visualization_id, sum(h.accessibility_index) AS accessibility_index \n\t\t\tFROM basic.prepare_heatmap_local_accessibility(amenities_json, user_id_input, active_study_area_id, \'scenario\', scenario_id_input, data_upload_ids) h\n\t\t\tGROUP BY h.grid_visualization_id \t\n\t\t),\n\t\twith_geom AS\n\t\t(\n\t\t\tSELECT g.id AS grid_visualization_id, COALESCE(h.accessibility_index, 0) AS accessibility_index, \'scenario\' AS modus, g.geom  \n\t\t\tFROM basic.grid_visualization g\n\t\t\tLEFT JOIN grouped h \n\t\t\tON g.id = h.grid_visualization_id\n\t\t)\t\t\n\t\tSELECT h.grid_visualization_id, \n\t\tCASE WHEN h.accessibility_index = 0 THEN 0\n\t\tWHEN h.accessibility_index > 0 AND h.accessibility_index < borders_quintiles[2] THEN 1\n\t\tWHEN h.accessibility_index >= borders_quintiles[2] AND h.accessibility_index < borders_quintiles[3] THEN 2\n\t\tWHEN h.accessibility_index >= borders_quintiles[3] AND h.accessibility_index < borders_quintiles[4] THEN 3\n\t\tWHEN h.accessibility_index >= borders_quintiles[4] AND h.accessibility_index < borders_quintiles[5] THEN 4\n\t\tWHEN h.accessibility_index >= borders_quintiles[5] THEN 5\n\t\tEND AS percentile_accessibility, h.accessibility_index::bigint, h.modus, h.geom  \n\t\tFROM with_geom h; \n\t\n\tEND IF; \n\t\n\tIF modus_input = \'comparison\' THEN \n\n\t\tALTER TABLE heatmap_default ADD PRIMARY KEY(grid_visualization_id);\n\t\tALTER TABLE heatmap_scenario ADD PRIMARY KEY(grid_visualization_id);\n\t\t\n\t\tDROP TABLE IF EXISTS heatmap_comparison;\n\t\tCREATE TEMP TABLE heatmap_comparison AS \n\t\tWITH with_geom AS  \n\t\t(\n\t\t\tSELECT d.grid_visualization_id, (s.percentile_accessibility - d.percentile_accessibility ) AS percentile_accessibility, \n\t\t\tCOALESCE(s.accessibility_index - d.accessibility_index,0) AS accessibility_index, \'comparison\' AS modus, d.geom\n\t\t\tFROM heatmap_default d, heatmap_scenario s \n\t\t\tWHERE d.grid_visualization_id = s.grid_visualization_id\n\t\t) \n\t\tSELECT h.grid_visualization_id, ntile(10) over (order by h.accessibility_index) AS percentile_accessibility, h.accessibility_index, h.modus, h.geom  \n\t\tFROM with_geom h\n\t\tWHERE h.accessibility_index <> 0\n\t\tUNION ALL \n\t\tSELECT h.grid_visualization_id, 0, h.accessibility_index, h.modus, h.geom   \n\t\tFROM with_geom h\n\t\tWHERE h.accessibility_index = 0; \n\t\t\n\tEND IF;\n\n\tIF modus_input = \'default\' THEN \n\t\tRETURN query \n\t\tSELECT * \n\t\tFROM heatmap_default;\n\tELSEIF modus_input = \'scenario\' THEN \n\t\tRETURN query \n\t\tSELECT * \n\t\tFROM heatmap_scenario;\n\tELSEIF modus_input = \'comparison\' THEN \n\t\tRETURN query \n\t\tSELECT * \n\t\tFROM heatmap_comparison;\n\tEND IF; \nEND\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_table; \nCREATE TABLE default_table AS \nSELECT * \nFROM basic.heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'default\',11, \'{}\'::integer[]) h;\n\nDROP TABLE IF EXISTS scenario_table; \nCREATE TABLE scenario_table AS \nSELECT * \nFROM basic.heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'scenario\',11, \'{}\'::integer[]) h;\n\nDROP TABLE IF EXISTS comparison_table; \nCREATE TABLE comparison_table AS \nSELECT * \nFROM basic.heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'comparison\',11, \'{}\'::integer[]) h;\n*/'
    )
    op.drop_entity(basic_heatmap_local_accessibility)

    basic_create_perpendicular_line = PGFunction(
        schema="basic",
        signature="create_perpendicular_line(line_geom geometry, point_geom geometry, length_line float)",
        definition='returns SETOF geometry AS\n$func$\n\n\tSELECT ST_SETSRID(\n\t\t\tST_MAKELINE(\n\t\t\t\tST_MAKEPOINT(x2+length_line,y2+(-1/((y2-y1)/(x2-x1)))*length_line), \n\t\t\t\tST_MAKEPOINT(x2-length_line,y2-(-1/((y2-y1)/(x2-x1)))*length_line)\n\t\t\t),4326)\n\tFROM (\n\t\tSELECT ST_X(st_startpoint(line_geom)) x1, ST_Y(st_startpoint(line_geom)) y1, ST_X(point_geom) x2, ST_Y(point_geom) y2 \n\t) x_y\n$func$  LANGUAGE sql IMMUTABLE'
    )
    op.drop_entity(basic_create_perpendicular_line)

    basic_modified_buildings = PGFunction(
        schema="basic",
        signature="modified_buildings(scenario_id_input integer)",
        definition="returns INTEGER[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_features integer[];\nBEGIN \n\n\tmodified_features = \n\t(\n\t\tWITH ids AS \n\t\t(\n\t\t\tSELECT DISTINCT building_id \n\t\t\tFROM customer.building_modified   \n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND building_id IS NOT NULL \n\t\t\tAND edit_type IN ('d')\n\t\t)\n\t\tSELECT COALESCE(ARRAY_AGG(building_id), array[]::integer[]) \n\t\tFROM ids\n\t);\n\t\n\tRETURN modified_features;\n\t\nEND;\n$function$\n/*\nSELECT * FROM basic.modified_buildings(1)\n*/"
    )
    op.drop_entity(basic_modified_buildings)

    basic_create_snapped_split_line = PGFunction(
        schema="basic",
        signature="create_snapped_split_line(geom geometry, extend_distance NUMERIC, point_to_extend text)",
        definition="returns geometry \nLANGUAGE plpgsql\nAS $function$\nDECLARE\n\tstart_geom geometry; \n\tend_geom geometry;\n\tazimuth_A float;\n\tazimuth_B float;\n\tlength_A NUMERIC;\n\tlength_B NUMERIC;\n\tnewpoint_A geometry;\n\tnewpoint_B geometry;\n\tnew_line geometry; \nBEGIN \n\t\t\n\t-- get the points A and B given a line L\n\tstart_geom = ST_STARTPOINT(geom);\n\tend_geom = ST_ENDPOINT(geom);\n\t\t\n\t-- Start line section\n\tazimuth_A = ST_AZIMUTH(ST_POINTN(geom,2),start_geom);\n\n\t-- End line section \n\tazimuth_B = ST_AZIMUTH(ST_POINTN(geom,-2),end_geom);\n\t\n\t-- get the length of the line A --> B\n\tlength_A = ST_DISTANCE(ST_STARTPOINT(geom),ST_POINTN(geom,2));\n\tlength_B = ST_DISTANCE(ST_ENDPOINT(geom),ST_POINTN(geom,-2));\n\t\n\tnewpoint_A = ST_TRANSLATE(start_geom, sin(azimuth_A) * extend_distance, cos(azimuth_A) * extend_distance);\n\tnewpoint_B = ST_TRANSLATE(end_geom, sin(azimuth_B) * extend_distance, cos(azimuth_B) * extend_distance);\n\t\n\tIF point_to_extend = 'start' THEN\n\t\tnew_line = ST_MAKELINE(start_geom,newpoint_A);\n\tELSEIF point_to_extend = 'end' THEN \n\t\tnew_line = ST_MAKELINE(end_geom,newpoint_B);\n\tELSE\n\t\tRAISE EXCEPTION 'Please specify a valid point_to_extend type.';\n\tEND IF; \n\n\tRETURN new_line;\nEND\n$function$\n/*point_to_extend = 'start', 'end'*/\n--1 meter in Germany approx. 0.0000127048\n/*\nSELECT basic.create_snapped_split_line(geom, 0.0000127048, 'start') \nFROM customer.way_modified WHERE id = 112;\n*/"
    )
    op.drop_entity(basic_create_snapped_split_line)

    basic_modified_pois = PGFunction(
        schema="basic",
        signature="modified_pois(scenario_id_input integer)",
        definition="returns TEXT[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_features text[];\nBEGIN \n\n\tmodified_features = \n\t(\n\t\tWITH ids AS \n\t\t(\n\t\t\tSELECT uid \n\t\t\tFROM customer.poi_modified p \t\n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND edit_type IN ('d', 'm')\n\t\t)\n\t\tSELECT COALESCE(ARRAY_AGG(uid), array[]::text[]) \n\t\tFROM ids\n\t);\n\t\n\tRETURN modified_features;\n\t\nEND;\n$function$\n/*\nSELECT * FROM basic.modified_pois(75)\n*/"
    )
    op.drop_entity(basic_modified_pois)

    basic_create_intersection_line = PGFunction(
        schema="basic",
        signature="create_intersection_line(point_geom geometry, length_line double precision)",
        definition='returns SETOF geometry\n LANGUAGE sql\n IMMUTABLE\nAS $function$\n\tSELECT ST_SETSRID(ST_MAKELINE(\n\t\tST_Translate(point_geom, length_line, length_line),\n\t\tST_Translate(point_geom, -length_line, -length_line)\n\t), 4326)\n$function$'
    )
    op.drop_entity(basic_create_intersection_line)

    basic_select_user_customization = PGFunction(
        schema="basic",
        signature="select_user_customization(user_id_input integer, setting_type text)",
        definition="returns jsonb\n LANGUAGE sql\nAS $function$\n\n\tSELECT u.setting -> c.type\n\tFROM customer.customization c, customer.user_customization u \n\tWHERE c.type = setting_type \n\tAND u.customization_id = c.id\n\tAND u.user_id = user_id_input;\n\n$function$ IMMUTABLE;\n/*\nSELECT select_user_customization(1, 'poi_groups');\n*/"
    )
    op.drop_entity(basic_select_user_customization)

    basic_poi_categories = PGFunction(
        schema="basic",
        signature="poi_categories(user_id_input integer)",
        definition="returns jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tdefault_setting jsonb := basic.select_customization('poi_groups');\n\tuser_setting jsonb := basic.select_user_customization(user_id_input, 'poi_groups');\n\tclassified_pois jsonb; \nBEGIN \n\t\n\tDROP TABLE IF EXISTS poi_groups_default; \n\tCREATE TEMP TABLE poi_groups_default AS \n\tWITH poi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(default_setting) poi_group\n\t)\n\tSELECT jsonb_array_elements(p.poi_group -> jsonb_object_keys(p.poi_group) -> 'children') AS poi_category \n\tFROM poi_groups p;\n\n\tDROP TABLE IF EXISTS poi_groups_user; \n\tCREATE TEMP TABLE poi_groups_user AS \n\tWITH poi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(user_setting) poi_group\n\t)\n\tSELECT jsonb_array_elements(p.poi_group -> jsonb_object_keys(p.poi_group) -> 'children') AS poi_category \n\tFROM poi_groups p; \n\t\n\tclassified_pois = (\n\t\tWITH poi_categories AS \n\t\t(\t\n\t\t\tSELECT jsonb_object_keys(p.poi_category) AS poi_category, (p.poi_category -> jsonb_object_keys(p.poi_category) -> 'multiple_entrance') AS multiple_entrance \n\t\t\tFROM poi_groups_default p\n\t\t\tUNION ALL \n\t\t\tSELECT jsonb_object_keys(p.poi_category) AS poi_category, (p.poi_category -> jsonb_object_keys(p.poi_category) -> 'multiple_entrance') AS multiple_entrance \n\t\t\tFROM poi_groups_user p\n\t\t),\n\t\t\n\t\tpoi_classified AS \n\t\t(\n\t\t\tSELECT COALESCE(multiple_entrance::BOOLEAN, FALSE) multiple_entrance, array_agg(poi_category) arr_pois \n\t\t\tFROM (SELECT DISTINCT * FROM poi_categories) p \n\t\t\tGROUP BY multiple_entrance\n\t\t) \n\t\tSELECT jsonb_object_agg(multiple_entrance, arr_pois)\n\t\tFROM poi_classified\n\t); \n\tRETURN classified_pois; \nEND ;\n$function$\n\n\n/* Function that returns the default and user poi categories grouped into multiple_entrance and single_entrance\\:\nSELECT basic.poi_categories(1) \n*/"
    )
    op.drop_entity(basic_poi_categories)

    basic_modified_edges = PGFunction(
        schema="basic",
        signature="modified_edges(scenario_id_input integer)",
        definition="returns INTEGER[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_features integer[];\nBEGIN \n\n\tmodified_features = \n\t(\n\t\tWITH ids AS \n\t\t(\n\t\t\tSELECT DISTINCT way_id \n\t\t\tFROM customer.way_modified  \n\t\t\tWHERE scenario_id = scenario_id_input \n\t\t\tAND way_id IS NOT NULL \n\t\t\tAND edit_type IN ('d', 'm')\n\t\t)\n\t\tSELECT COALESCE(ARRAY_AGG(way_id), array[]::integer[]) \n\t\tFROM ids\n\t);\n\t\n\tRETURN modified_features;\n\t\nEND;\n$function$\n/*\nSELECT * FROM basic.modified_edges(1)\n*/"
    )
    op.drop_entity(basic_modified_edges)

    basic_extend_line = PGFunction(
        schema="basic",
        signature="extend_line(geom geometry, extend_distance NUMERIC, point_to_extend text)",
        definition="returns geometry \nLANGUAGE plpgsql\nAS $function$\nDECLARE\n\tstart_geom geometry; \n\tend_geom geometry;\n\tazimuth_A float;\n\tazimuth_B float;\n\tlength_A NUMERIC;\n\tlength_B NUMERIC;\n\tnewpoint_A geometry;\n\tnewpoint_B geometry;\n\tnew_line geometry; \nBEGIN \n\t\t\n\t-- get the points A and B given a line L\n\tstart_geom = ST_STARTPOINT(geom);\n\tend_geom = ST_ENDPOINT(geom);\n\t\t\n\t-- Start line section\n\tazimuth_A = ST_AZIMUTH(ST_POINTN(geom,2),start_geom);\n\n\t-- End line section \n\tazimuth_B = ST_AZIMUTH(ST_POINTN(geom,-2),end_geom);\n\t\n\t-- get the length of the line A --> B\n\tlength_A = ST_DISTANCE(ST_STARTPOINT(geom),ST_POINTN(geom,2));\n\tlength_B = ST_DISTANCE(ST_ENDPOINT(geom),ST_POINTN(geom,-2));\n\t\n\tnewpoint_A = ST_TRANSLATE(start_geom, sin(azimuth_A) * extend_distance, cos(azimuth_A) * extend_distance);\n\tnewpoint_B = ST_TRANSLATE(end_geom, sin(azimuth_B) * extend_distance, cos(azimuth_B) * extend_distance);\n\t\n\tIF point_to_extend = 'start' THEN\n\t\tnew_line = st_addpoint(geom,newpoint_a, 0);\n\tELSEIF point_to_extend = 'end' THEN \n\t\tnew_line = st_addpoint(geom,newpoint_b, -1);\n\tELSEIF point_to_extend = 'both' THEN \n\t\tnew_line = st_addpoint(st_addpoint(geom,newpoint_B),newpoint_A,0);\n\tELSE \n\t\tRAISE EXCEPTION 'Please specify a valid point_to_extend type.';\n\tEND IF; \n\n\tRETURN new_line;\nEND\n$function$\n/*point_to_extend = 'start', 'end', 'both'*/\n--1 meter in Germany approx. 0.0000127048\n--SELECT basic.extend_line(geom, 0.0127048, 'both') \n--FROM customer.way_modified WHERE id = 112"
    )
    op.drop_entity(basic_extend_line)

    basic_select_customization = PGFunction(
        schema="basic",
        signature="select_customization(setting_type text)",
        definition="returns jsonb\n LANGUAGE sql\nAS $function$\n\n\tSELECT setting -> c.type\n\tFROM customer.customization c \n\tWHERE c.type = setting_type;\n\n$function$ IMMUTABLE;\n/*\nSELECT basic.select_customization('categories_no_foot');\n*/"
    )
    op.drop_entity(basic_select_customization)

    basic_fetch_network_routing_multi = PGFunction(
        schema="basic",
        signature="fetch_network_routing_multi(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns SETOF type_fetch_edges_routing\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tunion_buffer_network geometry;\nBEGIN \n\t\n\tPERFORM basic.create_multiple_artificial_edges(x, y, max_cutoff, speed, modus, scenario_id, routing_profile);\n\tunion_buffer_network  = (SELECT ST_UNION(geom) FROM buffer_network);\n\t\n\t/*Fetch Network*/\n\tRETURN query EXECUTE \n\t'SELECT 1, 1, 1, 1, 1, 1, NULL, ''[[1.1,1.1],[1.1,1.1]]''::json, $1, $2\n\t UNION ALL ' || \n\tbasic.query_edges_routing(ST_ASTEXT(union_buffer_network),modus,scenario_id,speed,routing_profile,True) || \n    ' AND id NOT IN (SELECT wid FROM artificial_edges)\n\tUNION ALL \n\tSELECT id, source, target, ST_LENGTH(ST_TRANSFORM(geom, 3857)) AS length_3857, cost, reverse_cost, NULL AS death_end, ST_AsGeoJSON(ST_Transform(geom,3857))::json->''coordinates'', NULL AS starting_ids, NULL AS starting_geoms\n\tFROM artificial_edges' USING (SELECT array_agg(s.id) FROM starting_vertices s), (SELECT array_agg(ST_ASTEXT(s.geom)) FROM starting_vertices s); \n\nEND;\n$function$;\n\n/*\nWITH p AS \n(\n\tSELECT geom\n\tFROM basic.poi \n\tLIMIT 100\n),\nagg AS \n(\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p  \n)\nSELECT n.* \nFROM agg, \nLATERAL basic.fetch_network_routing_multi(x,y, 1200., 1.33, 'default', 1, 'walking_standard') n \n*/"
    )
    op.drop_entity(basic_fetch_network_routing_multi)

    basic_create_multiple_artificial_edges = PGFunction(
        schema="basic",
        signature="create_multiple_artificial_edges(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns VOID \n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tbuffer_starting_point geometry; \n\tunion_buffer_network geometry;\n\tpoint geometry; \n\tsnap_distance_network integer := basic.select_customization('snap_distance_network')::integer;\n\tcnt_starting_points integer := 0;\n\tlength_starting_points integer := array_length(x, 1);\n\tmax_new_node_id integer := 2147483647;\n\tmax_new_edge_id integer := 2147483647;\nBEGIN \n\t\n\t/*Prepare temporary tables*/\n\tDROP TABLE IF EXISTS artificial_edges; \n\tCREATE TEMP TABLE artificial_edges (\n\t\twid integer, \n\t\tid integer, \n\t\tCOST float, \n\t\treverse_cost float, \n\t\tlength_m float, \n\t\tSOURCE integer, \n\t\ttarget integer, \n\t\tfraction float, \n\t\tgeom geometry, \n\t\tvid integer, \n\t\tpoint_geom geometry\n\t); \n\n\tDROP TABLE IF EXISTS duplicated_artificial_edges; \n\tCREATE TEMP TABLE duplicated_artificial_edges (LIKE artificial_edges); \n\n\tDROP TABLE IF EXISTS buffer_network; \n\tCREATE TEMP TABLE buffer_network (id serial, geom geometry);\n\t\n\t/*Loop through starting points*/\n\tWHILE cnt_starting_points < length_starting_points \n\tLOOP\n\t\tcnt_starting_points = cnt_starting_points + 1;\n\t\tpoint = ST_SETSRID(ST_POINT(x[cnt_starting_points],y[cnt_starting_points]), 4326);\n\t\t\n\t\tSELECT ST_SETSRID(ST_Buffer(point::geography,snap_distance_network)::geometry, 4326)\n\t\tINTO buffer_starting_point;\t\n\t\t\n\t\tINSERT INTO artificial_edges\n\t\tSELECT c.*, max_new_node_id, point AS point_geom  \n\t\tFROM basic.create_artificial_edges(basic.query_edges_routing(ST_ASTEXT(buffer_starting_point),modus,scenario_id,speed,routing_profile,FALSE),\n\t\t\tpoint, snap_distance_network, max_new_node_id, max_new_edge_id  \n\t\t) c; \n\n\t\tINSERT INTO buffer_network(geom) \n\t\tSELECT ST_Buffer(point::geography,max_cutoff * speed)::geometry;\n\t\t\n\t\tmax_new_node_id = max_new_node_id - 1;\n\t\tmax_new_edge_id = max_new_edge_id - 2; \n\tEND LOOP; \n\t\n\tunion_buffer_network  = (SELECT ST_UNION(b.geom) FROM buffer_network b);\n\t\n\tDROP TABLE IF EXISTS starting_vertices; \n\tCREATE TEMP TABLE starting_vertices (id integer, geom geometry);\n\n\t/*Identify duplicates and unique artificial edges */\n\tDROP TABLE IF EXISTS final_artificial_edges; \n\tCREATE TEMP TABLE final_artificial_edges AS \n\tWITH cnt_artificial_edges AS \n\t(\n\t\tSELECT a.wid, count(*)::integer AS cnt \n\t\tFROM artificial_edges a  \n\t\tGROUP BY a.wid\n\t),\t\n\tnot_duplicates AS \n\t(\n\t\tSELECT a.wid, a.vid, a.id, a.COST, a.reverse_cost, a.length_m, a.SOURCE, a.target, a.geom, a.point_geom  \n\t\tFROM artificial_edges a, cnt_artificial_edges c\n\t\tWHERE a.wid = c.wid \n\t\tAND c.cnt <= 2\n\t),\n\tinsert_not_duplicates AS \n\t(\n\t\tINSERT INTO starting_vertices \n\t\tSELECT DISTINCT vid, point_geom \n\t\tFROM not_duplicates \t\n\t),\n\tinsert_duplicates AS \n\t(\n\t\tINSERT INTO duplicated_artificial_edges\n\t\tSELECT a.* \n\t\tFROM artificial_edges a, cnt_artificial_edges c\n\t\tWHERE a.wid = c.wid \n\t\tAND c.cnt > 2 \n\t)\n\tSELECT n.wid, n.id, n.COST, n.reverse_cost, n.length_m, n.SOURCE, n.target, n.geom, n.point_geom  \n\tFROM not_duplicates n; \n\t\n\t/*Handle duplicated artificial edges*/\n\tDROP TABLE IF EXISTS cleaned_duplicates; \n\tCREATE TEMP TABLE cleaned_duplicates AS \n\tWITH sum_costs AS \n\t(\n\t\tSELECT d.vid, round(SUM(d.COST::numeric), 4) AS cost, round(SUM(d.reverse_cost::numeric), 4) AS reverse_cost\n\t\tFROM duplicated_artificial_edges d \n\t\tGROUP BY d.vid\n\t),\n\tordered AS \n\t(\n\t\tSELECT DISTINCT d.wid, d.vid, d.fraction, s.COST, s.reverse_cost, d.point_geom  \n\t\tFROM duplicated_artificial_edges d, sum_costs s  \n\t\tWHERE d.vid = s.vid \n\t\tAND d.fraction NOT IN (0,1)\n\t\tORDER BY d.wid, d.fraction \n\t),\n\tinsert_distinct_starting_points AS \n\t(\n\t\tINSERT INTO starting_vertices \n\t\tSELECT o.vid, point_geom  \n\t\tFROM ordered o\n\t),\n\tgrouped AS \n\t(\t\n\t\tSELECT g.wid, array_agg(g.vid) vids, array_agg(g.fraction) fractions\n\t\tFROM ordered g  \n\t\tGROUP BY g.wid\n\t),\n\tdistinct_costs AS \n\t(\n\t\tSELECT DISTINCT o.wid, o.COST, o.reverse_cost\n\t\tFROM ordered o\n\t),\n\tdistinct_duplicated_edges AS \n\t(\n\t\tSELECT g.wid, o.COST, o.reverse_cost, g.vids, g.fractions, e.SOURCE, e.target, e.geom\n\t\tFROM grouped g\n\t\tLEFT JOIN distinct_costs o\n\t\tON g.wid = o.wid \n\t\tLEFT JOIN basic.edge e \n\t\tON g.wid = e.id \n\t)\n\tSELECT edge_id AS wid, (max_new_edge_id - ROW_NUMBER() OVER()) AS id, f.COST, f.reverse_cost,\n\tST_LENGTH(f.geom::geography) AS length_m, f.SOURCE, f.target, f.geom, NULL AS point_geom  \n\tFROM distinct_duplicated_edges d, \n\tLATERAL basic.fix_multiple_artificial_edges(d.wid, d.SOURCE, d.target, d.COST, d.reverse_cost, d.geom, d.vids, d.fractions) f; \n\t\n\tUPDATE cleaned_duplicates d\n\tSET point_geom = s.geom \n\tFROM starting_vertices s  \n\tWHERE d.SOURCE = s.id;\n\n\tUPDATE cleaned_duplicates d\n\tSET point_geom = s.geom \n\tFROM starting_vertices s  \n\tWHERE d.target = s.id;\n\n\tINSERT INTO final_artificial_edges \n\tSELECT * FROM cleaned_duplicates; \n\nEND;\n$function$;\n\n/*\nWITH p AS \n(\n\tSELECT ST_CENTROID(geom) AS geom \n\tFROM basic.grid_calculation\n\tLIMIT 10\n),\nagg AS \n(\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p  \n)\nSELECT basic.create_multiple_artificial_edges(x, y, 1200., 1.33, 'default', 1, 'walking_standard') a\nFROM agg \n*/"
    )
    op.drop_entity(basic_create_multiple_artificial_edges)

    basic_fix_multiple_artificial_edges = PGFunction(
        schema="basic",
        signature="fix_multiple_artificial_edges(wid integer, s integer, t integer, c float, rc float, w_geom geometry, vids integer[],fractions float[])",
        definition='returns TABLE (edge_id integer, COST float, reverse_cost float, SOURCE integer, target integer, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tstart_fraction float := 0;\n\tsource_id integer := s;\n\tend_fraction float;\n\tstart_id integer := s;\n\tcnt integer := 1;\nBEGIN \n\tfractions = array_append(fractions,1::float);\n\tvids = array_append(vids,t);\n\n\tFOREACH end_fraction IN ARRAY fractions\n\tLOOP \n\t\tRETURN query\n\t\tWITH parts AS \n\t\t(\n\t\t\tSELECT wid, c*(end_fraction-start_fraction) AS cost,rc*(end_fraction-start_fraction) AS reverse_cost, \n\t\t\tsource_id AS source, vids[cnt] AS target, ST_LINESUBSTRING(w_geom,start_fraction,end_fraction) AS geom\n\t\t)\n\t\tSELECT p.wid, p.cost, p.reverse_cost, p.source, p.target, p.geom\n\t\tFROM parts p\n\t\tWHERE p.cost <> 0;  \n\n\t\tstart_fraction = end_fraction;\n\t\tsource_id = vids[cnt];\n\t\tedge_id = edge_id - 1;\n\t\tcnt = cnt + 1;\n\tEND LOOP;\n\tRETURN; \nEND \n$function$'
    )
    op.drop_entity(basic_fix_multiple_artificial_edges)

    basic_fetch_network_routing_heatmap = PGFunction(
        schema="basic",
        signature="fetch_network_routing_heatmap(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns SETOF type_fetch_edges_routing\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tunion_buffer_network geometry;\n\tcnt_starting_points integer := 0;\n\tlength_starting_points integer := array_length(x, 1);\n\tpoint geometry;\nBEGIN \n\t\n\tPERFORM basic.create_multiple_artificial_edges(x, y, max_cutoff, speed, modus, scenario_id, routing_profile);\n\t\n\tDROP TABLE IF EXISTS buffer_network; \n\tCREATE TEMP TABLE buffer_network (id serial, geom geometry);\n\t\n\tDROP TABLE IF EXISTS buffer_starting_points;\n\tCREATE TEMP TABLE buffer_starting_points(geom geometry);\n\n\t/*Loop through starting points*/\n\tWHILE cnt_starting_points < length_starting_points \n\tLOOP\n\t\tcnt_starting_points = cnt_starting_points + 1;\n\t\tpoint = ST_SETSRID(ST_POINT(x[cnt_starting_points],y[cnt_starting_points]), 4326);\n\t\t\n\t\tINSERT INTO buffer_network(geom) \n\t\tSELECT ST_Buffer(point::geography,max_cutoff * speed)::geometry;\n\t\t\n\t\tINSERT INTO buffer_starting_points(geom)\n\t\tSELECT ST_BUFFER(point, 0.000000001); \n\tEND LOOP; \n\t\n\tCREATE INDEX ON buffer_starting_points USING GIST(geom); \n\n\tunion_buffer_network  = (SELECT ST_UNION(b.geom) FROM buffer_network b);\n\t\n\tDROP TABLE IF EXISTS batch_artificial_edges; \n\tCREATE TEMP TABLE batch_artificial_edges AS\n\tSELECT *\n\tFROM temporal.heatmap_edges_artificial a\n\tWHERE ST_Intersects(a.geom, union_buffer_network); \n\t\n\tDROP TABLE IF EXISTS batch_starting_vertices; \n\tCREATE TEMP TABLE batch_starting_vertices AS\n\tSELECT v.*\n\tFROM temporal.heatmap_starting_vertices v, buffer_starting_points s  \n\tWHERE ST_Intersects(v.geom, s.geom); \n\n\t/*Fetch Network*/\n\tRETURN query EXECUTE \n\t'SELECT 1, 1, 1, 1, 1, 1, NULL, ''[[1.1,1.1],[1.1,1.1]]''::json, $1, $2\n\t UNION ALL ' || \n\tbasic.query_edges_routing(ST_ASTEXT(union_buffer_network),modus,scenario_id,speed,routing_profile,True) || \n    ' AND id NOT IN (SELECT wid FROM batch_artificial_edges)\n\tUNION ALL \n\tSELECT id, source, target, ST_LENGTH(ST_TRANSFORM(geom, 3857)) AS length_3857, cost, reverse_cost, \n\tNULL AS death_end, ST_AsGeoJSON(ST_Transform(geom,3857))::json->''coordinates'', NULL AS starting_ids, NULL AS starting_geoms\n\tFROM batch_artificial_edges' USING (SELECT array_agg(s.id) FROM batch_starting_vertices s), (SELECT array_agg(ST_ASTEXT(s.geom)) FROM batch_starting_vertices s); \n\nEND;\n$function$;\n\n/*\nWITH p AS \n(\n\tSELECT ST_CENTROID(geom) geom \n\tFROM temporal.heatmap_grid_helper h \n\tWHERE cid = 0\n),\nagg AS \n(\n\tSELECT array_agg(ST_X(geom)) AS x, array_agg(ST_Y(geom)) AS y\n\tFROM p  \n)\nSELECT n.* \nFROM agg, \nLATERAL basic.fetch_network_routing_heatmap(x,y, 1200., 1.33, 'default', 1, 'walking_standard') n\n*/"
    )
    op.drop_entity(basic_fetch_network_routing_heatmap)

    basic_fetch_network_routing = PGFunction(
        schema="basic",
        signature="fetch_network_routing(x float[], y float[], max_cutoff float, speed float, modus text, scenario_id integer, routing_profile text)",
        definition="returns SETOF type_fetch_edges_routing\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tbuffer_starting_point geometry; \n\tbuffer_network geometry;\n\tpoint geometry := ST_SETSRID(ST_POINT(x[1],y[1]), 4326);\n\tsnap_distance_network integer := basic.select_customization('snap_distance_network')::integer;\n\tmax_new_node_id integer := 2147483647;\n\tmax_new_edge_id integer := 2147483647;\nBEGIN \n\n\tSELECT ST_Buffer(point::geography,snap_distance_network)::geometry\n\tINTO buffer_starting_point;\n\n\tSELECT ST_Buffer(point::geography,max_cutoff * speed)::geometry\n\tINTO buffer_network;\n\n\tDROP TABLE IF EXISTS artificial_edges;\n\tCREATE TEMP TABLE artificial_edges AS   \n\tSELECT * \n\tFROM basic.create_artificial_edges(basic.query_edges_routing(ST_ASTEXT(buffer_starting_point),modus,scenario_id,speed,routing_profile,FALSE),point, \n\t\tsnap_distance_network,max_new_node_id, max_new_edge_id \n\t); \n\t\t\n\tRETURN query EXECUTE \n\t'SELECT 0, 0, 0, 0, 0, 0, NULL,''[[1.1,1.1],[1.1,1.1]]''::json, $1, $2\n\t UNION ALL ' || \n\tbasic.query_edges_routing(ST_ASTEXT(buffer_network),modus,scenario_id,speed,routing_profile,True) || \n    ' AND id NOT IN (SELECT wid FROM artificial_edges)\n\tUNION ALL \n\tSELECT id, source, target, ST_LENGTH(ST_TRANSFORM(geom, 3857)) AS length_3857, cost, reverse_cost, NULL AS death_end, ST_AsGeoJSON(ST_Transform(geom,3857))::json->''coordinates'', NULL AS starting_ids, NULL AS starting_geoms\n\tFROM artificial_edges' USING ARRAY[max_new_node_id]::integer[], ARRAY[ST_ASTEXT(point)]::TEXT[];\n\nEND;\n$function$;\n\n/*Fetches the routing network\nSELECT * \nFROM basic.fetch_network_routing(ARRAY[11.543274],ARRAY[48.195524], 1200., 1.33, 'default', 1, 'walking_standard')\n*/"
    )
    op.drop_entity(basic_fetch_network_routing)

    basic_create_artificial_edges = PGFunction(
        schema="basic",
        signature="create_artificial_edges(sql_network TEXT, point geometry, snap_distance integer, new_node_id integer, line_part1_id integer)",
        definition="returns TABLE(wid integer, id integer, COST float, reverse_cost float, length_m float, SOURCE integer, target integer, fraction float, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tsql_start_vertices TEXT; \n\trec record;\n\tline_part1 geometry;\n\tline_part2 geometry;\n\tlength_part1 float;\n\tlength_part2 float;\n\tline_part2_id integer; \n\tbuffer geometry; \n\ttotal_length_m float;\nBEGIN \n\t\n\tbuffer = ST_Buffer(point::geography, snap_distance)::geometry;\n  \tsql_start_vertices = 'SELECT ST_LineLocatePoint(geom,$2) AS fraction, \n\tw.geom AS w_geom, w.SOURCE, w.target, w.COST, w.reverse_cost, $3 AS vid, w.id AS wid\n\tFROM \n\t(\n\t\t%1$s\t\n\t) w\n\tWHERE $1 && geom\n\tORDER BY ST_CLOSESTPOINT(geom,$2) <-> $2\n  \tLIMIT 1;';\n  \t\n  \n\tEXECUTE format(sql_start_vertices, sql_network) USING buffer, point, new_node_id INTO rec;\n\n \ttotal_length_m = ST_LENGTH(rec.w_geom::geography);\n\tline_part1 = ST_LINESUBSTRING(rec.w_geom,0,rec.fraction);\n\tline_part2 = ST_LINESUBSTRING(rec.w_geom,rec.fraction,1);\n\tlength_part1 = ST_Length(line_part1::geography);\n\tlength_part2 = total_length_m - length_part1;\n\tline_part2_id = line_part1_id - 1;\n\n  \tRETURN query \n\tWITH pair_artificial AS (\n\t\tSELECT rec.wid, line_part1_id AS id, \n\t\trec.COST * (length_part1 / total_length_m) AS COST,\n\t\trec.reverse_cost * (length_part1 / total_length_m) AS reverse_cost,\n\t\tlength_part1 AS length_m, rec.SOURCE, rec.vid AS target, rec.fraction AS fraction, line_part1 AS geom\n\t\tUNION ALL\n\t\tSELECT rec.wid, line_part2_id AS id,\n\t\trec.COST * (length_part2 / total_length_m) AS COST,\n\t\trec.reverse_cost * (length_part2 / total_length_m) AS reverse_cost,\n\t\tlength_part2, rec.vid AS SOURCE, rec.target, rec.fraction AS fraction, line_part2 AS geom\n\t)\n\tSELECT p.wid, p.id, p.COST, p.reverse_cost, p.length_m, p.SOURCE, p.target, p.fraction, p.geom \n\tFROM pair_artificial p\n\tWHERE p.COST <> 0;\nEND \n$function$;\n/*This function create two artificial edges at starting point \nSELECT * \nFROM basic.create_artificial_edges(\n\tbasic.query_edges_routing(ST_ASTEXT(ST_BUFFER(ST_POINT(11.670883790338209, 48.129792632018706),0.0018)),'default',NULL,1.33,'walking_standard',FALSE),\n\tST_SETSRID(ST_POINT(11.670883790338209, 48.129792632018706), 4326), 100, 1, 1\n); \n */"
    )
    op.drop_entity(basic_create_artificial_edges)

    basic_query_edges_routing = PGFunction(
        schema="basic",
        signature="query_edges_routing(buffer_geom text, modus_input text, scenario_id_input integer, speed_input float, routing_profile TEXT, coordinates_only BOOLEAN)",
        definition='returns text\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tsql_ways_ids text := \'\';\n\tsql_scenario_id text := \'\';\n\tsql_routing_profile text := \'\';\n\tsql_geom text := format(\' AND ST_Intersects(geom, ST_SETSRID(ST_GEOMFROMTEXT(\'\'%1$s\'\'), 4326))\', buffer_geom);\n\texcluded_class_id text;\n\tfilter_categories text;\n\ttransport_mode TEXT := split_part(routing_profile,\'_\',1);\n\tcost_function TEXT;\n\tcategory text := jsonb_build_object(\'walking\',\'foot\',\'cycling\',\'bicycle\') ->> transport_mode;\n\tsql_select_ways text;\n\tsql_cost TEXT;\n\ttime_loss_intersections jsonb := \'{}\'::jsonb;\n\tgeom_column TEXT = \'geom\';\nBEGIN \n\texcluded_class_id = (basic.select_customization(\'excluded_class_id_\' || transport_mode))::text;\n\texcluded_class_id = substr(excluded_class_id, 2, length(excluded_class_id) - 2);\n\n  \tfilter_categories = replace(basic.select_customization(\'categories_no_\' || category)::TEXT, \'"\', \'\'\'\');\n\tfilter_categories = substr(filter_categories, 2, length(filter_categories) - 2);\n\n  \tIF transport_mode IN (\'cycling\',\'ebike\') THEN\n  \t\ttime_loss_intersections = basic.select_customization(\'cycling_crossings_delay\');\n  \tEND IF;\n\t\n\tIF routing_profile = \'cycling_pedelec\' THEN \n\t\tcost_function = \'ebike\';\n\tELSE\n\t\tcost_function = transport_mode;\n\tEND IF;\n\n\tsql_cost = jsonb_build_object(\n\t\'cycling\',\'CASE WHEN crossing IS NOT NULL THEN (\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+COALESCE(s_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s) \n\t\t\t   ELSE (length_m*(1+COALESCE(s_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s END AS cost,\n\t\t\t   CASE WHEN crossing IS NOT NULL THEN (\t\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+COALESCE(rs_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s) \n\t\t\t   ELSE (length_m*(1+COALESCE(rs_imp,0)+COALESCE(impedance_surface,0))::float)/%1$s END AS reverse_cost\',\n\t\'walking\', \'length_m/%1$s as cost, length_m/%1$s as reverse_cost\',\n\t\'ebike\', \'CASE WHEN crossing IS NOT NULL THEN (\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+-greatest(-COALESCE(s_imp,0),0)+COALESCE(impedance_surface,0))::float)/%1$s) \n\t\t\t   ELSE (length_m*(1+COALESCE(impedance_surface,0))::float)/%1$s END AS cost,\n\t\t\t   CASE WHEN crossing IS NOT NULL THEN (\'\'%2$s\'\'::jsonb ->> (\'\'delay_\'\' || crossing_delay_category))::integer + ((length_m*(1+-greatest(-COALESCE(rs_imp,0),0)+COALESCE(impedance_surface,0))::float)/%1$s)\n\t\t\t   ELSE (length_m*(1+COALESCE(impedance_surface,0))::float)/%1$s END AS reverse_cost\'\n\t) ->> cost_function;\n\n\tsql_cost = format(sql_cost, speed_input, time_loss_intersections::text);\n\n  \tIF modus_input = \'scenario\' THEN \n\t\tsql_scenario_id = \' AND (scenario_id IS NULL OR scenario_id=\'||scenario_id_input||\')\';\n\t\tsql_ways_ids = \' AND NOT id::int4 = any(\'\'\'|| basic.modified_edges(scenario_id_input)::text ||\'\'\') \';\n\tEND IF;\n\n\tIF  routing_profile = \'walking_safe_night\' THEN\n\t\tsql_routing_profile = \'AND (lit_classified = \'\'yes\'\' OR lit_classified = \'\'unclassified\'\')\';\n\tELSEIF routing_profile = \'walking_wheelchair\' THEN\n\t\tsql_routing_profile = \'AND ((wheelchair_classified = \'\'yes\'\') OR wheelchair_classified = \'\'limited\'\'\n\t\tOR wheelchair_classified = \'\'unclassified\'\')\';\n\tEND IF;\n\t\n\tIF coordinates_only = TRUE THEN\n\t\tgeom_column = \'coordinates_3857\'; \n\tEND IF; \n\n\n\tsql_select_ways = \n\t\t\'SELECT id::integer, source, target, length_3857,\'||sql_cost||\',death_end,\'||quote_ident(geom_column)||\', NULL AS starting_ids, NULL AS starting_geoms\n\t\tFROM basic.edge\n\t\tWHERE class_id NOT IN (\'||excluded_class_id||\')\n    \tAND (\'||quote_ident(category)||\' NOT IN (\'||filter_categories||\') \n\t\tOR \'||quote_ident(category)||\' IS NULL)\n\t\t\'||sql_geom||sql_scenario_id||sql_ways_ids||sql_routing_profile;\n\treturn sql_select_ways;\nEND;\n$function$;\n/*Produces the sql query as text to fetch the network*/\n/*\nSELECT basic.query_edges_routing(ST_ASTEXT(ST_BUFFER(ST_POINT(11.543274,48.195524),0.0018)),\'default\',NULL,1.33,\'walking_standard\',true)\n*/'
    )
    op.drop_entity(basic_query_edges_routing)

    # ### end Alembic commands ###
