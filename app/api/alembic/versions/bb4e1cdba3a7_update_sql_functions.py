"""update sql functions

Revision ID: bb4e1cdba3a7
Revises: a052397bf699
Create Date: 2022-05-01 14:26:28.662978

"""
from alembic import op
import sqlalchemy as sa
import geoalchemy2
import sqlmodel  

from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision = 'bb4e1cdba3a7'
down_revision = 'a052397bf699'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    basic_poi_categories_data_uploads = PGFunction(
        schema="basic",
        signature="poi_categories_data_uploads(user_id_input integer)",
        definition="returns text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tcategories text[];\nBEGIN \n\n\tSELECT ARRAY_AGG(data_upload_id)\n\tINTO categories \n\tFROM customer.opportunity_user_config o, customer.USER u\n\tWHERE o.user_id = u.id\n\tAND u.id = user_id_input\n\tAND o.study_area_id = u.active_study_area_id;\n\n\tRETURN COALESCE(categories, '{}'::TEXT[]);\n\nEND ;\n$function$\n\n/*\nSELECT * FROM basic.poi_categories_data_uploads(4)\n*/"
    )
    op.replace_entity(basic_poi_categories_data_uploads)

    basic_poi_categories = PGFunction(
        schema="basic",
        signature="poi_categories(user_id_input integer)",
        definition="returns jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tactive_study_area_id integer := (SELECT active_study_area_id FROM customer.USER WHERE id = user_id_input);\n\tclassified_pois jsonb;\nBEGIN \n\t\t\n\tclassified_pois = (\n\t\tWITH poi_categories AS \n\t\t(\n\t\t\tSELECT o.multiple_entrance, array_agg(o.category) arr_categories\n\t\t\tFROM basic.active_opportunities(user_id_input, active_study_area_id) o, basic.opportunity_group g \n\t\t\tWHERE g.TYPE = 'poi'\n\t\t\tAND o.category_group = g.GROUP\n\t\t\tGROUP BY o.multiple_entrance\n\t\t)\n\t\tSELECT jsonb_object_agg(COALESCE(multiple_entrance, FALSE), arr_categories)\n\t\tFROM poi_categories\n\t); \n\tRETURN classified_pois; \nEND ;\n$function$\n\n/* Function that returns the default and user poi categories grouped into multiple_entrance and single_entrance\\:\nSELECT basic.poi_categories(1) \n*/"
    )
    op.replace_entity(basic_poi_categories)

    basic_active_opportunities = PGFunction(
        schema="basic",
        signature="active_opportunities(user_id_input integer, active_study_area_id integer)",
        definition='returns TABLE(category TEXT, category_group TEXT, icon TEXT, color TEXT[], multiple_entrance bool, data_upload_id integer, sensitivity integer)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tactive_data_upload_ids integer[] = (SELECT active_data_upload_ids FROM customer.USER WHERE id = user_id_input); \nBEGIN \n\tRETURN QUERY \n\tWITH first_combination AS \n\t(\n\t\tSELECT CASE WHEN s.category IS NULL THEN o.category ELSE s.category END AS category,\n\t\tCASE WHEN s.GROUP IS NULL THEN o."group" ELSE s."group" END AS "group",\n\t\tCASE WHEN s.icon IS NULL THEN o.icon ELSE s.icon END AS icon,\n\t\tCASE WHEN s.color IS NULL THEN o.color ELSE s.color END AS color, s.is_active, o.data_upload_id,\n\t\tCASE WHEN s.multiple_entrance IS NULL THEN o.multiple_entrance END AS multiple_entrance,\n\t\tCASE WHEN s.sensitivity IS NULL THEN o.sensitivity END AS sensitivity\n\t\tFROM (\n\t\t\tSELECT y.*, g."group" \n\t\t\tFROM basic.opportunity_study_area_config y, basic.opportunity_group g\n\t\t\tWHERE y.study_area_id = active_study_area_id\n\t\t\tAND g.id = y.opportunity_group_id\n\t\t) s \n\t\tFULL JOIN (\n\t\t\tSELECT x.*, g."group" \n\t\t\tFROM customer.opportunity_user_config x, basic.opportunity_group g\n\t\t\tWHERE x.user_id = user_id_input\n\t\t\tAND x.study_area_id = active_study_area_id\n\t\t\tAND (x.data_upload_id IN (SELECT UNNEST(active_data_upload_ids)) OR x.data_upload_id IS NULL) \n\t\t\tAND g.id = x.opportunity_group_id\n\t\t) o\n\t\tON o.category = s.category \n\t),\n\tsecond_combination AS \n\t(\n\t\tSELECT CASE WHEN s.category IS NULL THEN o.category ELSE s.category END AS category,\n\t\tCASE WHEN s."group" IS NULL THEN o."group" ELSE s."group" END AS "group",\n\t\tCASE WHEN s.icon IS NULL THEN o.icon ELSE s.icon END AS icon,\n\t\tCASE WHEN s.color IS NULL THEN o.color ELSE s.color END AS color, s.is_active, s.data_upload_id,\n\t\tCASE WHEN s.multiple_entrance IS NULL THEN o.multiple_entrance END AS multiple_entrance,\n\t\tCASE WHEN s.sensitivity IS NULL THEN o.sensitivity END AS sensitivity\n\t\tFROM (\n\t\t\tSELECT x.*, g."group" \n\t\t\tFROM basic.opportunity_default_config x, basic.opportunity_group g\n\t\t\tWHERE g.id = x.opportunity_group_id\n\t\t) o \n\t\tFULL JOIN first_combination s \n\t\tON o.category = s.category \n\t)\n\tSELECT s.category, s."group", s.icon, s.color, s.multiple_entrance, s.data_upload_id, s.sensitivity \n\tFROM second_combination s \n\tWHERE (is_active IS NULL OR is_active IS TRUE); \n\nEND ;\n$function$\n\n/*\nSELECT * FROM basic.active_opportunities(40, 91620000)\n*/'
    )
    op.create_entity(basic_active_opportunities)

    basic_active_opportunities_json = PGFunction(
        schema="basic",
        signature="active_opportunities_json(opportunity_type text, user_id_input integer, active_study_area_id integer)",
        definition='returns json\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tsettings json; \nBEGIN \n\n\tWITH prepared_json AS \n\t(\n\t\tSELECT category_group AS "group", category, json_build_object(\'icon\', icon, \'color\', color) AS icon_color, \n\t\tCASE WHEN multiple_entrance IS NULL THEN \'{}\'::json ELSE json_build_object(\'multiple_entrance\', multiple_entrance) END AS multiple_entrance,\n\t\tCASE WHEN sensitivity IS NULL THEN \'{}\'::json ELSE json_build_object(\'sensitivity\', sensitivity) END AS sensitivity\n\t\tFROM basic.active_opportunities(user_id_input, active_study_area_id) \n\t),\n\tgrouped_categories AS \n\t(\n\t\tSELECT "group", json_agg(json_build_object(category, (icon_color::jsonb || multiple_entrance::jsonb || sensitivity::jsonb)::json)) AS children\n\t\tFROM prepared_json \n\t\tGROUP BY "group"\n\t),\n\tsorted_as_group AS \n\t(\n\t\tSELECT json_build_object(o."group", json_build_object(\'icon\', o.icon, \'color\', o.color, \'children\', g.children)) AS opportunity_groups\n\t\tFROM basic.opportunity_group o, grouped_categories g \n\t\tWHERE o."group" = g."group"\n\t    AND o.type = opportunity_type\n\t   \tORDER BY o.id\n   \t)\n   \tSELECT json_agg(opportunity_groups)\n   \tINTO settings\n\tFROM sorted_as_group; \n\n\tRETURN settings; \n\nEND ;\n$function$\n\n/*\nSELECT basic.active_opportunities_json(\'poi\', 40, 91620000)\n*/'
    )
    op.create_entity(basic_active_opportunities_json)

    basic_reached_population_study_area = PGFunction(
        schema="basic",
        signature="reached_population_study_area(ischrone_calculation_id_input integer, scenario_id_input integer, modus text, study_area_ids integer[])",
        definition="returns TABLE(id integer, step integer, reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[] := '{}'::integer[];\nBEGIN\n\t\n\tDROP TABLE IF EXISTS reachable_population; \n\n\t/*Get reachable population*/\n\tIF modus = 'default' THEN\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tSELECT i.id AS isochrone_feature_id, s.id AS sub_study_area_id, s.name, s.population \n\t\tFROM basic.sub_study_area s, customer.isochrone_feature i \n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids))\n\t\tAND i.isochrone_calculation_id = ischrone_calculation_id_input; \n\t\n\tELSEIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT p.sub_study_area_id, -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tGROUP BY p.sub_study_area_id \n\t\t\tUNION ALL \n\t\t\tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t \t),\n\t \tscenario_population AS \n\t \t(\n\t\t \tSELECT p.sub_study_area_id, sum(population) population \n\t\t \tFROM prepared_scenario p \n\t\t \tGROUP BY p.sub_study_area_id\n\t\t),\n\t\tcombined_population AS \n\t\t( \n\t\t\tSELECT s.id AS sub_study_area_id, s.name, (s.population + COALESCE(sp.population, 0)) AS population \n\t\t\tFROM basic.sub_study_area s\n\t\t\tLEFT JOIN scenario_population sp \n\t\t\tON s.id = sp.sub_study_area_id\n\t\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)) \t\n\t\t)\n\t\tSELECT i.id AS isochrone_feature_id, c.*\n\t\tFROM customer.isochrone_feature i, combined_population c\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input; \n\tELSE \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input \n\t)\n\tSELECT g.id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population, g.sub_study_area_id \n\tFROM to_group g\n\tGROUP BY g.id, g.sub_study_area_id; \n\t\n\t/*Combine and return results*/\n\tRETURN query \n\tWITH combined AS \n\t(\n\t\tSELECT a.isochrone_feature_id, a.sub_study_area_id, a.name, \n\t\tCASE WHEN COALESCE(r.population, 0) > a.population THEN a.population \n\t\tELSE COALESCE(r.population, 0) END AS reached_population, a.population AS total_population \n\t\tFROM reachable_population a\n\t\tLEFT JOIN reached_population r \n\t\tON a.isochrone_feature_id = r.id \n\t),\n\tas_object AS \n\t(\n\t\tSELECT c.isochrone_feature_id, jsonb_object_agg(c.sub_study_area_id, \n\t\tjsonb_build_object('name', c.name, 'reached_population', c.reached_population, 'total_population', c.total_population)) AS population \n\t\tFROM combined c\n\t\tGROUP BY c.isochrone_feature_id \n\t)\n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = o.population \n\tFROM as_object o \n\tWHERE o.isochrone_feature_id = i.id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n \nEND; \n$function$;\n\n/*\nSELECT * \nFROM basic.reached_population_study_area(39, 2,'default', ARRAY[17,24,26])\n*/"
    )
    op.replace_entity(basic_reached_population_study_area)

    basic_prepare_heatmap_local_accessibility = PGFunction(
        schema="basic",
        signature="prepare_heatmap_local_accessibility(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition='returns TABLE(grid_visualization_id bigint, accessibility_index bigint)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tarray_amenities text[];\n\tpois_one_entrance jsonb := basic.poi_categories(user_id_input) -> \'false\';\n\tpois_more_entrances jsonb := basic.poi_categories(user_id_input) -> \'true\';\n\tsensitivities integer[]; \n\ttranslation_sensitivities jsonb;\n\texcluded_poi_uids text[] := \'{}\'::TEXT[];\nBEGIN\n  \t\n\tSELECT ARRAY_AGG(s.sensitivity::integer) \n\tINTO sensitivities \n\tFROM (\n\t\tSELECT jsonb_array_elements_text(basic.select_customization(\'heatmap_sensitivities\')) sensitivity \n\t) s;\n\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_one_entrance  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_one_entrance) AS o(category) \n\tWHERE a.category = o.category; \n\t\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_more_entrances  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_more_entrances) AS o(category) \n\tWHERE a.category = o.category; \n\n\tSELECT jsonb_object_agg(k, (sensitivities  # (v ->> \'sensitivity\')::integer)::smallint)\n\tINTO translation_sensitivities\n\tFROM jsonb_each(amenities_json) AS u(k, v);\n\n\tIF modus_input <> \'default\' AND scenario_id_input <> 0 THEN \n\t\texcluded_poi_uids = basic.modified_pois(scenario_id_input); \n\tEND IF; \n\n\tRETURN query\n\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\tAND r.scenario_id IS NULL \n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\n\tRETURN query \n\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\tp.category, p.name\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND r.scenario_id IS NULL\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\t\n\tIF data_upload_ids <> \'{}\'::integer[] THEN \n\t\tRETURN query\n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND r.scenario_id IS NULL \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t\tAND (p.uid NOT IN (SELECT UNNEST(excluded_poi_uids)) AND scenario_id IS NULL)\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND r.scenario_id IS NULL \n\t\t\tAND (p.uid NOT IN (SELECT UNNEST(excluded_poi_uids)) AND scenario_id IS NULL)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \t\n\tEND IF;\n\n\tIF modus_input <> \'default\' AND scenario_id_input <> 0 THEN \n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p  \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND r.scenario_id = scenario_id_input\n\t\t\tAND p.edit_type <> \'d\'\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> \'weight\')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.edit_type <> \'d\'\n\t\t\tAND r.scenario_id = scenario_id_input\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\t\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\tEND IF; \n\t\nEND;\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_heatmap;\nCREATE TABLE default_heatmap AS \nWITH heatmap_grids AS \n(\n\tSELECT grid_visualization_id, sum(accessibility_index) \n\tFROM basic.prepare_heatmap_local_accessibility(\'{"supermarket"\\:{"sensitivity"\\:250000,"weight"\\:1}}\'::jsonb, 4, 1, \'default\',10) h\n\tGROUP BY grid_visualization_id \n)\nSELECT h.*, g.geom \nFROM basic.grid_visualization g, heatmap_grids h \nWHERE h.grid_visualization_id = g.id;  \n\nDROP TABLE IF EXISTS pois_to_explore; \nCREATE TABLE pois_to_explore AS \nSELECT * \nFROM basic.poi_aoi_visualization(4, 2, \'default\', ARRAY[0], 1)\nWHERE category = \'supermarket\'\n*/'
    )
    op.replace_entity(basic_prepare_heatmap_local_accessibility)

    basic_reached_pois_heatmap = PGFunction(
        schema="basic",
        signature="reached_pois_heatmap(table_name TEXT, calculation_geom geometry, user_id_input integer, scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[], poi_modified_uid text DEFAULT '')",
        definition="returns VOID\nAS $function$\nDECLARE\n\tsensitivities jsonb:= basic.select_customization('heatmap_sensitivities'); \n\tsnap_distance integer := basic.select_customization('snap_distance_poi_heatmap')::integer; \n\tbuffer_pois geometry := ST_BUFFER(calculation_geom::geography, snap_distance)::geometry;\n\tpoi_categories jsonb := basic.poi_categories(user_id_input); \n\tarr_categories text[];\nBEGIN \n\t\n\tIF table_name = 'poi_user' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap \n\t\tWHERE data_upload_id IN (SELECT UNNEST(data_upload_ids));\n\t\n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap r\n\t\tWHERE poi_uid = poi_modified_uid\n\t\tAND scenario_id = scenario_id_input;\n\t\n\tEND IF; \n\n\tWITH categories AS\n\t(\n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'true') AS category\n\t\tUNION ALL \n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'false') AS category\n\t)\n\tSELECT array_agg(category)\n\tFROM categories \n\tINTO arr_categories; \n\t\n\tIF table_name = 'poi' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, NULL AS data_upload_id  \n\t\tFROM (\n\t\t\tSELECT p.* \n\t\t\tFROM basic.poi p\n\t\t\tLEFT JOIN customer.reached_poi_heatmap r \n\t\t\tON r.poi_uid = p.uid\n\t\t\tWHERE r.poi_uid IS NULL\n\t\t) p  \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE p.category IN (SELECT UNNEST(arr_categories))\n\t\tAND ST_Intersects(p.geom, buffer_pois); \n\tELSEIF table_name = 'poi_user' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, p.data_upload_id \n\t\tFROM \n\t\t(\n\t\t\tSELECT p.* \n\t\t\tFROM customer.poi_user p\n\t\t\tLEFT JOIN customer.reached_poi_heatmap r \n\t\t\tON r.poi_uid = p.uid\n\t\t\tWHERE r.poi_uid IS NULL\n\t\t) p \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE ST_Intersects(p.geom, buffer_pois)\n\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids)); \n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, scenario_id_input AS scenario_id, p.data_upload_id  \n\t\tFROM (\n\t\t\tSELECT p.* \n\t\t\tFROM customer.poi_modified p \n\t\t\tWHERE p.uid = poi_modified_uid \n\t\t\tAND p.scenario_id = scenario_id_input\n\t\t) p\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f;\n\tELSE \n\t\tRAISE EXCEPTION 'Please specify a valid table name.';\n\tEND IF;\n\t\n\tCREATE INDEX ON pois_edges_full (edge_id);\t\n\tINSERT INTO customer.reached_poi_heatmap(poi_uid, scenario_id, data_upload_id, grid_visualization_ids, costs, accessibility_indices)\n\tWITH pois_with_cost AS \n\t(\n\t\tSELECT f.poi_uid, f.scenario_id, c.grid_visualization_id, c.COST, f.data_upload_id \n\t\tFROM pois_edges_full f\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT e.grid_visualization_id, avg(e.cost) AS COST \n\t\t\tFROM \n\t\t\t(\n\t\t\t\tSELECT c.grid_visualization_id,\n\t\t\t\tCASE WHEN r.start_cost < r.end_cost THEN (r.start_cost + f.fraction * (r.end_cost-r.start_cost))\n\t\t\t\tELSE (r.end_cost + (1-f.fraction) * (r.start_cost - r.end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND (r.edge_type IS NULL or r.edge_type = 'a')\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t\tUNION ALL \n\t\t\t\tSELECT c.grid_visualization_id, CASE WHEN start_cost < end_cost THEN (start_cost + fraction * (end_cost-start_cost))\n\t\t\t\tELSE (end_cost + (1-fraction) * (start_cost - end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND edge_type IN ('p', 'ap')\n\t\t\t\tAND f.fraction BETWEEN least(r.start_perc,r.end_perc) AND greatest(r.start_perc,r.end_perc)\t\t\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t) e\t\n\t\t\tGROUP BY e.grid_visualization_id \n\t\t) AS c \n\t),\n\tfirst_merge AS\n\t(\n\t\tSELECT poi_uid, scenario_id, data_upload_id, array_agg(grid_visualization_id) AS grid_visualization_ids , array_agg(cost) AS costs   \n\t\tFROM pois_with_cost \n\t\tGROUP BY poi_uid, scenario_id, data_upload_id  \n\t)\n\tSELECT f.poi_uid, f.scenario_id::integer, f.data_upload_id::integer, f.grid_visualization_ids, f.costs, a.accessibility_indices\n\tFROM first_merge f\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT ARRAY_AGG(accessibility_indices) AS accessibility_indices \n\t\tFROM \n\t\t(\n\t\t\tSELECT array_AGG((pow(exp(1.0)::real,(p.cost::real * p.cost::real) / -s.sensitivity) * (10000))::integer) AS accessibility_indices, s.sensitivity  \n\t\t\tFROM (SELECT sensitivity::REAL FROM jsonb_array_elements(basic.select_customization('heatmap_sensitivities')) sensitivity) s, \n\t\t\t(SELECT UNNEST(f.costs) cost) p\n\t\t\tGROUP BY sensitivity \n\t\t\tORDER BY sensitivity \n\t\t) s\n\t) AS a;\n\t\nEND;\n$function$ LANGUAGE plpgsql\n\n/*\nEXPLAIN ANALYZE \nSELECT basic.reached_pois_heatmap('poi_modified'::text, geom, 4, 75, ARRAY[0]::integer[], 'd0c79777fcdc4d55b02da0ef17470bef'::text) \nFROM (SELECT * FROM customer.poi_modified pm WHERE uid = 'd0c79777fcdc4d55b02da0ef17470bef') p\n*/"
    )
    op.replace_entity(basic_reached_pois_heatmap)

    basic_poi_aoi_visualization = PGFunction(
        schema="basic",
        signature="poi_aoi_visualization(user_id_input integer, scenario_id_input integer, active_upload_ids integer[], active_study_area_id integer)",
        definition="returns TABLE (id integer, uid TEXT, category TEXT, name TEXT, opening_hours TEXT, street TEXT, housenumber TEXT, zipcode TEXT, edit_type TEXT, geom geometry)\nLANGUAGE plpgsql\nAS $function$\nDECLARE \t\n\taoi_categories TEXT[]; \n\tdata_upload_poi_categories TEXT[] = '{}'::TEXT[];\n\tall_poi_categories text[];\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\tbuffer_geom_study_area geometry; \nBEGIN\n\tdata_upload_poi_categories = basic.poi_categories_data_uploads(user_id_input);\n\t\n\t/*Get combined poi categories*/\n\tSELECT array_agg(o.category) \n\tINTO all_poi_categories \n\tFROM basic.active_opportunities(user_id_input, active_study_area_id) o, basic.opportunity_group g \n\tWHERE o.category_group = g.GROUP \n\tAND g.TYPE = 'poi';\n\n\t/*Prepare AOI categories*/\n\tSELECT ARRAY_AGG(o.category) \n\tINTO aoi_categories\n\tFROM basic.active_opportunities(user_id_input, active_study_area_id) o, basic.opportunity_group g \n\tWHERE o.category_group = g.GROUP \n\tAND g.TYPE = 'aoi'; \n\n\t/*Check if POI scenario*/\n\tIF scenario_id_input <> 0 THEN \n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\tEND IF; \n\t/*Buffer study area to avoid border effects*/\n\tbuffer_geom_study_area = (SELECT buffer_geom_heatmap AS geom FROM basic.study_area s WHERE s.id = active_study_area_id);\n\n    RETURN query\n   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM basic.poi p\n\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area\n\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\tRETURN query \n\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM customer.poi_user p\n\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\t/*No scenarios nor aoi_user is implemented at the moment*/\n\tSELECT p.id, NULL, p.category, p.name, p.opening_hours, NULL AS street, NULL AS housenumber, NULL AS zipcode, NULL AS edit_type, p.geom\n\tFROM basic.aoi p \n\tWHERE p.category IN (SELECT UNNEST(aoi_categories))\n\tAND p.geom && buffer_geom_study_area; \n\t\n\tIF scenario_id_input <> 0 THEN \n\t   \tRETURN query \n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, p.edit_type, p.geom  \n\t\tFROM customer.poi_modified p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.scenario_id = scenario_id_input; \n\t   \t\n\t\tRETURN query\n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM basic.poi p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\t\tRETURN query \n\t\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM customer.poi_user p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\tEND IF; \nEND ;\n$function$;\n\n\n/*\nModus should be default, scenario, comparison\nSELECT * \nFROM basic.poi_aoi_visualization(4, 2, 'default', ARRAY[0], 1)\n*/"
    )
    op.replace_entity(basic_poi_aoi_visualization)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    basic_poi_aoi_visualization = PGFunction(
        schema="basic",
        signature="poi_aoi_visualization(user_id_input integer, scenario_id_input integer, active_upload_ids integer[], active_study_area_id integer)",
        definition="returns TABLE(id integer, uid text, category text, name text, opening_hours text, street text, housenumber text, zipcode text, edit_type text, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \t\n\taoi_categories TEXT[]; \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tdata_upload_poi_categories TEXT[] = '{}'::TEXT[];\n\tcombined_poi_categories text[];\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\tbuffer_geom_study_area geometry; \nBEGIN\n\tdata_upload_poi_categories = basic.poi_categories_data_uploads(user_id_input);\n\t\n\t/*Get combined poi categories*/\n\tSELECT ARRAY_AGG(c.category)\n\tINTO combined_poi_categories\n\tFROM \t\n\t(\n\t\tSELECT jsonb_array_elements_text(poi_categories -> 'true') category\n\t\tUNION ALL \n\t\tSELECT jsonb_array_elements_text(poi_categories -> 'false') category\n\t) c;\n\n\t/*Prepare AOI categories*/\n\tDROP TABLE IF EXISTS aoi_groups_default; \n\tCREATE TEMP TABLE aoi_groups_default AS \n\tWITH aoi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(basic.select_customization('aoi_groups')) aoi_group\n\t)\n\tSELECT jsonb_array_elements(p.aoi_group -> jsonb_object_keys(p.aoi_group) -> 'children') AS aoi_category \n\tFROM aoi_groups p;\n\n\tSELECT ARRAY_AGG(object_keys) AS aoi_category\n\tINTO aoi_categories\n\tFROM aoi_groups_default  p, LATERAL jsonb_object_keys(p.aoi_category) object_keys;  \n\t\n\t/*Check if POI scenario*/\n\tIF scenario_id_input <> 0 THEN \n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\tEND IF; \n\t/*Buffer study area to avoid border effects*/\n\tbuffer_geom_study_area = (SELECT buffer_geom_heatmap AS geom FROM basic.study_area s WHERE s.id = active_study_area_id);\n\n    RETURN query\n   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM basic.poi p\n\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area\n\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\tRETURN query \n\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM customer.poi_user p\n\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\t/*No scenarios nor aoi_user is implemented at the moment*/\n\tSELECT p.id, NULL, p.category, p.name, p.opening_hours, NULL AS street, NULL AS housenumber, NULL AS zipcode, NULL AS edit_type, p.geom\n\tFROM basic.aoi p \n\tWHERE p.category IN (SELECT UNNEST(aoi_categories))\n\tAND p.geom && buffer_geom_study_area; \n\t\n\tIF scenario_id_input <> 0 THEN \n\t   \tRETURN query \n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, p.edit_type, p.geom  \n\t\tFROM customer.poi_modified p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.scenario_id = scenario_id_input; \n\t   \t\n\t\tRETURN query\n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM basic.poi p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\t\tRETURN query \n\t\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM customer.poi_user p\n\t\tWHERE p.category IN (SELECT UNNEST(combined_poi_categories))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\tEND IF; \nEND ;\n$function$"
    )
    op.replace_entity(basic_poi_aoi_visualization)
    basic_reached_pois_heatmap = PGFunction(
        schema="basic",
        signature="reached_pois_heatmap(table_name text, calculation_geom geometry, user_id_input integer, scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[], poi_modified_uid text DEFAULT ''::text)",
        definition="returns void\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tsensitivities jsonb:= basic.select_customization('heatmap_sensitivities'); \n\tsnap_distance integer := basic.select_customization('snap_distance_poi_heatmap')::integer; \n\tbuffer_pois geometry := ST_BUFFER(calculation_geom::geography, snap_distance)::geometry;\n\tpoi_categories jsonb := basic.poi_categories(user_id_input); \n\tarr_categories text[];\nBEGIN \n\t\n\tIF table_name = 'poi_user' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap \n\t\tWHERE data_upload_id IN (SELECT UNNEST(data_upload_ids));\n\t\n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDELETE FROM customer.reached_poi_heatmap r\n\t\tWHERE poi_uid = poi_modified_uid\n\t\tAND scenario_id = scenario_id_input;\n\t\n\tEND IF; \n\n\tWITH categories AS\n\t(\n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'true') AS category\n\t\tUNION ALL \n\t\tSELECT jsonb_array_elements_text(basic.poi_categories(user_id_input) -> 'false') AS category\n\t)\n\tSELECT array_agg(category)\n\tFROM categories \n\tINTO arr_categories; \n\t\n\tIF table_name = 'poi' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, NULL AS data_upload_id  \n\t\tFROM basic.poi p \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE p.category IN (SELECT UNNEST(arr_categories))\n\t\tAND ST_Intersects(p.geom, buffer_pois); \n\tELSEIF table_name = 'poi_user' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, NULL AS scenario_id, p.data_upload_id \n\t\tFROM customer.poi_user p \n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f\n\t\tWHERE ST_Intersects(p.geom, buffer_pois)\n\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids)); \n\tELSEIF table_name = 'poi_modified' THEN \n\t\tDROP TABLE IF EXISTS pois_edges_full;\n\t\tCREATE TEMP TABLE pois_edges_full AS \n\t\tSELECT p.uid AS poi_uid, f.fraction, f.edge_id, scenario_id_input AS scenario_id, p.data_upload_id  \n\t\tFROM (SELECT * FROM customer.poi_modified x WHERE x.uid = poi_modified_uid AND x.scenario_id = scenario_id_input) p\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT ST_LineLocatePoint(e.geom,p.geom) fraction, e.edge_id\n\t\t\tFROM customer.reached_edge_full_heatmap e \n\t\t\tWHERE e.geom && ST_Buffer(p.geom::geography, snap_distance)::geometry\n\t\t\tORDER BY ST_CLOSESTPOINT(e.geom, p.geom) <-> p.geom \n\t\t\tLIMIT 1 \n\t\t) AS f;\n\tELSE \n\t\tRAISE EXCEPTION 'Please specify a valid table name.';\n\tEND IF;\n\t\n\tCREATE INDEX ON pois_edges_full (edge_id);\t\n\tINSERT INTO customer.reached_poi_heatmap(poi_uid, scenario_id, data_upload_id, grid_visualization_ids, costs, accessibility_indices)\n\tWITH pois_with_cost AS \n\t(\n\t\tSELECT f.poi_uid, f.scenario_id, c.grid_visualization_id, c.COST, f.data_upload_id \n\t\tFROM pois_edges_full f\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT e.grid_visualization_id, avg(e.cost) AS COST \n\t\t\tFROM \n\t\t\t(\n\t\t\t\tSELECT c.grid_visualization_id,\n\t\t\t\tCASE WHEN r.start_cost < r.end_cost THEN (r.start_cost + f.fraction * (r.end_cost-r.start_cost))\n\t\t\t\tELSE (r.end_cost + (1-f.fraction) * (r.start_cost - r.end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND (r.edge_type IS NULL or r.edge_type = 'a')\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t\tUNION ALL \n\t\t\t\tSELECT c.grid_visualization_id, CASE WHEN start_cost < end_cost THEN (start_cost + fraction * (end_cost-start_cost))\n\t\t\t\tELSE (end_cost + (1-fraction) * (start_cost - end_cost)) END AS COST\n\t\t\t\tFROM customer.reached_edge_heatmap_grid_calculation r, basic.grid_calculation c \n\t\t\t\tWHERE f.edge_id = r.reached_edge_heatmap_id \n\t\t\t\tAND edge_type IN ('p', 'ap')\n\t\t\t\tAND f.fraction BETWEEN least(r.start_perc,r.end_perc) AND greatest(r.start_perc,r.end_perc)\t\t\n\t\t\t\tAND r.grid_calculation_id = c.id\n\t\t\t) e\t\n\t\t\tGROUP BY e.grid_visualization_id \n\t\t) AS c \n\t),\n\tfirst_merge AS\n\t(\n\t\tSELECT poi_uid, scenario_id, data_upload_id, array_agg(grid_visualization_id) AS grid_visualization_ids , array_agg(cost) AS costs   \n\t\tFROM pois_with_cost \n\t\tGROUP BY poi_uid, scenario_id, data_upload_id  \n\t)\n\tSELECT f.poi_uid, f.scenario_id::integer, f.data_upload_id::integer, f.grid_visualization_ids, f.costs, a.accessibility_indices\n\tFROM first_merge f\n\tCROSS JOIN LATERAL \n\t(\n\t\tSELECT ARRAY_AGG(accessibility_indices) AS accessibility_indices \n\t\tFROM \n\t\t(\n\t\t\tSELECT array_AGG((pow(exp(1.0)::real,(p.cost::real * p.cost::real) / -s.sensitivity) * (10000))::integer) AS accessibility_indices, s.sensitivity  \n\t\t\tFROM (SELECT sensitivity::REAL FROM jsonb_array_elements(basic.select_customization('heatmap_sensitivities')) sensitivity) s, \n\t\t\t(SELECT UNNEST(f.costs) cost) p\n\t\t\tGROUP BY sensitivity \n\t\t\tORDER BY sensitivity \n\t\t) s\n\t) AS a;\n\t\nEND;\n$function$"
    )
    op.replace_entity(basic_reached_pois_heatmap)
    basic_prepare_heatmap_local_accessibility = PGFunction(
        schema="basic",
        signature="prepare_heatmap_local_accessibility(amenities_json jsonb, user_id_input integer, active_study_area_id integer, modus_input text DEFAULT 'default'::text, scenario_id_input integer DEFAULT 0, data_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE(grid_visualization_id bigint, accessibility_index bigint)\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n\tarray_amenities text[];\n\tpois_one_entrance jsonb := basic.poi_categories(user_id_input) -> 'false';\n\tpois_more_entrances jsonb := basic.poi_categories(user_id_input) -> 'true';\n\tsensitivities integer[]; \n\ttranslation_sensitivities jsonb;\n\texcluded_poi_uids text[] := '{}'::TEXT[];\nBEGIN\n  \t\n\tSELECT ARRAY_AGG(s.sensitivity::integer) \n\tINTO sensitivities \n\tFROM (\n\t\tSELECT jsonb_array_elements_text(basic.select_customization('heatmap_sensitivities')) sensitivity \n\t) s;\n\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_one_entrance  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_one_entrance) AS o(category) \n\tWHERE a.category = o.category; \n\t\n\tSELECT jsonb_agg(a.category)\n\tINTO pois_more_entrances  \n\tFROM jsonb_object_keys(amenities_json) AS a(category), jsonb_array_elements_text(pois_more_entrances) AS o(category) \n\tWHERE a.category = o.category; \n\n\tSELECT jsonb_object_agg(k, (sensitivities  # (v ->> 'sensitivity')::integer)::smallint)\n\tINTO translation_sensitivities\n\tFROM jsonb_each(amenities_json) AS u(k, v);\n\n\tIF modus_input <> 'default' AND scenario_id_input <> 0 THEN \n\t\texcluded_poi_uids = basic.modified_pois(scenario_id_input); \n\tEND IF; \n\n\tRETURN query\n\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> 'weight')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\n\tRETURN query \n\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> 'weight')::SMALLINT)::bigint AS accessibility_index  \n\tFROM (\n\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\tp.category, p.name\n\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, basic.poi p   \n\t\tWHERE s.id = active_study_area_id \n\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\tAND p.uid = r.poi_uid \n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\t\n\tIF data_upload_ids <> '{}'::integer[] THEN \n\t\tRETURN query\n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> 'weight')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> 'weight')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_user p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_poi_uids))\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(data_upload_ids))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \t\n\tEND IF;\n\n\tIF modus_input <> 'default' AND scenario_id_input <> 0 THEN \n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (u.accessibility_index * (amenities_json -> x.category ->> 'weight')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], p.category\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p  \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND p.edit_type <> 'd'\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index);\n\t\t\n\t\tRETURN query \n\t\tSELECT u.grid_visualization_id, (max(u.accessibility_index) * (amenities_json -> x.category ->> 'weight')::SMALLINT)::bigint AS accessibility_index  \n\t\tFROM (\n\t\t\tSELECT grid_visualization_ids, accessibility_indices[(translation_sensitivities ->> p.category)::integer\\:(translation_sensitivities ->> p.category)::integer][1\\:], \n\t\t\tp.category, p.name\n\t\t\tFROM customer.reached_poi_heatmap r, basic.study_area s, customer.poi_modified p   \n\t\t\tWHERE s.id = active_study_area_id \n\t\t\tAND ST_Intersects(p.geom, s.buffer_geom_heatmap)\n\t\t\tAND p.uid = r.poi_uid \n\t\t\tAND p.edit_type <> 'd'\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrances))\t\n\t\t)x, UNNEST(x.grid_visualization_ids, x.accessibility_indices) AS u(grid_visualization_id, accessibility_index)\n\t\tGROUP BY u.grid_visualization_id, x.category, x.name;  \n\tEND IF; \n\t\nEND;\n$function$"
    )
    op.replace_entity(basic_prepare_heatmap_local_accessibility)
    basic_reached_population_study_area = PGFunction(
        schema="basic",
        signature="reached_population_study_area(ischrone_calculation_id_input integer, scenario_id_input integer, modus text, study_area_ids integer[])",
        definition="returns TABLE(id integer, step integer, reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[] := '{}'::integer[];\nBEGIN\n\t\n\tDROP TABLE IF EXISTS reachable_population; \n\n\t/*Get reachable population*/\n\tIF modus = 'default' THEN\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tSELECT i.id AS isochrone_feature_id, s.id AS sub_study_area_id, s.name, s.population \n\t\tFROM basic.sub_study_area s, customer.isochrone_feature i \n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids))\n\t\tAND i.isochrone_calculation_id = ischrone_calculation_id_input; \n\t\n\tELSEIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT p.sub_study_area_id, -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tGROUP BY p.sub_study_area_id \n\t\t\tUNION ALL \n\t\t\tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t \t),\n\t \tscenario_population AS \n\t \t(\n\t\t \tSELECT p.sub_study_area_id, sum(population) population \n\t\t \tFROM prepared_scenario p \n\t\t \tGROUP BY p.sub_study_area_id\n\t\t) \n\t\tSELECT s.id AS sub_study_area_id, s.name, (s.population + COALESCE(sp.population, 0)) AS population \n\t\tFROM basic.sub_study_area s\n\t\tLEFT JOIN scenario_population sp \n\t\tON s.id = sp.sub_study_area_id\n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)); \t\n\n\tELSE \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input \n\t)\n\tSELECT g.id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population, g.sub_study_area_id \n\tFROM to_group g\n\tGROUP BY g.id, g.sub_study_area_id; \n\t\n\t/*Combine and return results*/\n\tRETURN query \n\tWITH combined AS \n\t(\n\t\tSELECT a.isochrone_feature_id, a.sub_study_area_id, a.name, \n\t\tCASE WHEN COALESCE(r.population, 0) > a.population THEN a.population \n\t\tELSE COALESCE(r.population, 0) END AS reached_population, a.population AS total_population \n\t\tFROM reachable_population a\n\t\tLEFT JOIN reached_population r \n\t\tON a.isochrone_feature_id = r.id \n\t),\n\tas_object AS \n\t(\n\t\tSELECT c.isochrone_feature_id, jsonb_object_agg(c.sub_study_area_id, \n\t\tjsonb_build_object('name', c.name, 'reached_population', c.reached_population, 'total_population', c.total_population)) AS population \n\t\tFROM combined c\n\t\tGROUP BY c.isochrone_feature_id \n\t)\n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = o.population \n\tFROM as_object o \n\tWHERE o.isochrone_feature_id = i.id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n \nEND; \n$function$"
    )
    op.replace_entity(basic_reached_population_study_area)
    basic_active_opportunities_json = PGFunction(
        schema="basic",
        signature="active_opportunities_json(opportunity_type text, user_id_input integer, active_study_area_id integer)",
        definition='returns json\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tsettings json; \nBEGIN \n\n\tWITH prepared_json AS \n\t(\n\t\tSELECT category_group AS "group", category, json_build_object(\'icon\', icon, \'color\', color) AS icon_color, \n\t\tCASE WHEN multiple_entrance IS NULL THEN \'{}\'::json ELSE json_build_object(\'multiple_entrance\', multiple_entrance) END AS multiple_entrance,\n\t\tCASE WHEN sensitivity IS NULL THEN \'{}\'::json ELSE json_build_object(\'sensitivity\', sensitivity) END AS sensitivity\n\t\tFROM basic.active_opportunities(user_id_input, active_study_area_id) \n\t),\n\tgrouped_categories AS \n\t(\n\t\tSELECT "group", json_agg(json_build_object(category, (icon_color::jsonb || multiple_entrance::jsonb || sensitivity::jsonb)::json)) AS children\n\t\tFROM prepared_json \n\t\tGROUP BY "group"\n\t),\n\tsorted_as_group AS \n\t(\n\t\tSELECT json_build_object(o."group", json_build_object(\'icon\', o.icon, \'color\', o.color, \'children\', g.children)) AS opportunity_groups\n\t\tFROM basic.opportunity_group o, grouped_categories g \n\t\tWHERE o."group" = g."group"\n\t    AND o.type = opportunity_type\n\t   \tORDER BY o.id\n   \t)\n   \tSELECT json_agg(opportunity_groups)\n   \tINTO settings\n\tFROM sorted_as_group; \n\n\tRETURN settings; \n\nEND ;\n$function$\n\n/*\nSELECT basic.active_opportunities_json(\'poi\', 40, 91620000)\n*/'
    )
    op.drop_entity(basic_active_opportunities_json)

    basic_active_opportunities = PGFunction(
        schema="basic",
        signature="active_opportunities(user_id_input integer, active_study_area_id integer)",
        definition='returns TABLE(category TEXT, category_group TEXT, icon TEXT, color TEXT[], multiple_entrance bool, data_upload_id integer, sensitivity integer)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tactive_data_upload_ids integer[] = (SELECT active_data_upload_ids FROM customer.USER WHERE id = user_id_input); \nBEGIN \n\tRETURN QUERY \n\tWITH first_combination AS \n\t(\n\t\tSELECT CASE WHEN s.category IS NULL THEN o.category ELSE s.category END AS category,\n\t\tCASE WHEN s.GROUP IS NULL THEN o."group" ELSE s."group" END AS "group",\n\t\tCASE WHEN s.icon IS NULL THEN o.icon ELSE s.icon END AS icon,\n\t\tCASE WHEN s.color IS NULL THEN o.color ELSE s.color END AS color, s.is_active, o.data_upload_id,\n\t\tCASE WHEN s.multiple_entrance IS NULL THEN o.multiple_entrance END AS multiple_entrance,\n\t\tCASE WHEN s.sensitivity IS NULL THEN o.sensitivity END AS sensitivity\n\t\tFROM (\n\t\t\tSELECT y.*, g."group" \n\t\t\tFROM basic.opportunity_study_area_config y, basic.opportunity_group g\n\t\t\tWHERE y.study_area_id = active_study_area_id\n\t\t\tAND g.id = y.opportunity_group_id\n\t\t) s \n\t\tFULL JOIN (\n\t\t\tSELECT x.*, g."group" \n\t\t\tFROM customer.opportunity_user_config x, basic.opportunity_group g\n\t\t\tWHERE x.user_id = user_id_input\n\t\t\tAND x.study_area_id = active_study_area_id\n\t\t\tAND (x.data_upload_id IN (SELECT UNNEST(active_data_upload_ids)) OR x.data_upload_id IS NULL) \n\t\t\tAND g.id = x.opportunity_group_id\n\t\t) o\n\t\tON o.category = s.category \n\t),\n\tsecond_combination AS \n\t(\n\t\tSELECT CASE WHEN s.category IS NULL THEN o.category ELSE s.category END AS category,\n\t\tCASE WHEN s."group" IS NULL THEN o."group" ELSE s."group" END AS "group",\n\t\tCASE WHEN s.icon IS NULL THEN o.icon ELSE s.icon END AS icon,\n\t\tCASE WHEN s.color IS NULL THEN o.color ELSE s.color END AS color, s.is_active, s.data_upload_id,\n\t\tCASE WHEN s.multiple_entrance IS NULL THEN o.multiple_entrance END AS multiple_entrance,\n\t\tCASE WHEN s.sensitivity IS NULL THEN o.sensitivity END AS sensitivity\n\t\tFROM (\n\t\t\tSELECT x.*, g."group" \n\t\t\tFROM basic.opportunity_default_config x, basic.opportunity_group g\n\t\t\tWHERE g.id = x.opportunity_group_id\n\t\t) o \n\t\tFULL JOIN first_combination s \n\t\tON o.category = s.category \n\t)\n\tSELECT s.category, s."group", s.icon, s.color, s.multiple_entrance, s.data_upload_id, s.sensitivity \n\tFROM second_combination s \n\tWHERE (is_active IS NULL OR is_active IS TRUE); \n\nEND ;\n$function$\n\n/*\nSELECT * FROM basic.active_opportunities(40, 91620000)\n*/'
    )
    op.drop_entity(basic_active_opportunities)

    basic_poi_categories = PGFunction(
        schema="basic",
        signature="poi_categories(user_id_input integer)",
        definition="returns jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tdefault_setting jsonb := basic.select_customization('poi_groups');\n\tuser_setting jsonb := basic.select_user_customization(user_id_input, 'poi_groups');\n\tclassified_pois jsonb; \nBEGIN \n\t\n\tDROP TABLE IF EXISTS poi_groups_default; \n\tCREATE TEMP TABLE poi_groups_default AS \n\tWITH poi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(default_setting) poi_group\n\t)\n\tSELECT jsonb_array_elements(p.poi_group -> jsonb_object_keys(p.poi_group) -> 'children') AS poi_category \n\tFROM poi_groups p;\n\n\tDROP TABLE IF EXISTS poi_groups_user; \n\tCREATE TEMP TABLE poi_groups_user AS \n\tWITH poi_groups AS \n\t(\n\t\tSELECT jsonb_array_elements(user_setting) poi_group\n\t)\n\tSELECT jsonb_array_elements(p.poi_group -> jsonb_object_keys(p.poi_group) -> 'children') AS poi_category \n\tFROM poi_groups p; \n\t\n\tclassified_pois = (\n\t\tWITH poi_categories AS \n\t\t(\t\n\t\t\tSELECT jsonb_object_keys(p.poi_category) AS poi_category, (p.poi_category -> jsonb_object_keys(p.poi_category) -> 'multiple_entrance') AS multiple_entrance \n\t\t\tFROM poi_groups_default p\n\t\t\tUNION ALL \n\t\t\tSELECT jsonb_object_keys(p.poi_category) AS poi_category, (p.poi_category -> jsonb_object_keys(p.poi_category) -> 'multiple_entrance') AS multiple_entrance \n\t\t\tFROM poi_groups_user p\n\t\t),\n\t\t\n\t\tpoi_classified AS \n\t\t(\n\t\t\tSELECT COALESCE(multiple_entrance::BOOLEAN, FALSE) multiple_entrance, array_agg(poi_category) arr_pois \n\t\t\tFROM (SELECT DISTINCT * FROM poi_categories) p \n\t\t\tGROUP BY multiple_entrance\n\t\t) \n\t\tSELECT jsonb_object_agg(multiple_entrance, arr_pois)\n\t\tFROM poi_classified\n\t); \n\tRETURN classified_pois; \nEND ;\n$function$"
    )
    op.replace_entity(basic_poi_categories)
    basic_poi_categories_data_uploads = PGFunction(
        schema="basic",
        signature="poi_categories_data_uploads(user_id_input integer)",
        definition="returns text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tupload_ids integer[];\n\tarea_id integer;\n\tupload_id integer; \n\tpoi_user_category TEXT;\n\tcategories text[] := '{}'::TEXT[];\nBEGIN \n\tSELECT u.active_data_upload_ids, u.active_study_area_id  \n\tINTO upload_ids, area_id \n\tFROM customer.USER u \n\tWHERE u.id = user_id_input;\n\n\tFOREACH upload_id IN ARRAY upload_ids \n\tLOOP\n\t\tSELECT category \n\t\tINTO poi_user_category \n\t\tFROM customer.poi_user p, customer.data_upload d\n\t\tWHERE p.data_upload_id = upload_id \n\t\tAND p.data_upload_id = d.id \n\t\tAND d.study_area_id = area_id  \n\t\tLIMIT 1; \n\t\t\n\t\tIF poi_user_category IS NOT NULL THEN  \n\t\t\tcategories = array_append(categories, poi_user_category );\n\t\tEND IF; \n\t\n\tEND LOOP;\n\t\n\tRETURN COALESCE(categories, '{}'::TEXT[]);\n\nEND ;\n$function$"
    )
    op.replace_entity(basic_poi_categories_data_uploads)
    # ### end Alembic commands ###
