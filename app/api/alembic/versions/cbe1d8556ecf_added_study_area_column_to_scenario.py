"""added study area column to scenario

Revision ID: cbe1d8556ecf
Revises: 3da99e981cec
Create Date: 2022-03-23 15:32:33.959319

"""
from alembic import op
import sqlalchemy as sa
import geoalchemy2
import sqlmodel  

from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text
from alembic_utils.pg_grant_table import PGGrantTable
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision = 'cbe1d8556ecf'
down_revision = '3da99e981cec'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('scenario', sa.Column('study_area_id', sa.Integer(), nullable=False), schema='customer')
    op.create_foreign_key(None, 'scenario', 'study_area', ['study_area_id'], ['id'], source_schema='customer', referent_schema='basic')
    basic_thematic_data_sum = PGFunction(
        schema="basic",
        signature="thematic_data_sum(user_id_input integer, input_isochrone_calculation_id integer, modus text, scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE(isochrone_feature_id integer, isochrone_feature_step integer, isochrone_feature_reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tpois_one_entrance jsonb = poi_categories -> 'false'; \n\tpois_more_entrance jsonb = poi_categories -> 'true';\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\texcluded_buildings_id integer[] := ARRAY[]::integer[];\nBEGIN \t\t\n\n\tIF modus = 'scenario' THEN\n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\tEND IF;\n\n    --Calculate reached AOIs\n\tDROP TABLE IF EXISTS reached_aois; \n\tCREATE TEMP TABLE reached_aois AS  \n\tWITH area_cnt AS \n\t(\n\t\tSELECT i.id, a.category, count(*) as cnt, intersec.area \n\t\tFROM customer.isochrone_feature i, basic.aoi a, \n\t\tLATERAL (SELECT ST_Area(st_intersection(i.geom,a.geom)::geography)::integer area) AS intersec  \n\t\tWHERE isochrone_calculation_id  = input_isochrone_calculation_id\n\t\tAND st_intersects(i.geom,a.geom)\n\t\tGROUP BY i.id, category, name, intersec.area\n\t),\n\tjson_area_cnt AS\n\t(\n\t\tSELECT p.id, p.category, jsonb_build_object('cnt',sum(cnt),'area',sum(area)) AS aois_json\n\t\tFROM area_cnt p \n\t\tGROUP BY p.id, p.category\n\t)\n\tSELECT j.id, jsonb_object_agg(category, aois_json) aois_json_agg\n\tFROM json_area_cnt j\n\tGROUP BY j.id; \n\t\n\n\tDROP TABLE IF EXISTS reached_opportunities; \n\tCREATE TEMP TABLE reached_opportunities \n\t(\n\t\tid integer,\n\t\topportunity_type TEXT, \n\t\tcnt integer\n\t);\n\n\t--Calculate reached population \n\tINSERT INTO reached_opportunities\n\tWITH temp_sum AS \n\t(\n\t\tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM basic.population p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n     \tUNION ALL \n     \tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM customer.population_modified p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.scenario_id = scenario_id_input \n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t)\n\tSELECT s.id, 'sum_pop', sum(s.population)::integer+(5-(sum(s.population)::integer % 5)) as sum_pop \n\tFROM temp_sum s     \t     \n\tGROUP BY s.id; \n\n\t--Calculate reached POIs one entrance \n\tINSERT INTO reached_opportunities\n\tSELECT i.id, s.category, count(*)\n \tFROM customer.isochrone_feature i\n \tCROSS JOIN LATERAL \n\t(\n\t\tSELECT p.category, i.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id \n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.scenario_id = scenario_id_input \n\t) s\n\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n\tGROUP BY category, i.id;\n\n\t--Calculate reached POIs more entrances \n\tINSERT INTO reached_opportunities\n\tWITH more_entrances AS \n\t(\n\t\tSELECT s.category, i.id\n\t \tFROM customer.isochrone_feature i\n\t \tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM basic.poi p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM customer.poi_user p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids)) \n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id \n\t\t\tFROM customer.poi_modified p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t\tGROUP BY name, category, i.id\n\t)\n\tSELECT m.id, m.category, count(*) \n\tFROM more_entrances m \n\tGROUP BY m.category, m.id;\n\n\tRETURN QUERY \n\tWITH group_reached_opportunities AS \n\t(\n\t\tSELECT r.id, jsonb_object_agg(opportunity_type, cnt) reached_opportunities  \n\t\tFROM reached_opportunities r \n\t\tGROUP BY id \n\t),\n\tcombined_opportunities AS \n\t(\n\t\tSELECT COALESCE(g.id, r.id) AS id, COALESCE(reached_opportunities, '{}'::jsonb) || COALESCE(aois_json_agg, '{}'::jsonb) AS reached_opportunities \n\t\tFROM group_reached_opportunities g\n\t\tFULL JOIN reached_aois r  \n\t\tON r.id = g.id \n\t)\n\tUPDATE customer.isochrone_feature i  \n\tSET reached_opportunities = c.reached_opportunities \n\tFROM combined_opportunities c \n\tWHERE i.id = c.id\n\tRETURNING i.id, i.step, i.reached_opportunities; \nEND ;\n$function$\n/*Intersects the isochrone with opportunity data-sets to produce cumulative opportunities*/\n/*\nSELECT * FROM basic.thematic_data_sum(3, 61, 'default', 0, ARRAY[0])\n*/"
    )
    op.replace_entity(basic_thematic_data_sum)

    public_buf_postgres_insert = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='INSERT', with_grant_option=True)
    op.drop_entity(public_buf_postgres_insert)

    public_buf_postgres_references = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='REFERENCES', with_grant_option=True)
    op.drop_entity(public_buf_postgres_references)

    public_buf_postgres_select = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='SELECT', with_grant_option=True)
    op.drop_entity(public_buf_postgres_select)

    public_buf_postgres_update = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='UPDATE', with_grant_option=True)
    op.drop_entity(public_buf_postgres_update)

    public_distinct_intersection_existing_network_postgres_insert = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='INSERT', with_grant_option=True)
    op.drop_entity(public_distinct_intersection_existing_network_postgres_insert)

    public_distinct_intersection_existing_network_postgres_references = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='REFERENCES', with_grant_option=True)
    op.drop_entity(public_distinct_intersection_existing_network_postgres_references)

    public_distinct_intersection_existing_network_postgres_select = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='SELECT', with_grant_option=True)
    op.drop_entity(public_distinct_intersection_existing_network_postgres_select)

    public_distinct_intersection_existing_network_postgres_update = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='UPDATE', with_grant_option=True)
    op.drop_entity(public_distinct_intersection_existing_network_postgres_update)

    public_test_postgres_insert = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='INSERT', with_grant_option=True)
    op.drop_entity(public_test_postgres_insert)

    public_test_postgres_references = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='REFERENCES', with_grant_option=True)
    op.drop_entity(public_test_postgres_references)

    public_test_postgres_select = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='SELECT', with_grant_option=True)
    op.drop_entity(public_test_postgres_select)

    public_test_postgres_update = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='UPDATE', with_grant_option=True)
    op.drop_entity(public_test_postgres_update)

    public_test_postgres_delete = PGGrantTable(schema='public', table='test', columns=[], role='postgres', grant='DELETE', with_grant_option=True)
    op.drop_entity(public_test_postgres_delete)

    public_test_postgres_truncate = PGGrantTable(schema='public', table='test', columns=[], role='postgres', grant='TRUNCATE', with_grant_option=True)
    op.drop_entity(public_test_postgres_truncate)

    public_test_postgres_trigger = PGGrantTable(schema='public', table='test', columns=[], role='postgres', grant='TRIGGER', with_grant_option=True)
    op.drop_entity(public_test_postgres_trigger)

    public_buf_postgres_delete = PGGrantTable(schema='public', table='buf', columns=[], role='postgres', grant='DELETE', with_grant_option=True)
    op.drop_entity(public_buf_postgres_delete)

    public_buf_postgres_truncate = PGGrantTable(schema='public', table='buf', columns=[], role='postgres', grant='TRUNCATE', with_grant_option=True)
    op.drop_entity(public_buf_postgres_truncate)

    public_buf_postgres_trigger = PGGrantTable(schema='public', table='buf', columns=[], role='postgres', grant='TRIGGER', with_grant_option=True)
    op.drop_entity(public_buf_postgres_trigger)

    public_distinct_intersection_existing_network_postgres_delete = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=[], role='postgres', grant='DELETE', with_grant_option=True)
    op.drop_entity(public_distinct_intersection_existing_network_postgres_delete)

    public_distinct_intersection_existing_network_postgres_truncate = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=[], role='postgres', grant='TRUNCATE', with_grant_option=True)
    op.drop_entity(public_distinct_intersection_existing_network_postgres_truncate)

    public_distinct_intersection_existing_network_postgres_trigger = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=[], role='postgres', grant='TRIGGER', with_grant_option=True)
    op.drop_entity(public_distinct_intersection_existing_network_postgres_trigger)

    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    public_distinct_intersection_existing_network_postgres_trigger = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=[], role='postgres', grant='TRIGGER', with_grant_option=True)
    op.create_entity(public_distinct_intersection_existing_network_postgres_trigger)

    public_distinct_intersection_existing_network_postgres_truncate = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=[], role='postgres', grant='TRUNCATE', with_grant_option=True)
    op.create_entity(public_distinct_intersection_existing_network_postgres_truncate)

    public_distinct_intersection_existing_network_postgres_delete = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=[], role='postgres', grant='DELETE', with_grant_option=True)
    op.create_entity(public_distinct_intersection_existing_network_postgres_delete)

    public_buf_postgres_trigger = PGGrantTable(schema='public', table='buf', columns=[], role='postgres', grant='TRIGGER', with_grant_option=True)
    op.create_entity(public_buf_postgres_trigger)

    public_buf_postgres_truncate = PGGrantTable(schema='public', table='buf', columns=[], role='postgres', grant='TRUNCATE', with_grant_option=True)
    op.create_entity(public_buf_postgres_truncate)

    public_buf_postgres_delete = PGGrantTable(schema='public', table='buf', columns=[], role='postgres', grant='DELETE', with_grant_option=True)
    op.create_entity(public_buf_postgres_delete)

    public_test_postgres_trigger = PGGrantTable(schema='public', table='test', columns=[], role='postgres', grant='TRIGGER', with_grant_option=True)
    op.create_entity(public_test_postgres_trigger)

    public_test_postgres_truncate = PGGrantTable(schema='public', table='test', columns=[], role='postgres', grant='TRUNCATE', with_grant_option=True)
    op.create_entity(public_test_postgres_truncate)

    public_test_postgres_delete = PGGrantTable(schema='public', table='test', columns=[], role='postgres', grant='DELETE', with_grant_option=True)
    op.create_entity(public_test_postgres_delete)

    public_test_postgres_update = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='UPDATE', with_grant_option=True)
    op.create_entity(public_test_postgres_update)

    public_test_postgres_select = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='SELECT', with_grant_option=True)
    op.create_entity(public_test_postgres_select)

    public_test_postgres_references = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='REFERENCES', with_grant_option=True)
    op.create_entity(public_test_postgres_references)

    public_test_postgres_insert = PGGrantTable(schema='public', table='test', columns=['coordinates_3857', 'cost', 'death_end', 'geom', 'id', 'length_3857', 'reverse_cost', 'source', 'starting_geoms', 'starting_ids', 'target'], role='postgres', grant='INSERT', with_grant_option=True)
    op.create_entity(public_test_postgres_insert)

    public_distinct_intersection_existing_network_postgres_update = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='UPDATE', with_grant_option=True)
    op.create_entity(public_distinct_intersection_existing_network_postgres_update)

    public_distinct_intersection_existing_network_postgres_select = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='SELECT', with_grant_option=True)
    op.create_entity(public_distinct_intersection_existing_network_postgres_select)

    public_distinct_intersection_existing_network_postgres_references = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='REFERENCES', with_grant_option=True)
    op.create_entity(public_distinct_intersection_existing_network_postgres_references)

    public_distinct_intersection_existing_network_postgres_insert = PGGrantTable(schema='public', table='distinct_intersection_existing_network', columns=['geom', 'id'], role='postgres', grant='INSERT', with_grant_option=True)
    op.create_entity(public_distinct_intersection_existing_network_postgres_insert)

    public_buf_postgres_update = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='UPDATE', with_grant_option=True)
    op.create_entity(public_buf_postgres_update)

    public_buf_postgres_select = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='SELECT', with_grant_option=True)
    op.create_entity(public_buf_postgres_select)

    public_buf_postgres_references = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='REFERENCES', with_grant_option=True)
    op.create_entity(public_buf_postgres_references)

    public_buf_postgres_insert = PGGrantTable(schema='public', table='buf', columns=['geom'], role='postgres', grant='INSERT', with_grant_option=True)
    op.create_entity(public_buf_postgres_insert)

    basic_thematic_data_sum = PGFunction(
        schema="basic",
        signature="thematic_data_sum(user_id_input integer, input_isochrone_calculation_id integer, modus text, scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE(isochrone_feature_id integer, isochrone_feature_step integer, isochrone_feature_reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tpois_one_entrance jsonb = poi_categories -> 'false'; \n\tpois_more_entrance jsonb = poi_categories -> 'true';\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\texcluded_buildings_id integer[] := ARRAY[]::integer[];\nBEGIN \t\t\n\n\tIF modus = 'scenario' THEN\n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\tEND IF;\n\n    --Calculate reached AOIs\n\tDROP TABLE IF EXISTS reached_aois; \n\tCREATE TEMP TABLE reached_aois AS  \n\tWITH area_cnt AS \n\t(\n\t\tSELECT i.id, a.category, count(*) as cnt, intersec.area \n\t\tFROM customer.isochrone_feature i, basic.aoi a, \n\t\tLATERAL (SELECT ST_Area(st_intersection(i.geom,a.geom)::geography)::integer area) AS intersec  \n\t\tWHERE isochrone_calculation_id  = input_isochrone_calculation_id\n\t\tAND st_intersects(i.geom,a.geom)\n\t\tGROUP BY i.id, category, name, intersec.area\n\t),\n\tjson_area_cnt AS\n\t(\n\t\tSELECT p.id, p.category, jsonb_build_object('cnt',sum(cnt),'area',sum(area)) AS aois_json\n\t\tFROM area_cnt p \n\t\tGROUP BY p.id, p.category\n\t)\n\tSELECT j.id, jsonb_object_agg(category, aois_json) aois_json_agg\n\tFROM json_area_cnt j\n\tGROUP BY j.id; \n\t\n\n\tDROP TABLE IF EXISTS reached_opportunities; \n\tCREATE TEMP TABLE reached_opportunities \n\t(\n\t\tid integer,\n\t\topportunity_type TEXT, \n\t\tcnt integer\n\t);\n\n\t--Calculate reached population \n\tINSERT INTO reached_opportunities\n\tWITH temp_sum AS \n\t(\n\t\tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM basic.population p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n     \tUNION ALL \n     \tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM customer.population_modified p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.scenario_id = scenario_id_input \n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t)\n\tSELECT s.id, 'sum_pop', sum(s.population)::integer+(5-(sum(s.population)::integer % 5)) as sum_pop \n\tFROM temp_sum s     \t     \n\tGROUP BY s.id; \n\n\t--Calculate reached POIs one entrance \n\tINSERT INTO reached_opportunities\n\tSELECT i.id, s.category, count(*)\n \tFROM customer.isochrone_feature i\n \tCROSS JOIN LATERAL \n\t(\n\t\tSELECT p.category, i.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id \n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.scenario_id = scenario_id_input \n\t) s\n\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n\tGROUP BY category, i.id;\n\n\t--Calculate reached POIs more entrances \n\tINSERT INTO reached_opportunities\n\tWITH more_entrances AS \n\t(\n\t\tSELECT s.category, i.id\n\t \tFROM customer.isochrone_feature i\n\t \tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM basic.poi p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM customer.poi_user p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids)) \n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id \n\t\t\tFROM customer.poi_modified p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t\tGROUP BY name, category, i.id\n\t)\n\tSELECT m.id, m.category, count(*) \n\tFROM more_entrances m \n\tGROUP BY m.category, m.id;\n\t\n\tRAISE NOTICE '%', active_upload_ids; \n\tRETURN QUERY \n\tWITH group_reached_opportunities AS \n\t(\n\t\tSELECT r.id, jsonb_object_agg(opportunity_type, cnt) reached_opportunities  \n\t\tFROM reached_opportunities r \n\t\tGROUP BY id \n\t),\n\tcombined_opportunities AS \n\t(\n\t\tSELECT COALESCE(g.id, r.id) AS id, COALESCE(reached_opportunities, '{}'::jsonb) || COALESCE(aois_json_agg, '{}'::jsonb) AS reached_opportunities \n\t\tFROM group_reached_opportunities g\n\t\tFULL JOIN reached_aois r  \n\t\tON r.id = g.id \n\t)\n\tUPDATE customer.isochrone_feature i  \n\tSET reached_opportunities = c.reached_opportunities \n\tFROM combined_opportunities c \n\tWHERE i.id = c.id\n\tRETURNING i.id, i.step, i.reached_opportunities; \nEND ;\n$function$"
    )
    op.replace_entity(basic_thematic_data_sum)
    op.drop_constraint(None, 'scenario', schema='customer', type_='foreignkey')
    op.drop_column('scenario', 'study_area_id', schema='customer')
    # ### end Alembic commands ###
