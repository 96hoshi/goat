"""added some functions

Revision ID: 70814d19d9d2
Revises: bb4e1cdba3a7
Create Date: 2022-05-02 20:59:08.467009

"""
from alembic import op
import sqlalchemy as sa
import geoalchemy2
import sqlmodel  

from alembic_utils.pg_function import PGFunction
from sqlalchemy import text as sql_text
from alembic_utils.pg_grant_table import PGGrantTable
from sqlalchemy import text as sql_text

# revision identifiers, used by Alembic.
revision = '70814d19d9d2'
down_revision = 'bb4e1cdba3a7'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_constraint('opportunity_user_config_user_id_fkey1', 'opportunity_user_config', schema='customer', type_='foreignkey')
    basic_poi_categories_data_uploads = PGFunction(
        schema="basic",
        signature="poi_categories_data_uploads(user_id_input integer)",
        definition="returns text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tupload_ids integer[];\n\tarea_id integer;\n\tupload_id integer; \n\tpoi_user_category TEXT;\n\tcategories text[] := '{}'::TEXT[];\nBEGIN \n\tSELECT u.active_data_upload_ids, u.active_study_area_id  \n\tINTO upload_ids, area_id \n\tFROM customer.USER u \n\tWHERE u.id = user_id_input;\n\n\tFOREACH upload_id IN ARRAY upload_ids \n\tLOOP\n\t\tSELECT category \n\t\tINTO poi_user_category \n\t\tFROM customer.poi_user p, customer.data_upload d\n\t\tWHERE p.data_upload_id = upload_id \n\t\tAND p.data_upload_id = d.id \n\t\tAND d.study_area_id = area_id  \n\t\tLIMIT 1; \n\t\t\n\t\tIF poi_user_category IS NOT NULL THEN  \n\t\t\tcategories = array_append(categories, poi_user_category );\n\t\tEND IF; \n\t\n\tEND LOOP;\n\t\n\tRETURN COALESCE(categories, '{}'::TEXT[]);\n\nEND ;\n$function$\n\n/*\nSELECT * FROM basic.poi_categories_data_uploads(4)\n*/"
    )
    op.replace_entity(basic_poi_categories_data_uploads)

    basic_heatmap_population = PGFunction(
        schema="basic",
        signature="heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default', scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population float, percentile_population integer, modus text, geom geometry)\nLANGUAGE plpgsql\nAS $function$\nBEGIN \n\t\n\tIF modus_input IN ('default', 'comparison') THEN \n\t\tDROP TABLE IF EXISTS population_default;\n\t\tCREATE TEMP TABLE population_default AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'default', scenario_id_input);\n\tEND IF; \n\tIF modus_input IN ('scenario','comparison') THEN \n\t\tDROP TABLE IF EXISTS population_scenario;\n\t\tCREATE TEMP TABLE population_scenario AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'scenario', scenario_id_input);\n\tEND IF;\n\tIF modus_input IN ('comparison') THEN \n\t\tALTER TABLE population_default ADD PRIMARY KEY(grid_visualization_id); \n\t\tALTER TABLE population_scenario ADD PRIMARY KEY(grid_visualization_id); \n\t\tDROP TABLE IF EXISTS population_comparison;\n\t\t\n\t\tCREATE TEMP TABLE population_comparison AS \n\t\tWITH pop_difference AS \n\t\t(\n\t\t\tSELECT d.grid_visualization_id, (COALESCE(s.population,0) - COALESCE(d.population,0)) AS population, d.geom\n\t\t\tFROM population_default d, population_scenario s\n\t\t\tWHERE d.grid_visualization_id = s.grid_visualization_id\n\t\t) \n\t\tSELECT p.grid_visualization_id, p.population, \n\t\tCASE \n\t\tWHEN p.population = 0 THEN 0\n\t\tWHEN p.population < -400 THEN -5 \n\t\tWHEN p.population BETWEEN -400 AND -200 THEN -4 \n\t\tWHEN p.population BETWEEN -200 AND -80 THEN -3 \n\t\tWHEN p.population BETWEEN -80 AND -20 THEN -2 \n\t\tWHEN p.population BETWEEN -20 AND -1 THEN -1 \n\t\tWHEN p.population BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN p.population BETWEEN 20 AND 80 THEN 2\n\t\tWHEN p.population BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN p.population BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN p.population  > 400 THEN 5 END AS percentile_population, p.geom \n\t\tFROM pop_difference p;\n\tEND IF; \n\t\t\n\tIF modus_input = 'default' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, COALESCE(p.percentile_population, 0), modus_input AS modus, p.geom \n\t\tFROM population_default p;\n\tELSEIF modus_input = 'scenario' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, COALESCE(p.percentile_population, 0), modus_input AS modus, p.geom \n\t\tFROM population_scenario p;\n\tELSEIF modus_input = 'comparison' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, COALESCE(p.percentile_population, 0), modus_input AS modus, p.geom \n\t\tFROM population_comparison p;\n\tEND IF; \n\nEND\n$function$;\n\n/*\nDROP TABLE IF EXISTS default_pop;\nCREATE TABLE default_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'default',0)\n\nDROP TABLE IF EXISTS scenario_pop;\nCREATE TABLE scenario_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'scenario',13)\n\nDROP TABLE IF EXISTS comparison_pop;\nCREATE TABLE comparison_pop AS \nSELECT * \nFROM basic.heatmap_population(1,'comparison',13)\n*/"
    )
    op.replace_entity(basic_heatmap_population)

    basic_reached_population_study_area = PGFunction(
        schema="basic",
        signature="reached_population_study_area(ischrone_calculation_id_input integer, scenario_id_input integer, modus text, study_area_ids integer[])",
        definition="returns TABLE(id integer, step integer, reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[] := '{}'::integer[];\nBEGIN\n\t\n\tDROP TABLE IF EXISTS reachable_population; \n\n\t/*Get reachable population*/\n\tIF modus = 'default' THEN\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tSELECT i.id AS isochrone_feature_id, s.id AS sub_study_area_id, s.name, s.population \n\t\tFROM basic.sub_study_area s, customer.isochrone_feature i \n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids))\n\t\tAND i.isochrone_calculation_id = ischrone_calculation_id_input; \n\t\n\tELSEIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT p.sub_study_area_id, -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tGROUP BY p.sub_study_area_id \n\t\t\tUNION ALL \n\t\t\tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t \t),\n\t \tscenario_population AS \n\t \t(\n\t\t \tSELECT p.sub_study_area_id, sum(population) population \n\t\t \tFROM prepared_scenario p \n\t\t \tGROUP BY p.sub_study_area_id\n\t\t),\n\t\tcombined_population AS \n\t\t( \n\t\t\tSELECT s.id AS sub_study_area_id, s.name, (s.population + COALESCE(sp.population, 0)) AS population \n\t\t\tFROM basic.sub_study_area s\n\t\t\tLEFT JOIN scenario_population sp \n\t\t\tON s.id = sp.sub_study_area_id\n\t\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)) \t\n\t\t)\n\t\tSELECT i.id AS isochrone_feature_id, c.*\n\t\tFROM customer.isochrone_feature i, combined_population c\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input; \n\tELSE \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input \n\t)\n\tSELECT g.id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population, g.sub_study_area_id \n\tFROM to_group g\n\tGROUP BY g.id, g.sub_study_area_id; \n\t\n\t/*Combine and return results*/\n\tRETURN query \n\tWITH combined AS \n\t(\n\t\tSELECT a.isochrone_feature_id, a.sub_study_area_id, a.name, \n\t\tCASE WHEN COALESCE(r.population, 0) > a.population THEN a.population \n\t\tELSE COALESCE(r.population, 0) END AS reached_population, a.population AS total_population \n\t\tFROM reachable_population a\n\t\tLEFT JOIN reached_population r \n\t\tON a.isochrone_feature_id = r.id \n\t\tAND a.sub_study_area_id = r.sub_study_area_id\n\t),\n\tas_object AS \n\t(\n\t\tSELECT c.isochrone_feature_id, jsonb_object_agg(c.sub_study_area_id, \n\t\tjsonb_build_object('name', c.name, 'reached_population', c.reached_population::integer, 'total_population', c.total_population::integer)) AS population \n\t\tFROM combined c\n\t\tGROUP BY c.isochrone_feature_id \n\t)\n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = o.population \n\tFROM as_object o \n\tWHERE o.isochrone_feature_id = i.id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n \nEND; \n$function$;\n\n/*\nSELECT * \nFROM basic.reached_population_study_area(39, 2,'default', ARRAY[17,24,26])\n*/"
    )
    op.replace_entity(basic_reached_population_study_area)

    basic_thematic_data_sum = PGFunction(
        schema="basic",
        signature="thematic_data_sum(user_id_input integer, input_isochrone_calculation_id integer, modus text, scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE(isochrone_feature_id integer, isochrone_feature_step integer, isochrone_feature_reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tpois_one_entrance jsonb = poi_categories -> 'false'; \n\tpois_more_entrance jsonb = poi_categories -> 'true';\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\texcluded_buildings_id integer[] := ARRAY[]::integer[];\n\tdata_upload_poi_categories text[];\nBEGIN \t\t\n\n\tIF modus = 'scenario' THEN\n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\tELSE \n\t\tscenario_id_input = 0;\n\tEND IF;\n\n\tdata_upload_poi_categories = basic.poi_categories_data_uploads(user_id_input);\n    \n\tIF data_upload_poi_categories IS NULL THEN \n    \tdata_upload_poi_categories = '{}'::text[];\n    END IF;\n    --Calculate reached AOIs\n\tDROP TABLE IF EXISTS reached_aois; \n\tCREATE TEMP TABLE reached_aois AS  \n\tWITH area_cnt AS \n\t(\n\t\tSELECT i.id, a.category, count(*) as cnt, intersec.area \n\t\tFROM customer.isochrone_feature i, basic.aoi a, \n\t\tLATERAL (SELECT ST_Area(st_intersection(i.geom,a.geom)::geography)::integer area) AS intersec  \n\t\tWHERE isochrone_calculation_id  = input_isochrone_calculation_id\n\t\tAND st_intersects(i.geom,a.geom)\n\t\tGROUP BY i.id, category, name, intersec.area\n\t),\n\tjson_area_cnt AS\n\t(\n\t\tSELECT p.id, p.category, jsonb_build_object('cnt',sum(cnt),'area',sum(area)) AS aois_json\n\t\tFROM area_cnt p \n\t\tGROUP BY p.id, p.category\n\t)\n\tSELECT j.id, jsonb_object_agg(category, aois_json) aois_json_agg\n\tFROM json_area_cnt j\n\tGROUP BY j.id; \n\t\n\n\tDROP TABLE IF EXISTS reached_opportunities; \n\tCREATE TEMP TABLE reached_opportunities \n\t(\n\t\tid integer,\n\t\topportunity_type TEXT, \n\t\tcnt integer\n\t);\n\n\t--Calculate reached population \n\tINSERT INTO reached_opportunities\n\tWITH temp_sum AS \n\t(\n\t\tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM basic.population p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n     \tUNION ALL \n     \tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM customer.population_modified p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.scenario_id = scenario_id_input \n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t)\n\tSELECT s.id, 'sum_pop', sum(s.population)::integer+(5-(sum(s.population)::integer % 5)) as sum_pop \n\tFROM temp_sum s     \t     \n\tGROUP BY s.id; \n\n\t--Calculate reached POIs one entrance \n\tINSERT INTO reached_opportunities\n\tSELECT i.id, s.category, count(*)\n \tFROM customer.isochrone_feature i\n \tCROSS JOIN LATERAL \n\t(\n\t\tSELECT p.category, i.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id \n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.scenario_id = scenario_id_input \n\t) s\n\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n\tGROUP BY category, i.id;\n\n\t--Calculate reached POIs more entrances \n\tINSERT INTO reached_opportunities\n\tWITH more_entrances AS \n\t(\n\t\tSELECT s.category, i.id\n\t \tFROM customer.isochrone_feature i\n\t \tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM basic.poi p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM customer.poi_user p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids)) \n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id \n\t\t\tFROM customer.poi_modified p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t\tGROUP BY name, category, i.id\n\t)\n\tSELECT m.id, m.category, count(*) \n\tFROM more_entrances m \n\tGROUP BY m.category, m.id;\n\n\tRETURN QUERY \n\tWITH group_reached_opportunities AS \n\t(\n\t\tSELECT r.id, jsonb_object_agg(opportunity_type, cnt) reached_opportunities  \n\t\tFROM reached_opportunities r \n\t\tGROUP BY id \n\t),\n\tcombined_opportunities AS \n\t(\n\t\tSELECT COALESCE(g.id, r.id) AS id, COALESCE(reached_opportunities, '{}'::jsonb) || COALESCE(aois_json_agg, '{}'::jsonb) AS reached_opportunities \n\t\tFROM group_reached_opportunities g\n\t\tFULL JOIN reached_aois r  \n\t\tON r.id = g.id \n\t)\n\tUPDATE customer.isochrone_feature i  \n\tSET reached_opportunities = c.reached_opportunities \n\tFROM combined_opportunities c \n\tWHERE i.id = c.id\n\tRETURNING i.id, i.step, i.reached_opportunities; \nEND ;\n$function$;\n\n/* Example with starting point to find study_area\nSELECT * FROM basic.count_pois_multi_isochrones(1,'scenario',10,1.33,'study_area',\n'POINT(11.570115749093093 48.15360025891228)', ARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 1, ARRAY[3]);\n \n * Example with drawn polygon\nSELECT * FROM basic.count_pois_multi_isochrones(1,'scenario',10,1.33,'draw',\n'POLYGON ((11.570115749093093 48.15360025891228, 11.570274296106232 48.1518693270582, 11.572708788648153 48.15118483030911, 11.574984827528402 48.15223125586774, 11.574826384986741 48.15396220424526, 11.57239179909107 48.154646710542, 11.570115749093093 48.15360025891228))',\nARRAY['bar','restaurant','pub','french_supermarket','fancy_market'], 1, ARRAY[3]);\n */"
    )
    op.replace_entity(basic_thematic_data_sum)

    basic_poi_aoi_visualization = PGFunction(
        schema="basic",
        signature="poi_aoi_visualization(user_id_input integer, scenario_id_input integer, active_upload_ids integer[], active_study_area_id integer)",
        definition="returns TABLE (id integer, uid TEXT, category TEXT, name TEXT, opening_hours TEXT, street TEXT, housenumber TEXT, zipcode TEXT, edit_type TEXT, geom geometry)\nLANGUAGE plpgsql\nAS $function$\nDECLARE \t\n\taoi_categories TEXT[]; \n\tdata_upload_poi_categories TEXT[] = '{}'::TEXT[];\n\tall_poi_categories text[];\n\texcluded_pois_id text[] := '{}'::text[]; \n\tbuffer_geom_study_area geometry; \nBEGIN\n\tdata_upload_poi_categories = basic.poi_categories_data_uploads(user_id_input);\n\tactive_study_area_id = (SELECT u.active_study_area_id FROM customer.user u WHERE u.id = user_id_input);\n\t/*Get combined poi categories*/\n\tSELECT array_agg(o.category) \n\tINTO all_poi_categories \n\tFROM basic.active_opportunities(user_id_input, active_study_area_id) o, basic.opportunity_group g \n\tWHERE o.category_group = g.GROUP \n\tAND g.TYPE = 'poi';\n\n\t/*Prepare AOI categories*/\n\tSELECT ARRAY_AGG(o.category) \n\tINTO aoi_categories\n\tFROM basic.active_opportunities(user_id_input, active_study_area_id) o, basic.opportunity_group g \n\tWHERE o.category_group = g.GROUP \n\tAND g.TYPE = 'aoi'; \n\n\t/*Check if POI scenario*/\n\tIF scenario_id_input <> 0 THEN \n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\tEND IF; \n\t/*Buffer study area to avoid border effects*/\n\tbuffer_geom_study_area = (SELECT buffer_geom_heatmap AS geom FROM basic.study_area s WHERE s.id = active_study_area_id);\n\n    RETURN query\n   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM basic.poi p\n\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area\n\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\tRETURN query \n\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM customer.poi_user p\n\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\t/*No scenarios nor aoi_user is implemented at the moment*/\n\tSELECT p.id, NULL, p.category, p.name, p.opening_hours, NULL AS street, NULL AS housenumber, NULL AS zipcode, NULL AS edit_type, p.geom\n\tFROM basic.aoi p \n\tWHERE p.category IN (SELECT UNNEST(aoi_categories))\n\tAND p.geom && buffer_geom_study_area; \n\t\n\tIF scenario_id_input <> 0 THEN \n\t   \tRETURN query \n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, p.edit_type, p.geom  \n\t\tFROM customer.poi_modified p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.scenario_id = scenario_id_input; \n\t   \t\n\t\tRETURN query\n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM basic.poi p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\t\tRETURN query \n\t\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM customer.poi_user p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\tEND IF; \nEND ;\n$function$;\n\n\n/*\nModus should be default, scenario, comparison\nSELECT * \nFROM basic.poi_aoi_visualization(4, 2, 'default', ARRAY[0], 1)\n*/"
    )
    op.replace_entity(basic_poi_aoi_visualization)

    basic_reached_population_polygon = PGFunction(
        schema="basic",
        signature="reached_population_polygon(ischrone_calculation_id_input integer, scenario_id_input integer, modus TEXT, region TEXT)",
        definition="returns TABLE (isochrone_feature_id integer, step integer, reached_opportunities jsonb)\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[];\n\tregion_geom geometry := ST_SETSRID(ST_GeomFromText(region), 4326);\n\treachable_population integer; \n\treachable_population_default integer; \n\treachable_population_scenario integer;  \nBEGIN\n\t\n\t/*Check if invalid modus*/\n\tIF modus NOT IN ('default','scenario') THEN \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t/*Get reachable population*/\n\tIF modus IN ('default','scenario')  THEN\n\t\tWITH pop AS \n\t\t(\n\t\t\tSELECT COALESCE(SUM(population), 0) population \n\t\t\tFROM basic.population p \n\t\t\tWHERE ST_Intersects(p.geom, region_geom)\n\t\t)\n\t\tSELECT population \n\t\tINTO reachable_population_default\n\t\tFROM pop;\n\t\t\n\tEND IF; \n\t\n\tIF modus = 'default' THEN \n\t\treachable_population = floor((reachable_population_default / 5)*5);\n\tEND IF; \n\n\tIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT COALESCE(-sum(p.population), 0) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE ST_Intersects(p.geom, region_geom)\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tUNION ALL \n\t\t\tSELECT COALESCE(sum(p.population), 0) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE ST_Intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t \t)\n \t\tSELECT COALESCE(sum(population), 0)::integer \n \t\tINTO reachable_population_scenario  \n\t\tFROM prepared_scenario p; \n\t\treachable_population = floor((reachable_population_default  + reachable_population_scenario / 5)*5); \n\t\t\n\tEND IF; \n\n\tIF modus = 'default' THEN \n\t\treachable_population = floor((reachable_population_default / 5)*5);\n\tEND IF; \n\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t),\n\tfinal_population AS \n\t(\t\n\t\tSELECT g.id AS isochrone_feature_id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population\n\t\tFROM to_group g\n\t\tGROUP BY g.id\n\t)\n\tSELECT f.isochrone_feature_id, CASE WHEN f.population > reachable_population THEN reachable_population ELSE f.population END AS population \n\tFROM final_population f;\n\t\n    /*Combine and return results*/\n\tRETURN query \n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = jsonb_build_object('name', 'polygon', 'reached_population', population, 'total_population', reachable_population)  \n\tFROM reached_population r \n\tWHERE i.id = r.isochrone_feature_id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n\nEND; \n$function$ LANGUAGE plpgsql;\n\n/*\nSELECT * \nFROM basic.reached_population_polygon(88, 2, 'default',\n'POLYGON ((11.570115749093093 48.15360025891228, 11.570274296106232 48.1518693270582, 11.572708788648153 48.15118483030911, 11.574984827528402 48.15223125586774, 11.574826384986741 48.15396220424526, 11.57239179909107 48.154646710542, 11.570115749093093 48.15360025891228))') \n*/"
    )
    op.replace_entity(basic_reached_population_polygon)

    basic_prepare_heatmap_population = PGFunction(
        schema="basic",
        signature="prepare_heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default'::text, scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population double precision, percentile_population integer, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_buildings integer[];\nBEGIN \n\t\n\tIF modus_input = 'default' THEN \n\t\tscenario_id_input = 0;\n\tEND IF;\n\tmodified_buildings = basic.modified_buildings(scenario_id_input);\n\tRETURN query\n\tWITH modified_population AS \n\t(\n\t\tSELECT p.geom, -p.population AS population\n\t\tFROM basic.population p \n\t\tWHERE building_id IN (SELECT UNNEST(modified_buildings))\n\t\tUNION ALL \n\t\tSELECT p.geom, p.population \n\t\tFROM customer.population_modified p \n\t\tWHERE p.scenario_id = scenario_id_input \n\t),\n\tsum_pop AS (\n\t\tSELECT g.id, sum(p.population) + COALESCE(g.population,0) population, \n\t\tCASE WHEN sum(p.population) + COALESCE(g.population,0) BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 20 AND 80 THEN 2\n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  > 400 THEN 5 END AS percentile_population, g.geom\n\t\tFROM basic.grid_visualization g, modified_population p, basic.study_area_grid_visualization s\n\t\tWHERE ST_Intersects(g.geom,p.geom)\n\t\tAND p.population IS NOT NULL \n\t\tAND g.id = s.grid_visualization_id \n\t\tAND s.study_area_id = active_study_area_id\n\t\tGROUP BY g.id, g.population, g.geom\n\t) \n\tSELECT s.id AS grid_visualization_id ,s.population, s.percentile_population, s.geom \n\tFROM sum_pop s\n\tUNION ALL \n\tSELECT g.id AS grid_visualization_id, g.population, g.percentile_population, g.geom\n\tFROM \n\t(\n\t\tSELECT g.* \n\t\tFROM basic.grid_visualization  g, basic.study_area_grid_visualization sa\n\t\tWHERE sa.study_area_id = active_study_area_id \n\t\tAND g.id = sa.grid_visualization_id \n\t) g \n\tLEFT JOIN sum_pop s\n\tON g.id = s.id\n\tWHERE s.id IS NULL;\n\t\nEND\n$function$;\n/*\nSELECT * \nFROM basic.prepare_heatmap_population(13)\n*/"
    )
    op.replace_entity(basic_prepare_heatmap_population)

    basic_population_modification = PGFunction(
        schema="basic",
        signature="population_modification(scenario_id_input integer)",
        definition="returns SETOF void\nLANGUAGE plpgsql\nAS $function$\nDECLARE \n\taverage_gross_living_area integer := basic.select_customization('average_gross_living_area');\nBEGIN \n\n\tUPDATE customer.building_modified b\n\tSET area = ST_AREA(geom::geography), \n\tpopulation = (\n\t\tCASE WHEN population IS NULL THEN (b.building_levels_residential * ST_AREA(b.geom::geography) / average_gross_living_area) \n\t\tELSE population END\n\t)\n\tWHERE scenario_id = scenario_id_input; \n\t\n\tWITH count_pop AS (\n\t\tSELECT count(*) AS count_points, building_modified_id \n\t\tFROM customer.population_modified \n\t\tWHERE scenario_id = scenario_id_input\n\t\tGROUP BY building_modified_id  \n\t),\n\tpoints_to_update AS \n\t(\n\t\tSELECT p.id, b.id AS building_modified_id, b.population / c.count_points AS population \n\t\tFROM customer.building_modified b, customer.population_modified p, count_pop c  \n\t\tWHERE b.id = p.building_modified_id  \n\t\tAND b.id = c.building_modified_id  \n\t\tAND b.scenario_id = scenario_id_input\n\t\tAND p.scenario_id = scenario_id_input\n\t\tAND b.building_type = 'residential'\n\t)\n\tUPDATE customer.population_modified p \n\tSET population = u.population \n\tFROM points_to_update u \n\tWHERE p.id = u.id; \n\nEND\n$function$;\n/*\nSELECT basic.population_modification(13)\n*/"
    )
    op.replace_entity(basic_population_modification)
    # ### end Alembic commands ###


def downgrade():
 
    basic_population_modification = PGFunction(
        schema="basic",
        signature="population_modification(scenario_id_input integer)",
        definition="returns SETOF void\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\taverage_gross_living_area integer := basic.select_customization('average_gross_living_area');\nBEGIN \n\n\tUPDATE customer.building_modified b\n\tSET area = ST_AREA(geom::geography), population = (b.building_levels_residential * ST_AREA(b.geom::geography) / average_gross_living_area) \n\tWHERE scenario_id = scenario_id_input; \n\t\n\tWITH count_pop AS (\n\t\tSELECT count(*) AS count_points, building_modified_id \n\t\tFROM customer.population_modified \n\t\tWHERE scenario_id = scenario_id_input\n\t\tGROUP BY building_modified_id  \n\t),\n\tpoints_to_update AS \n\t(\n\t\tSELECT p.id, b.id AS building_modified_id, b.population / c.count_points AS population \n\t\tFROM customer.building_modified b, customer.population_modified p, count_pop c  \n\t\tWHERE b.id = p.building_modified_id  \n\t\tAND b.id = c.building_modified_id  \n\t\tAND b.scenario_id = scenario_id_input\n\t\tAND p.scenario_id = scenario_id_input\n\t\tAND b.building_type = 'residential'\n\t)\n\tUPDATE customer.population_modified p \n\tSET population = u.population \n\tFROM points_to_update u \n\tWHERE p.id = u.id; \n\nEND\n$function$"
    )
    op.replace_entity(basic_population_modification)
    basic_prepare_heatmap_population = PGFunction(
        schema="basic",
        signature="prepare_heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default'::text, scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population double precision, percentile_population integer, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tmodified_buildings integer[] := basic.modified_buildings(scenario_id_input);\nBEGIN \n\t\n\tIF modus_input = 'default' THEN \n\t\tscenario_id_input = 0;\n\tEND IF;\n\t\n\tRETURN query\n\tWITH modified_population AS \n\t(\n\t\tSELECT p.geom, -p.population AS population\n\t\tFROM basic.population p \n\t\tWHERE building_id IN (SELECT UNNEST(modified_buildings))\n\t\tUNION ALL \n\t\tSELECT p.geom, p.population \n\t\tFROM customer.population_modified p \n\t\tWHERE p.scenario_id = scenario_id_input \n\t),\n\tsum_pop AS (\n\t\tSELECT g.id, sum(p.population) + COALESCE(g.population,0) population, \n\t\tCASE WHEN sum(p.population) + COALESCE(g.population,0) BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 20 AND 80 THEN 2\n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN sum(p.population) + COALESCE(g.population,0)  > 400 THEN 5 END AS percentile_population, g.geom\n\t\tFROM basic.grid_visualization g, modified_population p, basic.study_area_grid_visualization s\n\t\tWHERE ST_Intersects(g.geom,p.geom)\n\t\tAND p.population IS NOT NULL \n\t\tAND g.id = s.grid_visualization_id \n\t\tAND s.study_area_id = active_study_area_id\n\t\tGROUP BY g.id, g.population, g.geom\n\t) \n\tSELECT s.id AS grid_visualization_id ,s.population, s.percentile_population, s.geom \n\tFROM sum_pop s\n\tUNION ALL \n\tSELECT g.id AS grid_visualization_id, g.population, g.percentile_population, g.geom\n\tFROM \n\t(\n\t\tSELECT g.* \n\t\tFROM basic.grid_visualization  g, basic.study_area_grid_visualization sa\n\t\tWHERE sa.study_area_id = active_study_area_id \n\t\tAND g.id = sa.grid_visualization_id \n\t) g \n\tLEFT JOIN sum_pop s\n\tON g.id = s.id\n\tWHERE s.id IS NULL;\n\t\nEND\n$function$"
    )
    op.replace_entity(basic_prepare_heatmap_population)
    basic_reached_population_polygon = PGFunction(
        schema="basic",
        signature="reached_population_polygon(ischrone_calculation_id_input integer, scenario_id_input integer, modus text, region text)",
        definition="returns TABLE(isochrone_feature_id integer, step integer, reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[];\n\tregion_geom geometry := ST_SETSRID(ST_GeomFromText(region), 4326);\n\treachable_population integer; \n\treachable_population_default integer; \n\treachable_population_scenario integer;  \nBEGIN\n\t\n\t/*Check if invalid modus*/\n\tIF modus NOT IN ('default','scenario') THEN \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t/*Get reachable population*/\n\tIF modus IN ('default','scenario')  THEN\n\t\tWITH pop AS \n\t\t(\n\t\t\tSELECT SUM(population) population \n\t\t\tFROM basic.population p \n\t\t\tWHERE ST_Intersects(p.geom, region_geom)\n\t\t)\n\t\tSELECT population \n\t\tINTO reachable_population_default\n\t\tFROM pop;\n\t\t\n\tEND IF; \n\t\n\tIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE ST_Intersects(p.geom, region_geom)\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tUNION ALL \n\t\t\tSELECT sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE ST_Intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t \t)\n \t\tSELECT COALESCE(sum(population), 0)::integer \n \t\tINTO reachable_population_scenario  \n\t\tFROM prepared_scenario p; \n\t\n\t\treachable_population = floor((reachable_population_default  + reachable_population_scenario / 5)*5); \n\t\t\n\tEND IF; \n\treachable_population = floor((reachable_population_default / 5)*5);\n\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND st_intersects(p.geom, region_geom)\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t),\n\tfinal_population AS \n\t(\t\n\t\tSELECT g.id AS isochrone_feature_id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population\n\t\tFROM to_group g\n\t\tGROUP BY g.id\n\t)\n\tSELECT f.isochrone_feature_id, CASE WHEN f.population > reachable_population THEN reachable_population ELSE f.population END AS population \n\tFROM final_population f;\n\t\n    /*Combine and return results*/\n\tRETURN query \n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = jsonb_build_object('name', 'polygon', 'reached_population', population, 'total_population', reachable_population)  \n\tFROM reached_population r \n\tWHERE i.id = r.isochrone_feature_id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n\nEND; \n$function$"
    )
    op.replace_entity(basic_reached_population_polygon)
    basic_poi_aoi_visualization = PGFunction(
        schema="basic",
        signature="poi_aoi_visualization(user_id_input integer, scenario_id_input integer, active_upload_ids integer[], active_study_area_id integer)",
        definition="returns TABLE(id integer, uid text, category text, name text, opening_hours text, street text, housenumber text, zipcode text, edit_type text, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \t\n\taoi_categories TEXT[]; \n\tdata_upload_poi_categories TEXT[] = '{}'::TEXT[];\n\tall_poi_categories text[];\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\tbuffer_geom_study_area geometry; \nBEGIN\n\tdata_upload_poi_categories = basic.poi_categories_data_uploads(user_id_input);\n\t\n\t/*Get combined poi categories*/\n\tSELECT array_agg(o.category) \n\tINTO all_poi_categories \n\tFROM basic.active_opportunities(user_id_input, active_study_area_id) o, basic.opportunity_group g \n\tWHERE o.category_group = g.GROUP \n\tAND g.TYPE = 'poi';\n\n\t/*Prepare AOI categories*/\n\tSELECT ARRAY_AGG(o.category) \n\tINTO aoi_categories\n\tFROM basic.active_opportunities(user_id_input, active_study_area_id) o, basic.opportunity_group g \n\tWHERE o.category_group = g.GROUP \n\tAND g.TYPE = 'aoi'; \n\n\t/*Check if POI scenario*/\n\tIF scenario_id_input <> 0 THEN \n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\tEND IF; \n\t/*Buffer study area to avoid border effects*/\n\tbuffer_geom_study_area = (SELECT buffer_geom_heatmap AS geom FROM basic.study_area s WHERE s.id = active_study_area_id);\n\n    RETURN query\n   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM basic.poi p\n\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area\n\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\tRETURN query \n\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, NULL AS edit_type, p.geom  \n\tFROM customer.poi_user p\n\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\tAND p.geom && buffer_geom_study_area;\n\t\n\tRETURN query \n\t/*No scenarios nor aoi_user is implemented at the moment*/\n\tSELECT p.id, NULL, p.category, p.name, p.opening_hours, NULL AS street, NULL AS housenumber, NULL AS zipcode, NULL AS edit_type, p.geom\n\tFROM basic.aoi p \n\tWHERE p.category IN (SELECT UNNEST(aoi_categories))\n\tAND p.geom && buffer_geom_study_area; \n\t\n\tIF scenario_id_input <> 0 THEN \n\t   \tRETURN query \n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, p.edit_type, p.geom  \n\t\tFROM customer.poi_modified p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.scenario_id = scenario_id_input; \n\t   \t\n\t\tRETURN query\n\t   \tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM basic.poi p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area\n\t\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories));\n\t\n\t\tRETURN query \n\t\tSELECT p.id, p.uid, p.category, p.name, p.opening_hours, p.street, p.housenumber, p.zipcode, 'd' AS edit_type, p.geom  \n\t\tFROM customer.poi_user p\n\t\tWHERE p.category IN (SELECT UNNEST(all_poi_categories))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tAND p.uid IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.geom && buffer_geom_study_area;\n\tEND IF; \nEND ;\n$function$"
    )
    op.replace_entity(basic_poi_aoi_visualization)
    basic_thematic_data_sum = PGFunction(
        schema="basic",
        signature="thematic_data_sum(user_id_input integer, input_isochrone_calculation_id integer, modus text, scenario_id_input integer DEFAULT 0, active_upload_ids integer[] DEFAULT '{}'::integer[])",
        definition="returns TABLE(isochrone_feature_id integer, isochrone_feature_step integer, isochrone_feature_reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tpoi_categories jsonb = basic.poi_categories(user_id_input);\n\tpois_one_entrance jsonb = poi_categories -> 'false'; \n\tpois_more_entrance jsonb = poi_categories -> 'true';\n\texcluded_pois_id text[] := ARRAY[]::text[]; \n\texcluded_buildings_id integer[] := ARRAY[]::integer[];\n\tdata_upload_poi_categories text[];\nBEGIN \t\t\n\n\tIF modus = 'scenario' THEN\n\t\texcluded_pois_id = basic.modified_pois(scenario_id_input);\n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\tEND IF;\n\n\tdata_upload_poi_categories = basic.poi_categories_data_uploads(user_id_input);\n    \n\tIF data_upload_poi_categories IS NULL THEN \n    \tdata_upload_poi_categories = '{}'::text[];\n    END IF;\n    --Calculate reached AOIs\n\tDROP TABLE IF EXISTS reached_aois; \n\tCREATE TEMP TABLE reached_aois AS  \n\tWITH area_cnt AS \n\t(\n\t\tSELECT i.id, a.category, count(*) as cnt, intersec.area \n\t\tFROM customer.isochrone_feature i, basic.aoi a, \n\t\tLATERAL (SELECT ST_Area(st_intersection(i.geom,a.geom)::geography)::integer area) AS intersec  \n\t\tWHERE isochrone_calculation_id  = input_isochrone_calculation_id\n\t\tAND st_intersects(i.geom,a.geom)\n\t\tGROUP BY i.id, category, name, intersec.area\n\t),\n\tjson_area_cnt AS\n\t(\n\t\tSELECT p.id, p.category, jsonb_build_object('cnt',sum(cnt),'area',sum(area)) AS aois_json\n\t\tFROM area_cnt p \n\t\tGROUP BY p.id, p.category\n\t)\n\tSELECT j.id, jsonb_object_agg(category, aois_json) aois_json_agg\n\tFROM json_area_cnt j\n\tGROUP BY j.id; \n\t\n\n\tDROP TABLE IF EXISTS reached_opportunities; \n\tCREATE TEMP TABLE reached_opportunities \n\t(\n\t\tid integer,\n\t\topportunity_type TEXT, \n\t\tcnt integer\n\t);\n\n\t--Calculate reached population \n\tINSERT INTO reached_opportunities\n\tWITH temp_sum AS \n\t(\n\t\tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM basic.population p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n     \tUNION ALL \n     \tSELECT s.population,i.id \n     \tFROM customer.isochrone_feature i\n     \tCROSS JOIN LATERAL \n     \t(\n\t     \tSELECT sum(p.population) AS population\n\t     \tFROM customer.population_modified p \n\t     \tWHERE st_intersects(i.geom,p.geom)\n\t     \tAND p.scenario_id = scenario_id_input \n     \t) s\n     \tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t)\n\tSELECT s.id, 'sum_pop', sum(s.population)::integer+(5-(sum(s.population)::integer % 5)) as sum_pop \n\tFROM temp_sum s     \t     \n\tGROUP BY s.id; \n\n\t--Calculate reached POIs one entrance \n\tINSERT INTO reached_opportunities\n\tSELECT i.id, s.category, count(*)\n \tFROM customer.isochrone_feature i\n \tCROSS JOIN LATERAL \n\t(\n\t\tSELECT p.category, i.id\n\t\tFROM basic.poi p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.category NOT IN (SELECT UNNEST(data_upload_poi_categories))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id\n\t\tFROM customer.poi_user p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids))\n\t\tUNION ALL \n\t\tSELECT p.category, i.id \n\t\tFROM customer.poi_modified p\n\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_one_entrance))\n\t\tAND p.scenario_id = scenario_id_input \n\t) s\n\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\t\n\tGROUP BY category, i.id;\n\n\t--Calculate reached POIs more entrances \n\tINSERT INTO reached_opportunities\n\tWITH more_entrances AS \n\t(\n\t\tSELECT s.category, i.id\n\t \tFROM customer.isochrone_feature i\n\t \tCROSS JOIN LATERAL \n\t\t(\n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM basic.poi p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id\n\t\t\tFROM customer.poi_user p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.uid NOT IN (SELECT UNNEST(excluded_pois_id))\n\t\t\tAND p.data_upload_id IN (SELECT UNNEST(active_upload_ids)) \n\t\t\tUNION ALL \n\t\t\tSELECT p.category, p.name, i.id \n\t\t\tFROM customer.poi_modified p\n\t\t\tWHERE ST_Intersects(i.geom, p.geom)\n\t\t\tAND p.category IN (SELECT jsonb_array_elements_text(pois_more_entrance))\n\t\t\tAND p.scenario_id = scenario_id_input \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = input_isochrone_calculation_id\n\t\tGROUP BY name, category, i.id\n\t)\n\tSELECT m.id, m.category, count(*) \n\tFROM more_entrances m \n\tGROUP BY m.category, m.id;\n\n\tRETURN QUERY \n\tWITH group_reached_opportunities AS \n\t(\n\t\tSELECT r.id, jsonb_object_agg(opportunity_type, cnt) reached_opportunities  \n\t\tFROM reached_opportunities r \n\t\tGROUP BY id \n\t),\n\tcombined_opportunities AS \n\t(\n\t\tSELECT COALESCE(g.id, r.id) AS id, COALESCE(reached_opportunities, '{}'::jsonb) || COALESCE(aois_json_agg, '{}'::jsonb) AS reached_opportunities \n\t\tFROM group_reached_opportunities g\n\t\tFULL JOIN reached_aois r  \n\t\tON r.id = g.id \n\t)\n\tUPDATE customer.isochrone_feature i  \n\tSET reached_opportunities = c.reached_opportunities \n\tFROM combined_opportunities c \n\tWHERE i.id = c.id\n\tRETURNING i.id, i.step, i.reached_opportunities; \nEND ;\n$function$"
    )
    op.replace_entity(basic_thematic_data_sum)
    basic_reached_population_study_area = PGFunction(
        schema="basic",
        signature="reached_population_study_area(ischrone_calculation_id_input integer, scenario_id_input integer, modus text, study_area_ids integer[])",
        definition="returns TABLE(id integer, step integer, reached_opportunities jsonb)\n LANGUAGE plpgsql\nAS $function$ \nDECLARE \t\n\texcluded_buildings_id integer[] := '{}'::integer[];\nBEGIN\n\t\n\tDROP TABLE IF EXISTS reachable_population; \n\n\t/*Get reachable population*/\n\tIF modus = 'default' THEN\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tSELECT i.id AS isochrone_feature_id, s.id AS sub_study_area_id, s.name, s.population \n\t\tFROM basic.sub_study_area s, customer.isochrone_feature i \n\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids))\n\t\tAND i.isochrone_calculation_id = ischrone_calculation_id_input; \n\t\n\tELSEIF modus = 'scenario' THEN \n\t\texcluded_buildings_id  = basic.modified_buildings(scenario_id_input);\n\t\t\n\t\tCREATE TEMP TABLE reachable_population AS \n\t\tWITH prepared_scenario AS \n\t\t(\n\t\t\tSELECT p.sub_study_area_id, -sum(p.population) AS population \n\t\t\tFROM basic.population p \n\t\t\tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t\tAND p.building_id IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t\tGROUP BY p.sub_study_area_id \n\t\t\tUNION ALL \n\t\t\tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t \t),\n\t \tscenario_population AS \n\t \t(\n\t\t \tSELECT p.sub_study_area_id, sum(population) population \n\t\t \tFROM prepared_scenario p \n\t\t \tGROUP BY p.sub_study_area_id\n\t\t),\n\t\tcombined_population AS \n\t\t( \n\t\t\tSELECT s.id AS sub_study_area_id, s.name, (s.population + COALESCE(sp.population, 0)) AS population \n\t\t\tFROM basic.sub_study_area s\n\t\t\tLEFT JOIN scenario_population sp \n\t\t\tON s.id = sp.sub_study_area_id\n\t\t\tWHERE s.id IN (SELECT UNNEST(study_area_ids)) \t\n\t\t)\n\t\tSELECT i.id AS isochrone_feature_id, c.*\n\t\tFROM customer.isochrone_feature i, combined_population c\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input; \n\tELSE \n\t\tRAISE EXCEPTION 'Unknown modus\\: %', modus;\t\n\tEND IF;\n\t\n\t/*Get reached population*/\n\tDROP TABLE IF EXISTS reached_population; \n\tCREATE TEMP TABLE reached_population AS \n\tWITH to_group AS \n\t(\n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM basic.population p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.building_id NOT IN (SELECT UNNEST(excluded_buildings_id))\t\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input\n\t\tUNION ALL \n\t\tSELECT i.id, s.population, s.sub_study_area_id\n\t\tFROM customer.isochrone_feature i\n\t\tCROSS JOIN LATERAL \n\t\t(\n\t\t \tSELECT p.sub_study_area_id, sum(p.population) AS population\n\t\t \tFROM customer.population_modified p \n\t\t \tWHERE st_intersects(i.geom,p.geom)\n\t\t \tAND p.sub_study_area_id IN (SELECT UNNEST(study_area_ids))\n\t\t \tAND p.scenario_id = scenario_id_input\n\t\t \tGROUP BY p.sub_study_area_id \n\t\t) s\n\t\tWHERE i.isochrone_calculation_id = ischrone_calculation_id_input \n\t)\n\tSELECT g.id, (floor(COALESCE(sum(g.population)::integer,0)/5)*5) AS population, g.sub_study_area_id \n\tFROM to_group g\n\tGROUP BY g.id, g.sub_study_area_id; \n\t\n\t/*Combine and return results*/\n\tRETURN query \n\tWITH combined AS \n\t(\n\t\tSELECT a.isochrone_feature_id, a.sub_study_area_id, a.name, \n\t\tCASE WHEN COALESCE(r.population, 0) > a.population THEN a.population \n\t\tELSE COALESCE(r.population, 0) END AS reached_population, a.population AS total_population \n\t\tFROM reachable_population a\n\t\tLEFT JOIN reached_population r \n\t\tON a.isochrone_feature_id = r.id \n\t),\n\tas_object AS \n\t(\n\t\tSELECT c.isochrone_feature_id, jsonb_object_agg(c.sub_study_area_id, \n\t\tjsonb_build_object('name', c.name, 'reached_population', c.reached_population, 'total_population', c.total_population)) AS population \n\t\tFROM combined c\n\t\tGROUP BY c.isochrone_feature_id \n\t)\n\tUPDATE customer.isochrone_feature i\n\tSET reached_opportunities = o.population \n\tFROM as_object o \n\tWHERE o.isochrone_feature_id = i.id\n\tRETURNING i.id, i.step, i.reached_opportunities;\n \nEND; \n$function$"
    )
    op.replace_entity(basic_reached_population_study_area)
    basic_heatmap_population = PGFunction(
        schema="basic",
        signature="heatmap_population(active_study_area_id integer, modus_input text DEFAULT 'default'::text, scenario_id_input integer DEFAULT 0)",
        definition="returns TABLE(grid_visualization_id bigint, population double precision, percentile_population integer, modus text, geom geometry)\n LANGUAGE plpgsql\nAS $function$\nBEGIN \n\t\n\tIF modus_input IN ('default', 'comparison') THEN \n\t\tDROP TABLE IF EXISTS population_default;\n\t\tCREATE TEMP TABLE population_default AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'default', scenario_id_input);\n\tEND IF; \n\tIF modus_input IN ('scenario','comparison') THEN \n\t\tDROP TABLE IF EXISTS population_scenario;\n\t\tCREATE TEMP TABLE population_scenario AS \n\t\tSELECT * FROM basic.prepare_heatmap_population(active_study_area_id, 'scenario', scenario_id_input);\n\tEND IF;\n\tIF modus_input IN ('comparison') THEN \n\t\tALTER TABLE population_default ADD PRIMARY KEY(grid_visualization_id); \n\t\tALTER TABLE population_scenario ADD PRIMARY KEY(grid_visualization_id); \n\t\tDROP TABLE IF EXISTS population_comparison;\n\t\t\n\t\tCREATE TEMP TABLE population_comparison AS \n\t\tWITH pop_difference AS \n\t\t(\n\t\t\tSELECT d.grid_visualization_id, (COALESCE(s.population,0) - COALESCE(d.population,0)) AS population, d.geom\n\t\t\tFROM population_default d, population_scenario s\n\t\t\tWHERE d.grid_visualization_id = s.grid_visualization_id\n\t\t) \n\t\tSELECT p.grid_visualization_id, p.population, \n\t\tCASE \n\t\tWHEN p.population = 0 THEN 0\n\t\tWHEN p.population < -400 THEN -5 \n\t\tWHEN p.population BETWEEN -400 AND -200 THEN -4 \n\t\tWHEN p.population BETWEEN -200 AND -80 THEN -3 \n\t\tWHEN p.population BETWEEN -80 AND -20 THEN -2 \n\t\tWHEN p.population BETWEEN -20 AND -1 THEN -1 \n\t\tWHEN p.population BETWEEN 1 AND 20 THEN 1 \n\t\tWHEN p.population BETWEEN 20 AND 80 THEN 2\n\t\tWHEN p.population BETWEEN 80 AND 200 THEN 3 \n\t\tWHEN p.population BETWEEN 200 AND 400 THEN 4 \n\t\tWHEN p.population  > 400 THEN 5 END AS percentile_population, p.geom \n\t\tFROM pop_difference p;\n\tEND IF; \n\t\t\n\tIF modus_input = 'default' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_default p;\n\tELSEIF modus_input = 'scenario' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_scenario p;\n\tELSEIF modus_input = 'comparison' THEN \n\t\tRETURN query \n\t\tSELECT p.grid_visualization_id, p.population, p.percentile_population, modus_input AS modus, p.geom \n\t\tFROM population_comparison p;\n\tEND IF; \n\nEND\n$function$"
    )
    op.replace_entity(basic_heatmap_population)
    basic_poi_categories_data_uploads = PGFunction(
        schema="basic",
        signature="poi_categories_data_uploads(user_id_input integer)",
        definition="returns text[]\n LANGUAGE plpgsql\nAS $function$\nDECLARE \n\tcategories text[];\nBEGIN \n\n\tSELECT ARRAY_AGG(data_upload_id)\n\tINTO categories \n\tFROM customer.opportunity_user_config o, customer.USER u\n\tWHERE o.user_id = u.id\n\tAND u.id = user_id_input\n\tAND o.study_area_id = u.active_study_area_id;\n\n\tRETURN COALESCE(categories, '{}'::TEXT[]);\n\nEND ;\n$function$"
    )
    op.replace_entity(basic_poi_categories_data_uploads)
    op.create_foreign_key('opportunity_user_config_user_id_fkey1', 'opportunity_user_config', 'user', ['user_id'], ['id'], source_schema='customer', referent_schema='customer')
    # ### end Alembic commands ###
